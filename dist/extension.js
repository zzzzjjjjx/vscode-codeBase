/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerChunkingCommands = registerChunkingCommands;
const vscode = __importStar(__webpack_require__(2));
const chunkingService_1 = __webpack_require__(3);
let chunkingService;
/**
 * æ³¨å†Œä»£ç åˆ†å—ç›¸å…³çš„æ‰€æœ‰å‘½ä»¤
 */
function registerChunkingCommands(context) {
    // åˆå§‹åŒ–æœåŠ¡
    chunkingService = new chunkingService_1.ChunkingService();
    // æ³¨å†Œä»£ç åˆ†å—å‘½ä»¤
    const chunkCodeCommand = vscode.commands.registerCommand('test-electron-treesitter.chunkCode', async () => {
        try {
            const res = await chunkingService.executeCodeChunking(context);
            return res;
        }
        catch (error) {
            console.error('[CodeChunker] æ‰§è¡Œé”™è¯¯:', error);
            vscode.window.showErrorMessage(`ä»£ç åˆ†å—æ‰§è¡Œå¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œè¿›åº¦æŸ¥è¯¢å‘½ä»¤
    const checkProgressCommand = vscode.commands.registerCommand('test-electron-treesitter.checkProgress', async () => {
        try {
            await chunkingService.checkChunkingProgress();
        }
        catch (error) {
            console.error('[CodeChunker] è¿›åº¦æŸ¥è¯¢é”™è¯¯:', error);
            vscode.window.showErrorMessage(`è¿›åº¦æŸ¥è¯¢å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œæ¸…é™¤ç¼“å­˜å‘½ä»¤
    const clearCacheCommand = vscode.commands.registerCommand('test-electron-treesitter.clearCache', async () => {
        try {
            await chunkingService.clearProcessingCache();
        }
        catch (error) {
            console.error('[CodeChunker] æ¸…é™¤ç¼“å­˜é”™è¯¯:', error);
            vscode.window.showErrorMessage(`æ¸…é™¤ç¼“å­˜å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†ŒæŸ¥çœ‹ç´¢å¼•ç¼“å­˜ç»Ÿè®¡å‘½ä»¤
    const cacheStatsCommand = vscode.commands.registerCommand('test-electron-treesitter.cacheStats', async () => {
        try {
            const stats = await chunkingService.getCacheStats();
            if (stats) {
                vscode.window.showInformationMessage(`ç´¢å¼•ç¼“å­˜ç»Ÿè®¡:\n` +
                    `- ç¼“å­˜æ–‡ä»¶æ•°: ${stats.totalFiles}\n` +
                    `- ç¼“å­˜å¤§å°: ${stats.totalSize}\n` +
                    `- æœ€æ—©è®°å½•: ${stats.oldestRecord ? stats.oldestRecord.toLocaleString() : 'æ— '}\n` +
                    `- æœ€æ–°è®°å½•: ${stats.newestRecord ? stats.newestRecord.toLocaleString() : 'æ— '}`);
            }
            else {
                vscode.window.showInformationMessage('ç´¢å¼•ç¼“å­˜æœªå¯ç”¨');
            }
        }
        catch (error) {
            console.error('[CodeChunker] è·å–ç¼“å­˜ç»Ÿè®¡å¤±è´¥:', error);
            vscode.window.showErrorMessage(`è·å–ç¼“å­˜ç»Ÿè®¡å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œæ¸…é™¤ç´¢å¼•ç¼“å­˜å‘½ä»¤
    const clearIndexCacheCommand = vscode.commands.registerCommand('test-electron-treesitter.clearIndexCache', async () => {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
                return;
            }
            const config = vscode.workspace.getConfiguration('codeChunker');
            const userId = config.get('userId');
            const deviceId = config.get('deviceId');
            if (!userId || !deviceId) {
                vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯');
                return;
            }
            const confirmation = await vscode.window.showWarningMessage('ç¡®å®šè¦æ¸…é™¤å½“å‰å·¥ä½œåŒºçš„ç´¢å¼•ç¼“å­˜å—ï¼Ÿè¿™å°†å¯¼è‡´ä¸‹æ¬¡å¤„ç†æ—¶é‡æ–°ç´¢å¼•æ‰€æœ‰æ–‡ä»¶ã€‚', 'ç¡®å®šæ¸…é™¤', 'å–æ¶ˆ');
            if (confirmation === 'ç¡®å®šæ¸…é™¤') {
                const workspacePath = workspaceFolder.uri.fsPath;
                await chunkingService.clearWorkspaceIndexCache(workspacePath, userId, deviceId);
                vscode.window.showInformationMessage('ç´¢å¼•ç¼“å­˜å·²æ¸…é™¤');
            }
        }
        catch (error) {
            console.error('[CodeChunker] æ¸…é™¤ç´¢å¼•ç¼“å­˜å¤±è´¥:', error);
            vscode.window.showErrorMessage(`æ¸…é™¤ç´¢å¼•ç¼“å­˜å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œç½‘ç»œæ€§èƒ½åˆ†ææŠ¥å‘Šå‘½ä»¤
    const networkPerformanceCommand = vscode.commands.registerCommand('test-electron-treesitter.networkPerformance', async () => {
        try {
            const report = await chunkingService.generateNetworkPerformanceReport();
            if (report) {
                vscode.window.showInformationMessage(`ç½‘ç»œæ€§èƒ½æŠ¥å‘Šå·²ç”Ÿæˆï¼Œè¯¦ç»†ä¿¡æ¯è¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºã€‚\n` +
                    `æ€»è¯·æ±‚æ•°: ${report.summary.totalRequests}\n` +
                    `å¹³å‡ç½‘ç»œé€šä¿¡æ—¶é—´: ${report.performance.networkCommunicationTime.avg.toFixed(2)}ms\n` +
                    `ç½‘ç»œæ—¶é—´å æ¯”: ${report.performance.networkRatio.avg.toFixed(1)}%`);
            }
            else {
                vscode.window.showInformationMessage('æš‚æ— ç½‘ç»œæ€§èƒ½æ•°æ®ï¼Œè¯·å…ˆæ‰§è¡Œä¸€äº›ä»£ç åˆ†å—æ“ä½œã€‚');
            }
        }
        catch (error) {
            console.error('[CodeChunker] ç”Ÿæˆç½‘ç»œæ€§èƒ½æŠ¥å‘Šå¤±è´¥:', error);
            vscode.window.showErrorMessage(`ç”Ÿæˆç½‘ç»œæ€§èƒ½æŠ¥å‘Šå¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œæ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®å‘½ä»¤
    const clearNetworkDataCommand = vscode.commands.registerCommand('test-electron-treesitter.clearNetworkData', async () => {
        try {
            await chunkingService.clearNetworkPerformanceData();
            vscode.window.showInformationMessage('ç½‘ç»œæ€§èƒ½æ•°æ®å·²æ¸…é™¤');
        }
        catch (error) {
            console.error('[CodeChunker] æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®å¤±è´¥:', error);
            vscode.window.showErrorMessage(`æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    context.subscriptions.push(chunkCodeCommand, checkProgressCommand, clearCacheCommand, cacheStatsCommand, clearIndexCacheCommand, networkPerformanceCommand, clearNetworkDataCommand);
    console.log('[CodeChunker] ä»£ç åˆ†å—å‘½ä»¤å·²æ³¨å†Œ');
}


/***/ }),
/* 2 */
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),
/* 3 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChunkingService = void 0;
const vscode = __importStar(__webpack_require__(2));
const path = __importStar(__webpack_require__(4));
const fs = __importStar(__webpack_require__(5));
const commonViews_1 = __webpack_require__(6);
const indexCacheService_1 = __webpack_require__(7);
// å¯¼å…¥ code-chunker æ¨¡å—
const codeChunker = __webpack_require__(9);
// å…¨å±€å˜é‡æ¥è·Ÿè¸ªæ´»è·ƒçš„chunkerå®ä¾‹
let activeChunkerInstance = null;
let isProcessing = false;
class ChunkingService {
    indexCacheService = null;
    /**
     * åˆå§‹åŒ–ç´¢å¼•ç¼“å­˜æœåŠ¡
     */
    initializeIndexCache(context) {
        if (!this.indexCacheService) {
            this.indexCacheService = new indexCacheService_1.IndexCacheService(context);
        }
    }
    /**
     * æ‰§è¡Œä»£ç åˆ†å—
     */
    async executeCodeChunking(context) {
        if (isProcessing) {
            vscode.window.showWarningMessage('ä»£ç åˆ†å—æ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç­‰å¾…å½“å‰å¤„ç†å®Œæˆ');
            return;
        }
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
            return;
        }
        // è·å–é…ç½®
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        const ignorePatterns = config.get('ignorePatterns') || [];
        // æ£€æŸ¥å¿…è¦çš„é…ç½®
        if (!userId || !deviceId || !token) {
            const result = await vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯ï¼ˆç”¨æˆ·IDã€è®¾å¤‡IDæˆ–Tokenï¼‰ï¼Œæ˜¯å¦ç°åœ¨é…ç½®ï¼Ÿ', 'å»é…ç½®', 'å–æ¶ˆ');
            if (result === 'å»é…ç½®') {
                await commonViews_1.CommonViews.showConfiguration();
            }
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        const workspaceName = path.basename(workspacePath);
        // æ£€æŸ¥å·¥ä½œåŒºæ˜¯å¦å­˜åœ¨
        if (!fs.existsSync(workspacePath)) {
            vscode.window.showErrorMessage(`å·¥ä½œåŒºè·¯å¾„ä¸å­˜åœ¨: ${workspacePath}`);
            return;
        }
        isProcessing = true;
        // åˆå§‹åŒ–ç´¢å¼•ç¼“å­˜æœåŠ¡
        if (context) {
            this.initializeIndexCache(context);
        }
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: 'ä»£ç åˆ†å—å¤„ç†ä¸­...',
            cancellable: false
        }, async (progress) => {
            try {
                progress.report({ increment: 0, message: 'åˆå§‹åŒ–å¤„ç†ç¯å¢ƒ...' });
                // è·å–æˆ–åˆ›å»ºchunkerå®ä¾‹
                activeChunkerInstance = codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
                progress.report({ increment: 10, message: 'æ£€æŸ¥æ–‡ä»¶ç´¢å¼•ç¼“å­˜...' });
                // å¦‚æœå¯ç”¨äº†ç´¢å¼•ç¼“å­˜ï¼Œå…ˆæ£€æŸ¥å“ªäº›æ–‡ä»¶éœ€è¦å¤„ç†
                let filesToProcess = [];
                let skippedFiles = [];
                if (this.indexCacheService) {
                    try {
                        // æ‰«æå·¥ä½œåŒºè·å–æ–‡ä»¶åˆ—è¡¨
                        const allFiles = await this.scanWorkspaceFiles(workspacePath, ignorePatterns);
                        // æ£€æŸ¥å“ªäº›æ–‡ä»¶å·²ç»ç´¢å¼•è¿‡
                        const { indexed, unindexed } = await this.indexCacheService.filterUnindexedFiles(allFiles, workspacePath, userId, deviceId);
                        filesToProcess = unindexed;
                        skippedFiles = indexed;
                        progress.report({
                            increment: 10,
                            message: `ç¼“å­˜æ£€æŸ¥å®Œæˆï¼šè·³è¿‡ ${skippedFiles.length} ä¸ªæ–‡ä»¶ï¼Œå¤„ç† ${filesToProcess.length} ä¸ªæ–‡ä»¶...`
                        });
                        // æ˜¾ç¤ºç¼“å­˜ç»Ÿè®¡
                        if (skippedFiles.length > 0) {
                        }
                    }
                    catch (error) {
                        console.warn('[ChunkingService] ç´¢å¼•ç¼“å­˜æ£€æŸ¥å¤±è´¥ï¼Œå°†å¤„ç†æ‰€æœ‰æ–‡ä»¶:', error);
                        filesToProcess = []; // ç©ºæ•°ç»„è¡¨ç¤ºå¤„ç†æ‰€æœ‰æ–‡ä»¶
                    }
                }
                progress.report({ increment: 10, message: 'å¼€å§‹å¤„ç†å·¥ä½œåŒºæ–‡ä»¶...' });
                // æ‰§è¡Œä»£ç åˆ†å—å¤„ç†
                let success;
                try {
                    success = filesToProcess.length === 0
                        ? await codeChunker.processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns)
                        : await this.processSpecificFiles(userId, deviceId, workspacePath, token, filesToProcess);
                }
                catch (processingError) {
                    const error = processingError instanceof Error ? processingError : new Error(String(processingError));
                    console.error('ğŸ”¥ ä»£ç åˆ†å—å¤„ç†å‡ºç°å¼‚å¸¸:', error);
                    console.error('ğŸ”¥ å¼‚å¸¸è¯¦æƒ…:', {
                        name: error.name,
                        message: error.message,
                        stack: error.stack
                    });
                    vscode.window.showErrorMessage(`ä»£ç åˆ†å—å¤„ç†å¤±è´¥: ${error.message || 'Unknown error'}`);
                    return false;
                }
                // å¦‚æœå¤„ç†æˆåŠŸä¸”å¯ç”¨äº†ç¼“å­˜ï¼Œæ ‡è®°æ–°å¤„ç†çš„æ–‡ä»¶ä¸ºå·²ç´¢å¼•
                if (success && this.indexCacheService && filesToProcess.length > 0) {
                    try {
                        await this.indexCacheService.markFilesAsIndexed(filesToProcess, workspacePath, userId, deviceId);
                    }
                    catch (error) {
                        console.warn('[ChunkingService] æ ‡è®°æ–‡ä»¶ç´¢å¼•çŠ¶æ€å¤±è´¥:', error);
                    }
                }
                if (success) {
                    progress.report({ increment: 100, message: 'å¤„ç†å®Œæˆï¼' });
                    vscode.window.showInformationMessage(`å·¥ä½œåŒº "${workspaceName}" ä»£ç åˆ†å—å¤„ç†å®Œæˆï¼`);
                    return true;
                }
                else {
                    vscode.window.showErrorMessage('ä»£ç åˆ†å—å¤„ç†å¤±è´¥');
                    return false;
                }
            }
            catch (error) {
                console.error('[CodeChunker] å¤„ç†è¿‡ç¨‹å‡ºé”™:', error);
                vscode.window.showErrorMessage(`å¤„ç†å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
                return false;
            }
            finally {
                isProcessing = false;
            }
        });
    }
    /**
     * æŸ¥çœ‹åˆ†å—è¿›åº¦
     */
    async checkChunkingProgress() {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
            return;
        }
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        if (!userId || !deviceId || !token) {
            vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯ï¼Œè¯·å…ˆé…ç½®');
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        try {
            // ä½¿ç”¨ç¼“å­˜çš„å®ä¾‹æˆ–åˆ›å»ºæ–°å®ä¾‹
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance || !chunkerInstance.progressTracker) {
                vscode.window.showInformationMessage('æš‚æ— è¿›åº¦ä¿¡æ¯ï¼Œè¯·å…ˆå¼€å§‹ä»£ç åˆ†å—å¤„ç†');
                return;
            }
            // è·å–è¿›åº¦ä¿¡æ¯
            const overallProgress = chunkerInstance.progressTracker.getOverallProgress();
            const fileProgress = chunkerInstance.progressTracker.getFileProgress();
            const fileProgressSummary = chunkerInstance.progressTracker.getFileProgressSummary();
            // è®¡ç®—æ–‡ä»¶çº§åˆ«çš„è¿›åº¦ç™¾åˆ†æ¯”
            const fileProgressPercentage = chunkerInstance.progressTracker.getFileProgressPercentage();
            // æ˜¾ç¤ºè¿›åº¦ä¿¡æ¯
            await commonViews_1.CommonViews.showProgressDetails(overallProgress, fileProgress, fileProgressSummary, fileProgressPercentage);
        }
        catch (error) {
            console.error('[CodeChunker] è·å–è¿›åº¦ä¿¡æ¯å¤±è´¥:', error);
            vscode.window.showErrorMessage(`è·å–è¿›åº¦ä¿¡æ¯å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * æ¸…é™¤å¤„ç†ç¼“å­˜
     */
    async clearProcessingCache() {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
            return;
        }
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        if (!userId || !deviceId || !token) {
            vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯');
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        try {
            // è·å–chunkerå®ä¾‹
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance.vectorManager) {
                vscode.window.showErrorMessage('VectorManageræœªåˆå§‹åŒ–ï¼Œæ— æ³•æ¸…é™¤ç¼“å­˜');
                return;
            }
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: 'æ¸…é™¤ç¼“å­˜ä¸­...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: 'è·å–ç¼“å­˜ä¿¡æ¯...' });
                // è·å–å‘é‡ä¿¡æ¯
                const vectorInfo = await chunkerInstance.vectorManager.getVectorInfo();
                progress.report({ increment: 50, message: 'æ¸…ç©ºä¸´æ—¶å‘é‡å­˜å‚¨...' });
                // æ¸…ç©ºä¸´æ—¶å‘é‡å­˜å‚¨
                if (chunkerInstance.vectorManager.tempVectors) {
                    chunkerInstance.vectorManager.tempVectors.clear();
                }
                progress.report({ increment: 100, message: 'ä¸´æ—¶å­˜å‚¨æ¸…ç©ºå®Œæˆï¼' });
                // æ˜¾ç¤ºæ¸…ç©ºç»“æœ
                vscode.window.showInformationMessage(`ä¸´æ—¶å­˜å‚¨æ¸…ç©ºå®Œæˆï¼\n` +
                    `æ¸…ç©ºå‘é‡æ•°: ${vectorInfo.totalVectors}\n` +
                    `é‡Šæ”¾ç©ºé—´: ${(vectorInfo.cacheSize / 1024 / 1024).toFixed(2)} MB`);
            });
        }
        catch (error) {
            console.error('[CodeChunker] æ¸…é™¤ç¼“å­˜å¤±è´¥:', error);
            vscode.window.showErrorMessage(`æ¸…é™¤ç¼“å­˜å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * è®¡ç®—æ–‡ä»¶è¿›åº¦
     */
    async calculateFileProgress(workspacePath, totalVectors) {
        const config = vscode.workspace.getConfiguration('codeChunker');
        const ignorePatterns = config.get('ignorePatterns') || [];
        let totalFiles = 0;
        let processedFiles = 0;
        async function scanDirectory(dirPath) {
            try {
                const items = await fs.promises.readdir(dirPath, { withFileTypes: true });
                for (const item of items) {
                    const fullPath = path.join(dirPath, item.name);
                    const relativePath = path.relative(workspacePath, fullPath);
                    // æ£€æŸ¥æ˜¯å¦åº”è¯¥å¿½ç•¥
                    const shouldIgnore = ignorePatterns.some(pattern => {
                        return relativePath.includes(pattern.replace(/\*\*/g, '').replace(/\*/g, ''));
                    });
                    if (shouldIgnore) {
                        continue;
                    }
                    if (item.isDirectory()) {
                        await scanDirectory(fullPath);
                    }
                    else if (item.isFile()) {
                        // åªç»Ÿè®¡ä»£ç æ–‡ä»¶
                        const ext = path.extname(item.name).toLowerCase();
                        const codeExtensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs', '.php', '.rb'];
                        if (codeExtensions.includes(ext)) {
                            totalFiles++;
                            // ç®€å•ä¼°ç®—ï¼šå‡è®¾æ¯ä¸ªæ–‡ä»¶å¹³å‡äº§ç”Ÿ10ä¸ªå‘é‡
                            const estimatedVectorsPerFile = 10;
                            if (totalVectors > (processedFiles * estimatedVectorsPerFile)) {
                                processedFiles++;
                            }
                        }
                    }
                }
            }
            catch (error) {
                console.warn(`æ‰«æç›®å½•å¤±è´¥: ${dirPath}`, error);
            }
        }
        await scanDirectory(workspacePath);
        return {
            totalFiles,
            processedFiles,
            progressPercentage: totalFiles > 0 ? (processedFiles / totalFiles) * 100 : 0
        };
    }
    /**
     * æ‰«æå·¥ä½œåŒºæ–‡ä»¶
     */
    async scanWorkspaceFiles(workspacePath, ignorePatterns) {
        const files = [];
        async function scanDirectory(dirPath) {
            try {
                const items = await fs.promises.readdir(dirPath, { withFileTypes: true });
                for (const item of items) {
                    const fullPath = path.join(dirPath, item.name);
                    const relativePath = path.relative(workspacePath, fullPath);
                    // æ£€æŸ¥æ˜¯å¦åº”è¯¥å¿½ç•¥
                    const shouldIgnore = ignorePatterns.some(pattern => {
                        return relativePath.includes(pattern.replace(/\*\*/g, '').replace(/\*/g, ''));
                    });
                    if (shouldIgnore) {
                        continue;
                    }
                    if (item.isDirectory()) {
                        await scanDirectory(fullPath);
                    }
                    else if (item.isFile()) {
                        // åªåŒ…å«ä»£ç æ–‡ä»¶
                        const ext = path.extname(item.name).toLowerCase();
                        const codeExtensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs', '.php', '.rb', '.cs', '.css', '.html', '.json', '.xml', '.yaml', '.yml', '.md'];
                        if (codeExtensions.includes(ext)) {
                            files.push(relativePath);
                        }
                    }
                }
            }
            catch (error) {
                console.warn(`æ‰«æç›®å½•å¤±è´¥: ${dirPath}`, error);
            }
        }
        await scanDirectory(workspacePath);
        return files;
    }
    /**
     * å¤„ç†ç‰¹å®šæ–‡ä»¶åˆ—è¡¨
     */
    async processSpecificFiles(userId, deviceId, workspacePath, token, filesToProcess) {
        try {
            // è¿™é‡Œå¯ä»¥è°ƒç”¨ code-chunker çš„ç‰¹å®šæ–‡ä»¶å¤„ç†æ–¹æ³•
            // å¦‚æœ code-chunker æ²¡æœ‰æä¾›æ­¤æ–¹æ³•ï¼Œå¯ä»¥ä½¿ç”¨å®Œæ•´å¤„ç†ä½†åªæ ‡è®°ç‰¹å®šæ–‡ä»¶
            // ä¸´æ—¶è§£å†³æ–¹æ¡ˆï¼šä»ç„¶å¤„ç†æ‰€æœ‰æ–‡ä»¶ï¼Œä½†ç´¢å¼•ç¼“å­˜ä¼šè®°å½•å…·ä½“çš„æ–‡ä»¶çŠ¶æ€
            const success = await codeChunker.processWorkspace(userId, deviceId, workspacePath, token);
            return success;
        }
        catch (error) {
            console.error('[ChunkingService] å¤„ç†ç‰¹å®šæ–‡ä»¶å¤±è´¥:', error);
            return false;
        }
    }
    /**
     * è·å–ç´¢å¼•ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
     */
    async getCacheStats() {
        if (!this.indexCacheService) {
            return null;
        }
        return this.indexCacheService.getCacheStats();
    }
    /**
     * æ¸…é™¤å·¥ä½œåŒºç´¢å¼•ç¼“å­˜
     */
    async clearWorkspaceIndexCache(workspacePath, userId, deviceId) {
        if (this.indexCacheService) {
            await this.indexCacheService.clearWorkspaceCache(workspacePath, userId, deviceId);
        }
    }
    /**
     * ç”Ÿæˆç½‘ç»œæ€§èƒ½åˆ†ææŠ¥å‘Š
     */
    async generateNetworkPerformanceReport() {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
                return null;
            }
            const config = vscode.workspace.getConfiguration('codeChunker');
            const userId = config.get('userId');
            const deviceId = config.get('deviceId');
            const token = config.get('token');
            if (!userId || !deviceId || !token) {
                vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯');
                return null;
            }
            const workspacePath = workspaceFolder.uri.fsPath;
            // è·å–chunkerå®ä¾‹
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance.vectorManager || !chunkerInstance.vectorManager.embeddingClient) {
                vscode.window.showErrorMessage('EmbeddingClientæœªåˆå§‹åŒ–ï¼Œæ— æ³•ç”Ÿæˆç½‘ç»œæ€§èƒ½æŠ¥å‘Š');
                return null;
            }
            // è°ƒç”¨embeddingClientçš„ç½‘ç»œæ€§èƒ½æŠ¥å‘Šæ–¹æ³•
            const report = chunkerInstance.vectorManager.embeddingClient.generateNetworkPerformanceReport();
            return report;
        }
        catch (error) {
            console.error('[ChunkingService] ç”Ÿæˆç½‘ç»œæ€§èƒ½æŠ¥å‘Šå¤±è´¥:', error);
            throw error;
        }
    }
    /**
     * æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®
     */
    async clearNetworkPerformanceData() {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
                return;
            }
            const config = vscode.workspace.getConfiguration('codeChunker');
            const userId = config.get('userId');
            const deviceId = config.get('deviceId');
            const token = config.get('token');
            if (!userId || !deviceId || !token) {
                vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯');
                return;
            }
            const workspacePath = workspaceFolder.uri.fsPath;
            // è·å–chunkerå®ä¾‹
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance.vectorManager || !chunkerInstance.vectorManager.embeddingClient) {
                vscode.window.showErrorMessage('EmbeddingClientæœªåˆå§‹åŒ–ï¼Œæ— æ³•æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®');
                return;
            }
            // è°ƒç”¨embeddingClientçš„æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®æ–¹æ³•
            chunkerInstance.vectorManager.embeddingClient.clearNetworkPerformanceData();
        }
        catch (error) {
            console.error('[ChunkingService] æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®å¤±è´¥:', error);
            throw error;
        }
    }
}
exports.ChunkingService = ChunkingService;


/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 5 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 6 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonViews = void 0;
const vscode = __importStar(__webpack_require__(2));
class CommonViews {
    /**
     * æ˜¾ç¤ºé…ç½®ç•Œé¢
     */
    static async showConfiguration() {
        const config = vscode.workspace.getConfiguration('codeChunker');
        // è·å–å½“å‰é…ç½®å€¼
        const currentUserId = config.get('userId') || '';
        const currentDeviceId = config.get('deviceId') || '';
        const currentToken = config.get('token') || '';
        // æ˜¾ç¤ºç”¨æˆ·IDè¾“å…¥æ¡†
        const userId = await vscode.window.showInputBox({
            prompt: 'è¯·è¾“å…¥ç”¨æˆ·ID',
            value: currentUserId,
            placeHolder: 'ä¾‹å¦‚: user123',
            validateInput: (value) => {
                if (!value || value.trim().length === 0) {
                    return 'ç”¨æˆ·IDä¸èƒ½ä¸ºç©º';
                }
                if (value.trim().length < 3) {
                    return 'ç”¨æˆ·IDè‡³å°‘éœ€è¦3ä¸ªå­—ç¬¦';
                }
                return null;
            }
        });
        if (userId === undefined) {
            return; // ç”¨æˆ·å–æ¶ˆ
        }
        // æ˜¾ç¤ºè®¾å¤‡IDè¾“å…¥æ¡†
        const deviceId = await vscode.window.showInputBox({
            prompt: 'è¯·è¾“å…¥è®¾å¤‡ID',
            value: currentDeviceId,
            placeHolder: 'ä¾‹å¦‚: device456',
            validateInput: (value) => {
                if (!value || value.trim().length === 0) {
                    return 'è®¾å¤‡IDä¸èƒ½ä¸ºç©º';
                }
                if (value.trim().length < 3) {
                    return 'è®¾å¤‡IDè‡³å°‘éœ€è¦3ä¸ªå­—ç¬¦';
                }
                return null;
            }
        });
        if (deviceId === undefined) {
            return; // ç”¨æˆ·å–æ¶ˆ
        }
        // æ˜¾ç¤ºTokenè¾“å…¥æ¡†
        const token = await vscode.window.showInputBox({
            prompt: 'è¯·è¾“å…¥è®¿é—®ä»¤ç‰Œ',
            value: currentToken,
            placeHolder: 'ä¾‹å¦‚: your_access_token',
            password: true, // éšè—è¾“å…¥å†…å®¹
            validateInput: (value) => {
                if (!value || value.trim().length === 0) {
                    return 'è®¿é—®ä»¤ç‰Œä¸èƒ½ä¸ºç©º';
                }
                if (value.trim().length < 10) {
                    return 'è®¿é—®ä»¤ç‰Œè‡³å°‘éœ€è¦10ä¸ªå­—ç¬¦';
                }
                return null;
            }
        });
        if (token === undefined) {
            return; // ç”¨æˆ·å–æ¶ˆ
        }
        try {
            // ä¿å­˜é…ç½®
            await config.update('userId', userId.trim(), vscode.ConfigurationTarget.Global);
            await config.update('deviceId', deviceId.trim(), vscode.ConfigurationTarget.Global);
            await config.update('token', token.trim(), vscode.ConfigurationTarget.Global);
            vscode.window.showInformationMessage(`é…ç½®å·²ä¿å­˜ï¼\nç”¨æˆ·ID: ${userId}\nè®¾å¤‡ID: ${deviceId}\nToken: ${token.substring(0, 6)}...`);
        }
        catch (error) {
            console.error('[CommonViews] ä¿å­˜é…ç½®å¤±è´¥:', error);
            vscode.window.showErrorMessage(`ä¿å­˜é…ç½®å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * æ˜¾ç¤ºè¿›åº¦è¯¦æƒ…
     */
    static async showProgressDetails(overallProgress, fileProgress, fileProgressSummary, fileProgressPercentage) {
        const outputChannel = vscode.window.createOutputChannel('ä»£ç åˆ†å—è¿›åº¦');
        try {
            outputChannel.clear();
            outputChannel.appendLine('ğŸ“Š ä»£ç åˆ†å—å¤„ç†è¿›åº¦æŠ¥å‘Š');
            outputChannel.appendLine(`â° æ›´æ–°æ—¶é—´: ${new Date().toLocaleString()}`);
            outputChannel.appendLine(`${'='.repeat(60)}\n`);
            // æ–‡ä»¶çº§åˆ«è¿›åº¦
            outputChannel.appendLine('ğŸ“ æ–‡ä»¶å¤„ç†è¿›åº¦:');
            outputChannel.appendLine(`   æ€»æ–‡ä»¶æ•°: ${fileProgress.totalFiles}`);
            outputChannel.appendLine(`   å·²å®Œæˆ: ${fileProgress.completedFiles}`);
            outputChannel.appendLine(`   å¤„ç†ä¸­: ${fileProgress.processingFiles}`);
            outputChannel.appendLine(`   ç­‰å¾…ä¸­: ${fileProgress.pendingFiles}`);
            outputChannel.appendLine(`   å¤±è´¥: ${fileProgress.failedFiles}`);
            outputChannel.appendLine(`   è¿›åº¦: ${fileProgressPercentage.toFixed(2)}%\n`);
            // ä»£ç å—çº§åˆ«è¿›åº¦
            outputChannel.appendLine('ğŸ”— ä»£ç å—å¤„ç†è¿›åº¦:');
            outputChannel.appendLine(`   æ€»ä»£ç å—: ${overallProgress.totalChunks}`);
            outputChannel.appendLine(`   å·²å®Œæˆ: ${overallProgress.completedChunks}`);
            outputChannel.appendLine(`   å¤„ç†ä¸­: ${overallProgress.processingChunks}`);
            outputChannel.appendLine(`   ç­‰å¾…ä¸­: ${overallProgress.pendingChunks}`);
            outputChannel.appendLine(`   å¤±è´¥: ${overallProgress.failedChunks}`);
            outputChannel.appendLine(`   æˆåŠŸç‡: ${overallProgress.successRate.toFixed(2)}%\n`);
            // æ–‡ä»¶è¯¦ç»†è¿›åº¦
            if (fileProgressSummary && fileProgressSummary.length > 0) {
                outputChannel.appendLine('ğŸ“„ æ–‡ä»¶è¯¦ç»†è¿›åº¦:');
                outputChannel.appendLine(`${'æ–‡ä»¶å'.padEnd(25)} ${'è¯­è¨€'.padEnd(12)} ${'å®Œæˆ'.padEnd(6)} ${'æ€»è®¡'.padEnd(6)} ${'æˆåŠŸç‡'.padEnd(8)}`);
                outputChannel.appendLine('-'.repeat(60));
                fileProgressSummary.forEach(fileInfo => {
                    const fileName = fileInfo.file.length > 23 ? fileInfo.file.substring(0, 20) + '...' : fileInfo.file;
                    const language = fileInfo.language || 'unknown';
                    const completed = fileInfo.completed.toString();
                    const total = fileInfo.total.toString();
                    const successRate = fileInfo.successRate.toFixed(1) + '%';
                    outputChannel.appendLine(`${fileName.padEnd(25)} ${language.padEnd(12)} ${completed.padEnd(6)} ${total.padEnd(6)} ${successRate.padEnd(8)}`);
                });
            }
            outputChannel.appendLine(`\n${'='.repeat(60)}`);
            outputChannel.appendLine('ğŸ’¡ æç¤º: å¦‚æœå¤„ç†åœæ»ï¼Œå¯ä»¥å°è¯•é‡æ–°è¿è¡Œä»£ç åˆ†å—å‘½ä»¤');
            // æ˜¾ç¤ºè¾“å‡ºé¢æ¿
            outputChannel.show(true);
            // æ˜¾ç¤ºæ‘˜è¦é€šçŸ¥
            const summaryMessage = `å¤„ç†è¿›åº¦: æ–‡ä»¶ ${fileProgress.completedFiles}/${fileProgress.totalFiles} (${fileProgressPercentage.toFixed(1)}%), ` +
                `ä»£ç å— ${overallProgress.completedChunks}/${overallProgress.totalChunks} (${overallProgress.successRate.toFixed(1)}%)`;
            vscode.window.showInformationMessage(summaryMessage);
        }
        catch (error) {
            console.error('[CommonViews] æ˜¾ç¤ºè¿›åº¦è¯¦æƒ…å¤±è´¥:', error);
            vscode.window.showErrorMessage(`æ˜¾ç¤ºè¿›åº¦è¯¦æƒ…å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * æ˜¾ç¤ºç®€å•çš„ä¿¡æ¯æ¶ˆæ¯
     */
    static showInfo(message) {
        vscode.window.showInformationMessage(message);
    }
    /**
     * æ˜¾ç¤ºè­¦å‘Šæ¶ˆæ¯
     */
    static showWarning(message) {
        vscode.window.showWarningMessage(message);
    }
    /**
     * æ˜¾ç¤ºé”™è¯¯æ¶ˆæ¯
     */
    static showError(message) {
        vscode.window.showErrorMessage(message);
    }
    /**
     * æ˜¾ç¤ºå¸¦è¿›åº¦çš„ä»»åŠ¡
     */
    static async showProgress(title, task) {
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: title,
            cancellable: false
        }, task);
    }
}
exports.CommonViews = CommonViews;


/***/ }),
/* 7 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IndexCacheService = void 0;
const fs = __importStar(__webpack_require__(5));
const path = __importStar(__webpack_require__(4));
const crypto = __importStar(__webpack_require__(8));
class IndexCacheService {
    context;
    cacheFilePath;
    cache = new Map();
    isInitialized = false;
    constructor(context) {
        this.context = context;
        this.cacheFilePath = path.join(context.globalStorageUri.fsPath, 'indexed-files-cache.json');
    }
    /**
     * åˆå§‹åŒ–ç¼“å­˜æœåŠ¡
     */
    async initialize() {
        try {
            // ç¡®ä¿å…¨å±€å­˜å‚¨ç›®å½•å­˜åœ¨
            await fs.promises.mkdir(path.dirname(this.cacheFilePath), { recursive: true });
            // åŠ è½½ç°æœ‰ç¼“å­˜
            await this.loadCache();
            this.isInitialized = true;
        }
        catch (error) {
            console.error('[IndexCacheService] åˆå§‹åŒ–å¤±è´¥:', error);
            this.isInitialized = true; // å³ä½¿å¤±è´¥ä¹Ÿæ ‡è®°ä¸ºå·²åˆå§‹åŒ–ï¼Œé¿å…é˜»å¡
        }
    }
    /**
     * æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å·²ç»ç´¢å¼•è¿‡
     */
    async isFileIndexed(filePath, workspacePath, userId, deviceId) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        try {
            // è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
            const fileHash = await this.calculateFileHash(filePath);
            const cacheKey = this.generateCacheKey(filePath, workspacePath, userId, deviceId);
            const cachedRecord = this.cache.get(cacheKey);
            if (!cachedRecord) {
                return false;
            }
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«ä¿®æ”¹è¿‡
            if (cachedRecord.fileHash !== fileHash) {
                // ç§»é™¤è¿‡æœŸçš„ç¼“å­˜è®°å½•
                this.cache.delete(cacheKey);
                return false;
            }
            return true;
        }
        catch (error) {
            console.error(`[IndexCacheService] æ£€æŸ¥æ–‡ä»¶ç´¢å¼•çŠ¶æ€å¤±è´¥: ${filePath}`, error);
            return false; // å‡ºé”™æ—¶é»˜è®¤è¿›è¡Œç´¢å¼•
        }
    }
    /**
     * æ ‡è®°æ–‡ä»¶ä¸ºå·²ç´¢å¼•
     */
    async markFileAsIndexed(filePath, workspacePath, userId, deviceId) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        try {
            const fileHash = await this.calculateFileHash(filePath);
            const cacheKey = this.generateCacheKey(filePath, workspacePath, userId, deviceId);
            const record = {
                filePath,
                fileHash,
                indexedAt: Date.now(),
                workspacePath,
                userId,
                deviceId
            };
            this.cache.set(cacheKey, record);
            // å¼‚æ­¥ä¿å­˜ç¼“å­˜ï¼Œä¸é˜»å¡ä¸»æµç¨‹
            this.saveCache().catch(error => {
                console.error('[IndexCacheService] ä¿å­˜ç¼“å­˜å¤±è´¥:', error);
            });
        }
        catch (error) {
            console.error(`[IndexCacheService] æ ‡è®°æ–‡ä»¶ç´¢å¼•å¤±è´¥: ${filePath}`, error);
        }
    }
    /**
     * æ‰¹é‡æ£€æŸ¥æ–‡ä»¶ç´¢å¼•çŠ¶æ€
     */
    async filterUnindexedFiles(files, workspacePath, userId, deviceId) {
        const indexed = [];
        const unindexed = [];
        for (const file of files) {
            const fullPath = path.isAbsolute(file) ? file : path.join(workspacePath, file);
            try {
                const isIndexed = await this.isFileIndexed(fullPath, workspacePath, userId, deviceId);
                if (isIndexed) {
                    indexed.push(file);
                }
                else {
                    unindexed.push(file);
                }
            }
            catch (error) {
                console.error(`[IndexCacheService] æ£€æŸ¥æ–‡ä»¶å¤±è´¥: ${file}`, error);
                unindexed.push(file); // å‡ºé”™æ—¶é»˜è®¤éœ€è¦ç´¢å¼•
            }
        }
        return { indexed, unindexed };
    }
    /**
     * æ‰¹é‡æ ‡è®°æ–‡ä»¶ä¸ºå·²ç´¢å¼•
     */
    async markFilesAsIndexed(files, workspacePath, userId, deviceId) {
        for (const file of files) {
            const fullPath = path.isAbsolute(file) ? file : path.join(workspacePath, file);
            await this.markFileAsIndexed(fullPath, workspacePath, userId, deviceId);
        }
    }
    /**
     * æ¸…é™¤æŒ‡å®šå·¥ä½œåŒºçš„ç¼“å­˜
     */
    async clearWorkspaceCache(workspacePath, userId, deviceId) {
        const keysToDelete = [];
        for (const [key, record] of this.cache.entries()) {
            if (record.workspacePath === workspacePath &&
                record.userId === userId &&
                record.deviceId === deviceId) {
                keysToDelete.push(key);
            }
        }
        keysToDelete.forEach(key => this.cache.delete(key));
        await this.saveCache();
    }
    /**
     * è·å–ç¼“å­˜ç»Ÿè®¡ä¿¡æ¯
     */
    getCacheStats() {
        let oldestTime = Number.MAX_SAFE_INTEGER;
        let newestTime = 0;
        for (const record of this.cache.values()) {
            if (record.indexedAt < oldestTime) {
                oldestTime = record.indexedAt;
            }
            if (record.indexedAt > newestTime) {
                newestTime = record.indexedAt;
            }
        }
        const stats = {
            totalFiles: this.cache.size,
            totalSize: this.formatSize(JSON.stringify([...this.cache.values()]).length),
            oldestRecord: oldestTime === Number.MAX_SAFE_INTEGER ? undefined : new Date(oldestTime),
            newestRecord: newestTime === 0 ? undefined : new Date(newestTime)
        };
        return stats;
    }
    /**
     * ç”Ÿæˆç¼“å­˜é”®
     */
    generateCacheKey(filePath, workspacePath, userId, deviceId) {
        const relativePath = path.relative(workspacePath, filePath);
        const identifier = `${userId}_${deviceId}_${workspacePath}_${relativePath}`;
        return crypto.createHash('md5').update(identifier).digest('hex');
    }
    /**
     * è®¡ç®—æ–‡ä»¶å“ˆå¸Œ
     */
    async calculateFileHash(filePath) {
        try {
            const content = await fs.promises.readFile(filePath);
            return crypto.createHash('md5').update(content).digest('hex');
        }
        catch (error) {
            console.warn(`[IndexCacheService] è®¡ç®—æ–‡ä»¶å“ˆå¸Œå¤±è´¥: ${filePath}`, error);
            // å¦‚æœæ— æ³•è¯»å–æ–‡ä»¶ï¼Œä½¿ç”¨æ–‡ä»¶è·¯å¾„å’Œä¿®æ”¹æ—¶é—´ä½œä¸ºæ›¿ä»£
            const stats = await fs.promises.stat(filePath);
            return crypto.createHash('md5').update(`${filePath}_${stats.mtime.getTime()}`).digest('hex');
        }
    }
    /**
     * åŠ è½½ç¼“å­˜æ•°æ®
     */
    async loadCache() {
        try {
            if (!fs.existsSync(this.cacheFilePath)) {
                return;
            }
            const cacheContent = await fs.promises.readFile(this.cacheFilePath, 'utf8');
            const cacheData = JSON.parse(cacheContent);
            // éªŒè¯ç¼“å­˜ç‰ˆæœ¬å…¼å®¹æ€§
            if (!cacheData.version || cacheData.version !== '1.0') {
                return;
            }
            // é‡å»ºç¼“å­˜æ˜ å°„
            this.cache.clear();
            for (const record of cacheData.records || []) {
                const key = this.generateCacheKey(record.filePath, record.workspacePath, record.userId, record.deviceId);
                this.cache.set(key, record);
            }
        }
        catch (error) {
            console.error('[IndexCacheService] åŠ è½½ç¼“å­˜å¤±è´¥:', error);
            this.cache.clear();
        }
    }
    /**
     * ä¿å­˜ç¼“å­˜æ•°æ®
     */
    async saveCache() {
        try {
            const cacheData = {
                version: '1.0',
                records: [...this.cache.values()],
                lastUpdated: Date.now()
            };
            await fs.promises.writeFile(this.cacheFilePath, JSON.stringify(cacheData, null, 2), 'utf8');
        }
        catch (error) {
            console.error('[IndexCacheService] ä¿å­˜ç¼“å­˜å¤±è´¥:', error);
        }
    }
    /**
     * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
     */
    formatSize(bytes) {
        const units = ['B', 'KB', 'MB', 'GB'];
        let size = bytes;
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
            size /= 1024;
            unitIndex++;
        }
        return `${size.toFixed(2)} ${units[unitIndex]}`;
    }
}
exports.IndexCacheService = IndexCacheService;


/***/ }),
/* 8 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CodeChunker = __webpack_require__(10);
const fs = __webpack_require__(5);
const path = __webpack_require__(4);
const yaml = __webpack_require__(49);

// å…¨å±€CodeChunkerå®ä¾‹ç¼“å­˜
const chunkerInstances = new Map();

/**
 * åŠ è½½é»˜è®¤é…ç½®
 */
function loadDefaultConfig() {
    // ğŸ”¥ å†…ç½®å¤šè¯­è¨€é¡¹ç›®ä¼˜åŒ–é…ç½®ï¼Œæ”¯æŒPythonã€C++ã€CUDAç­‰æ·±åº¦å­¦ä¹ é¡¹ç›®
    const builtinConfig = {
        scanFileExtensions: [
            // Python files
            '.py', '.pyx', '.pyi', '.pyw',
            // C/C++ files
            '.c', '.cpp', '.cc', '.cxx', '.c++', '.h', '.hpp', '.hh', '.hxx', '.h++',
            // CUDA files
            '.cu', '.cuh',
            // Configuration files
            '.yaml', '.yml', '.json', '.toml', '.ini', '.cfg', '.conf',
            // Build files
            '.cmake', '.txt', '.mk', '.make',
            // Documentation
            '.md', '.rst', '.txt',
            // Shell scripts
            '.sh', '.bash', '.zsh', '.fish',
            // Java files (keep for backward compatibility)
            '.java', '.xml', '.properties',
            // JavaScript/TypeScript
            '.js', '.ts', '.jsx', '.tsx',
            // Other common formats
            '.sql', '.proto', '.proto3'
        ],
        maxWorkers: 1,
        useWorkers: false,
        batchSize: 10,
        linesPerChunk: 20,
        ignoredDirectories: [
            'node_modules', '.git', '.vscode', '.idea', 'target', 'build', 'out', 'bin', 'classes',
            'test', 'tests', 'src/test', 'sql', 'database', 'db', 'flowable-patch', 'patch',
            'lib', 'libs', 'vendor', 'third-party', 'ui', 'frontend', 'static', 'dist',
            'script', 'scripts', 'doc', 'docs', 'logs', 'log', 'temp', 'tmp'
        ],
        ignorePatterns: [
            '**/*.sql', '**/sql/**', '**/test/**', '**/tests/**', '**/target/**', '**/build/**',
            '**/flowable-patch/**', '**/third-party/**', '**/vendor/**', '**/lib/**', '**/libs/**',
            '**/node_modules/**', '**/.git/**', '**/.vscode/**', '**/.idea/**',
            // CUDAå’Œæ·±åº¦å­¦ä¹ é¡¹ç›®ç‰¹æœ‰å¿½ç•¥
            '**/cubin/**', '**/*.cubin', '**/*.cubin.cpp', '**/*.ptx', '**/*.fatbin',
            '**/models/**', '**/weights/**', '**/data/**', '**/datasets/**',
            '**/*.bin', '**/*.onnx', '**/*.pb', '**/*.pth', '**/*.engine', '**/*.plan',
            '**/__pycache__/**', '**/venv/**', '**/wandb/**', '**/runs/**'
        ]
    };
    
    // ğŸ”¥ å°è¯•åŠ è½½å¤–éƒ¨é…ç½®æ–‡ä»¶ï¼Œä½†å¦‚æœå¤±è´¥åˆ™ä½¿ç”¨å†…ç½®é…ç½®
    const defaultConfigPath = path.join(__dirname, 'config', 'default.yaml');
    
    try {
        if (fs.existsSync(defaultConfigPath)) {
            const defaultConfigContent = fs.readFileSync(defaultConfigPath, 'utf8');
            const externalConfig = yaml.parse(defaultConfigContent);
            return externalConfig;
        } else {
            return builtinConfig;
        }
    } catch (error) {
        console.error('[CodeChunker] âŒ åŠ è½½å¤–éƒ¨é…ç½®å¤±è´¥ï¼Œä½¿ç”¨å†…ç½®é…ç½®:', error);
        return builtinConfig;
    }
}

/**
 * è·å–æˆ–åˆ›å»ºCodeChunkerå®ä¾‹
 */
function getChunkerInstance(userId, deviceId, workspacePath, token) {
    const key = `${userId}_${deviceId}_${workspacePath}`;
    
    if (!chunkerInstances.has(key)) {
        // ğŸ”¥ åŠ è½½é»˜è®¤é…ç½®ï¼ˆåŒ…å«ç™½åå•å’Œä¼˜åŒ–è®¾ç½®ï¼‰
        const defaultConfig = loadDefaultConfig();
        
        // åˆå¹¶é…ç½®ï¼šé»˜è®¤é…ç½® + è¿è¡Œæ—¶é…ç½®
        const config = {
            ...defaultConfig, // ğŸ”¥ é¦–å…ˆåº”ç”¨default.yamlé…ç½®
            workspacePath,
            userId,
            deviceId,
            token,
            vectorManager: {
                enabled: true,
                logLevel: 'info',
                
                cache: {
                    size: defaultConfig.vectorCache?.maxSize || 200,
                    uploadThreshold: 10,
                    memoryThreshold: defaultConfig.performance?.maxMemoryUsage || 0.6,
                    persistPath: "./vector-cache",
                    cleanupInterval: 1800000
                },
                
                security: {
                    enabled: false,
                    keyPath: "./keys/vector.key"
                },
                
                embedding: {
                    timeout: 30000,
                    batchSize: defaultConfig.batchSize || 10,
                    maxRetries: 3
                },
                
                database: {
                    type: 'tencent_cloud',
                    connection: {
                        type: 'tencent',
                        host: 'http://nj-vdb-dz5mmt48.sql.tencentcdb.com',
                        port: 8100,
                        database: 'vectorservice-test',
                        username: 'root',
                        apiKey: '4xVMtNrcgYd3FQ35A3YkWuFTcvn63t0hkBkDWfKS',
                        timeout: 30000
                    },
                    collections: {
                        vectorDimension: 768,
                        metricType: 'COSINE',
                        indexType: 'HNSW'
                    },
                    query: {
                        defaultDatabase: 'vectorservice-test'
                    },
                    batchSize: defaultConfig.batchSize || 10
                }
            }
        };
        
        const chunkerInstance = new CodeChunker(config);
        chunkerInstances.set(key, chunkerInstance);
        
        return chunkerInstance;
    }
    
    return chunkerInstances.get(key);
}

/**
 * ç»Ÿä¸€ç­¾åçš„å…¥å£å‡½æ•° - ä½¿ç”¨ç¼“å­˜å®ä¾‹
 */
async function processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns) {
    // ä½¿ç”¨ç¼“å­˜çš„å®ä¾‹ï¼Œç¡®ä¿ä¸è¿›åº¦æŸ¥è¯¢ä½¿ç”¨åŒä¸€ä¸ªå®ä¾‹
    const chunker = getChunkerInstance(userId, deviceId, workspacePath, token);
    
    // æ‰§è¡Œå¤„ç†
    const result = await chunker.processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns);
    
    return result;
}

module.exports = {
    processWorkspace,
    getChunkerInstance,
    chunkerInstances,
    CodeChunker
}; 

/***/ }),
/* 10 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const yaml = __webpack_require__(49);
const config = __webpack_require__(123);
const FileScanner = __webpack_require__(125);
const ParserSelector = __webpack_require__(137);
const Dispatcher = __webpack_require__(144);
const Sender = __webpack_require__(147);
const ProgressTracker = __webpack_require__(220);
const MerkleTree = __webpack_require__(237);
const VectorManager = __webpack_require__(221);
const PerformanceAnalyzer = __webpack_require__(238);

class CodeChunker {
    constructor(userConfig) {
        this.config = this._loadConfig(userConfig);
        this.progressTracker = new ProgressTracker();
        this.fileScanner = new FileScanner(this.config);
        this.parserSelector = new ParserSelector(this.config);
        this.dispatcher = new Dispatcher(this.config);
        this.merkleTree = new MerkleTree();
        
        // åˆå§‹åŒ–æ€§èƒ½åˆ†æå™¨
        this.performanceAnalyzer = new PerformanceAnalyzer();
        
        // åˆå§‹åŒ– VectorManagerï¼ˆåªæœ‰åœ¨æ˜ç¡®å¯ç”¨æ—¶æ‰åˆå§‹åŒ–ï¼‰
        if (this.config.vectorManager?.enabled === true) {
            this.vectorManager = new VectorManager(this.config.vectorManager);
            this.vectorManager.initialize().catch(error => {
                this.error('Failed to initialize VectorManager:', error);
            });
        } else {
            this.log('VectorManager is disabled, skipping initialization.');
        }
        
        // åˆå§‹åŒ–Senderï¼Œä¼ å…¥VectorManagerå’Œæ€§èƒ½åˆ†æå™¨
        this.sender = new Sender(this.config, this.progressTracker, this.vectorManager);
        
        this.version = '0.1.0';
    }

    _loadConfig(userConfig) {
        // åŠ è½½é»˜è®¤é…ç½®
        const defaultConfigPath = path.join(__dirname, '..', 'config', 'default.yaml');
        let defaultConfig = {};
        
        try {
            if (fs.existsSync(defaultConfigPath)) {
                const defaultConfigContent = fs.readFileSync(defaultConfigPath, 'utf8');
                defaultConfig = yaml.parse(defaultConfigContent);
            }
        } catch (error) {
            console.warn('Error loading default config:', error);
        }

        // åˆå¹¶ç”¨æˆ·é…ç½®
        return {
            ...defaultConfig,
            ...userConfig
        };
    }

    log(message) {
        console.log(message);
    }

    error(message) {
        console.error(message);
    }

    warn(message) {
        console.warn(message);
    }

    async processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns = []) {
        const startTime = Date.now();
        
        try {
            // å¼€å§‹æ€§èƒ½åˆ†æ
            this.performanceAnalyzer.startAnalysis(workspacePath, userId, deviceId);
            
            this.log(`Starting Code Chunker v${this.version} for workspace: ${workspacePath}`);
            
            // æ›´æ–°é…ç½®
            const updatedConfig = {
                ...this.config,
                workspacePath,
                ignorePatterns: Array.isArray(ignorePatterns) ? ignorePatterns : [],
                userId,
                deviceId,
                token
            };
            
            // é‡æ–°åˆå§‹åŒ–ç»„ä»¶
            this.progressTracker = new ProgressTracker();
            this.config = { ...updatedConfig, progressTracker: this.progressTracker };
            
            this.fileScanner = new FileScanner(this.config, this.performanceAnalyzer);
            this.parserSelector = new ParserSelector(this.config, this.performanceAnalyzer);
            this.dispatcher = new Dispatcher(this.config, this.performanceAnalyzer);
            this.merkleTree = new MerkleTree();
            
            // é‡æ–°åˆå§‹åŒ–Senderï¼Œä¼ å…¥ç°æœ‰çš„VectorManagerå’Œæ€§èƒ½åˆ†æå™¨
            this.sender = new Sender(this.config, this.progressTracker, this.vectorManager, this.performanceAnalyzer);
            
            // å¦‚æœ VectorManager å·²å­˜åœ¨ä¸”å¯ç”¨ï¼Œåˆ™æ›´æ–°é…ç½®ï¼›å¦åˆ™åˆå§‹åŒ–
            if (this.config.vectorManager?.enabled === true) {
                if (!this.vectorManager) {
                    this.vectorManager = new VectorManager(this.config.vectorManager);
                    await this.vectorManager.initialize();
                }
                // ä¸éœ€è¦é‡æ–°åˆå§‹åŒ–ï¼ŒVectorManagerå¯ä»¥é‡ç”¨
            }

           
            // return;
            this.log('Scanning workspace...');
            this.performanceAnalyzer.startFileScanning();
            const { fileList, fileContents, merkleTree: scanMerkleTree, fileHashes, scanStats } = await this.fileScanner.scanWorkspace(workspacePath);
            this.performanceAnalyzer.endFileScanning(fileList.length, scanStats ? scanStats.skippedFiles : 0);
            this.log(`Found ${fileList.length} files to process.`);
            
            // æ–°å¢ï¼šæ³¨å†Œæ–‡ä»¶åˆ°è¿›åº¦è·Ÿè¸ªå™¨
            this.progressTracker.registerFiles(fileList);
            this.log(`Registered ${fileList.length} files for progress tracking.`);

            // æ„å»º Merkle æ ‘ - ä¼˜åŒ–ï¼šä½¿ç”¨fileScannerä¸­å·²è®¡ç®—çš„å“ˆå¸Œå€¼
            let rootHash, tree;
            if (scanMerkleTree && scanMerkleTree.rootHash) {
                // å¦‚æœfileScannerå·²ç»æ„å»ºäº†å¢å¼ºçš„Merkleæ ‘ï¼Œç›´æ¥ä½¿ç”¨
                rootHash = scanMerkleTree.rootHash;
                tree = scanMerkleTree.tree;
                this.merkleTree.leaves = scanMerkleTree.leaves || [];
                this.merkleTree.tree = tree || [];
            } else {
                // ä»å·²è®¡ç®—çš„å“ˆå¸Œæ„å»ºMerkleæ ‘ï¼ˆé¿å…é‡å¤å“ˆå¸Œè®¡ç®—ï¼‰
                const hashArray = fileList.map(filePath => fileHashes[filePath]);
                const result = this.merkleTree.buildTree(hashArray);
                rootHash = result.rootHash;
                tree = result.tree;
            }
            this.log(`Generated Merkle tree with root hash: ${rootHash}`);

            this.log('Processing files concurrently...');
            this.performanceAnalyzer.startFileParsing(fileList.length);
            const fileObjects = fileList.map((f, index) => ({ 
                path: f,
                merkleProof: this.merkleTree.getProof(index)
            }));
            const chunks = await this.dispatcher.processFilesConcurrently(fileObjects, this.parserSelector);
            
            // è·å–çœŸå®çš„Workerç»Ÿè®¡ä¿¡æ¯
            const workerStats = this.dispatcher.getWorkerStats();
            const successFiles = chunks.length > 0 ? fileList.length : 0;
            const failedFiles = fileList.length - successFiles;
            const syncCount = workerStats.useWorkers ? 0 : fileList.length;
            const workerCount = workerStats.useWorkers ? fileList.length : 0;
            
            this.performanceAnalyzer.endFileParsing(
                successFiles, 
                failedFiles, 
                workerStats.workerFailures, 
                syncCount, 
                workerCount
            );
            this.log(`Generated ${chunks.length} chunks`);
            
            // è®°å½•åˆ†å—ç”Ÿæˆä¿¡æ¯
            const chunkSizes = chunks.map(chunk => chunk.content ? chunk.content.length : 0);
            this.performanceAnalyzer.recordChunkGeneration(chunks.length, chunkSizes);
            
            // ============ é›†åˆæ¸…ç†å’Œé‡æ–°åˆ›å»º - å¼ºåˆ¶æ‰§è¡Œ ============
            this.log('å¼€å§‹æ¸…ç†å’Œé‡æ–°åˆ›å»ºé›†åˆï¼ˆå¼ºåˆ¶æ‰§è¡Œï¼‰');
            this.performanceAnalyzer.startVectorDBOperations();
            await this._cleanAndRecreateCollection(userId, deviceId, workspacePath);
            this.log('é›†åˆæ¸…ç†å’Œé‡æ–°åˆ›å»ºå®Œæˆ');
            
            this.log('Sending chunks to embedding service...');
            this.performanceAnalyzer.startEmbeddingGeneration();
            await this.sender.sendChunks(chunks, rootHash);
             
            // æ•°æ®å·²ç›´æ¥å‘é€åˆ°å‘é‡æ•°æ®åº“ï¼Œæ— éœ€é¢å¤–æŒä¹…åŒ–

            // æ›´æ–°æ–‡ä»¶å¤„ç†çŠ¶æ€ä¸ºå®Œæˆ
            if (this.progressTracker) {
                // å°†æ‰€æœ‰æ–‡ä»¶æ ‡è®°ä¸ºå·²å®Œæˆ
                for (const filePath of fileList) {
                    this.progressTracker.updateFileStatus(filePath, 'completed');
                }
                
                const finalProgress = this.progressTracker.getOverallProgress();
                const fileProgress = this.progressTracker.getFileProgress();
                
                this.log(`File Processing Summary: ${fileProgress.completedFiles}/${fileProgress.totalFiles} files completed (${this.progressTracker.getFileProgressPercentage().toFixed(2)}%)`);
                this.log(`Chunk Processing Summary: ${finalProgress.completedChunks}/${finalProgress.totalChunks} chunks completed (${finalProgress.successRate.toFixed(2)}%)`);
                
                if (finalProgress.successRate < 100) {
                    this.warn("Some chunks could not be sent");
                }
                
                // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
                this.performanceAnalyzer.recordMemoryUsage('completion');
                
                // å®Œæˆæ€§èƒ½åˆ†æå¹¶ç”ŸæˆæŠ¥å‘Š
                this.performanceAnalyzer.endVectorDBOperations(chunks.length, Math.ceil(chunks.length / 10)); // å‡è®¾æ¯æ‰¹10ä¸ª
                const performanceReport = await this.performanceAnalyzer.endAnalysis();
                
                this.log(`\nğŸ‰ ============== é¡¹ç›®å¤„ç†å®Œæˆ ==============`);
                this.log(`ğŸ“Š æ€§èƒ½æµ‹é€ŸæŠ¥å‘Šå·²è‡ªåŠ¨ç”Ÿæˆ:`);
                this.log(`   ğŸ“ æŠ¥å‘Šæ–‡ä»¶å¤¹: ${this.performanceAnalyzer.reportFolder}`);
                this.log(`   ğŸ“„ JSONæŠ¥å‘Š: ${this.performanceAnalyzer.reportPath}`);
                this.log(`   ğŸ“„ MDæŠ¥å‘Š: ${this.performanceAnalyzer.reportPath.replace('.json', '.md')}`);
                
                if (performanceReport) {
                    const totalTime = (performanceReport.summary.totalDuration / 1000).toFixed(2);
                    const score = this.performanceAnalyzer._calculatePerformanceScore(performanceReport);
                    
                    this.log(`\nğŸ“ˆ æ€§èƒ½æ¦‚è§ˆ:`);
                    this.log(`   â±ï¸  æ€»å¤„ç†æ—¶é—´: ${totalTime}ç§’`);
                    this.log(`   ğŸ“ å¤„ç†æ–‡ä»¶æ•°: ${performanceReport.summary.processedFiles}/${performanceReport.summary.totalFiles}`);
                    this.log(`   ğŸ§© ç”Ÿæˆä»£ç å—: ${performanceReport.summary.totalChunks}`);
                    this.log(`   ğŸŒ Embeddingè¯·æ±‚: ${performanceReport.summary.totalEmbeddingRequests}`);
                    this.log(`   ğŸ“Š æ’å…¥å‘é‡æ•°: ${performanceReport.summary.insertedVectors}`);
                    this.log(`   ğŸ¯ æ€§èƒ½è¯„åˆ†: ${score}/100 åˆ†`);
                    
                    if (performanceReport.performance.bottlenecks.length > 0) {
                        this.log(`\nğŸš¨ å‘ç° ${performanceReport.performance.bottlenecks.length} ä¸ªæ€§èƒ½ç“¶é¢ˆ:`);
                        performanceReport.performance.bottlenecks.forEach((bottleneck, index) => {
                            const icon = bottleneck.impact === 'high' ? 'ğŸ”´' : bottleneck.impact === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢';
                            this.log(`   ${index + 1}. ${icon} ${bottleneck.phase}: ${bottleneck.description}`);
                        });
                    } else {
                        this.log(`\nâœ… æœªæ£€æµ‹åˆ°æ˜æ˜¾æ€§èƒ½ç“¶é¢ˆï¼Œè¿è¡Œè‰¯å¥½ï¼`);
                    }
                    
                    if (performanceReport.performance.recommendations.length > 0) {
                        this.log(`\nğŸ’¡ æ€§èƒ½ä¼˜åŒ–å»ºè®®:`);
                        performanceReport.performance.recommendations.slice(0, 3).forEach((rec, index) => {
                            const icon = rec.priority === 'high' ? 'ğŸ”´' : rec.priority === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢';
                            this.log(`   ${index + 1}. ${icon} ${rec.category}: ${rec.suggestion}`);
                        });
                    }
                }
                
                this.log(`\nğŸ“‹ è¯·æŸ¥çœ‹è¯¦ç»†çš„æ€§èƒ½æµ‹é€ŸæŠ¥å‘Šä»¥äº†è§£æ›´å¤šä¿¡æ¯ã€‚`);
                this.log(`===============================================\n`);
            }

            const endTime = Date.now();
            this.log(`Code Chunker completed in ${((endTime - startTime) / 1000).toFixed(2)} seconds`);

            return true;
        } catch (error) {
            this.error('âŒ Error in processWorkspace:', error);
            this.error('âŒ Error details:', {
                name: error.name,
                message: error.message,
                stack: error.stack
            });
            
            // å‘ä¸ŠæŠ›å‡ºé”™è¯¯è€Œä¸æ˜¯è¿”å›falseï¼Œè¿™æ ·TypeScriptå±‚å¯ä»¥çœ‹åˆ°å…·ä½“é”™è¯¯
            throw error;
        }
    }

    // æ·»åŠ æœç´¢æ–¹æ³•
    async search(query, options = {}) {
        if (!this.vectorManager) {
            throw new Error('VectorManager is not enabled');
        }

        try {
            const searchResults = await this.vectorManager.search(query, options.topK || 10, {
                userId: this.config.userId,
                deviceId: this.config.deviceId,
                workspacePath: this.config.workspacePath,
                ...options
            });

            // è¿‡æ»¤æ‰åŒ…å«"unknown"çš„ç»“æœ
            const filteredResults = this._filterUnknownResults(searchResults);
            
            // è®°å½•è¿‡æ»¤ä¿¡æ¯
            if (searchResults.length !== filteredResults.length) {
                this.log(`æœç´¢ç»“æœè¿‡æ»¤: åŸå§‹${searchResults.length}æ¡ -> è¿‡æ»¤å${filteredResults.length}æ¡ (ç§»é™¤äº†${searchResults.length - filteredResults.length}æ¡åŒ…å«"unknown"çš„ç»“æœ)`);
            }

            return filteredResults;
        } catch (error) {
            this.error('Error searching vectors:', error);
            throw error;
        }
    }

    /**
     * è¿‡æ»¤åŒ…å«"unknown"çš„æœç´¢ç»“æœ
     * @param {Array} results - åŸå§‹æœç´¢ç»“æœ
     * @returns {Array} è¿‡æ»¤åçš„ç»“æœ
     */
    _filterUnknownResults(results) {
        if (!Array.isArray(results)) {
            return results;
        }

        return results.filter(result => {
            // æ£€æŸ¥å„ä¸ªå¯èƒ½åŒ…å«"unknown"çš„å­—æ®µ
            const fieldsToCheck = [
                result.filePath,
                result.content, 
                result.chunkId,
                result.metadata?.userId,
                result.metadata?.deviceId,
                result.metadata?.workspacePath,
                result.metadata?.vectorModel
            ];

            // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•å­—æ®µåŒ…å«"unknown"ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰
            const hasUnknown = fieldsToCheck.some(field => {
                if (typeof field === 'string') {
                    return field.toLowerCase().includes('unknown');
                }
                return false;
            });

            // é¢å¤–æ£€æŸ¥ï¼šå¦‚æœfilePathæ˜¯"unknown"æˆ–ä»¥"unknown"å¼€å¤´ï¼Œä¹Ÿè¿‡æ»¤æ‰
            if (result.filePath && 
                (result.filePath.toLowerCase() === 'unknown' || 
                 result.filePath.toLowerCase().startsWith('unknown/'))) {
                return false;
            }

            // é¢å¤–æ£€æŸ¥ï¼šå¦‚æœcontentä¸ºç©ºæˆ–åªæœ‰ç©ºç™½å­—ç¬¦ï¼Œä¹Ÿè¿‡æ»¤æ‰
            if (!result.content || result.content.trim().length === 0) {
                return false;
            }

            return !hasUnknown;
        });
    }

    /**
     * è·å–æ–‡ä»¶å¤„ç†è¿›åº¦ç™¾åˆ†æ¯”
     * @returns {number} 0-100ä¹‹é—´çš„æµ®ç‚¹æ•°
     */
    getFileProcessingProgress() {
        if (!this.progressTracker) {
            return 0;
        }
        return this.progressTracker.getFileProgressPercentage();
    }

    /**
     * è·å–è¯¦ç»†çš„æ–‡ä»¶å¤„ç†è¿›åº¦ä¿¡æ¯
     * @returns {Object} åŒ…å«è¯¦ç»†è¿›åº¦ä¿¡æ¯çš„å¯¹è±¡
     */
    getFileProcessingDetails() {
        if (!this.progressTracker) {
            return {
                totalFiles: 0,
                completedFiles: 0,
                processingFiles: 0,
                failedFiles: 0,
                pendingFiles: 0,
                progressPercentage: 0
            };
        }
        return this.progressTracker.getFileProgress();
    }

    // æ·»åŠ å…³é—­æ–¹æ³•
    async shutdown() {
        try {
            if (this.vectorManager) {
                await this.vectorManager.shutdown();
            }
            if (this.sender) {
                await this.sender.shutdown();
            }
        } catch (error) {
            this.error('Error during shutdown:', error);
        }
    }

    /**
     * æ¸…ç†å¹¶é‡æ–°åˆ›å»ºé›†åˆ
     * ç¡®ä¿æ¯æ¬¡å¤„ç†å·¥ä½œç©ºé—´æ—¶éƒ½æœ‰ä¸€ä¸ªå¹²å‡€çš„å‘é‡æ•°æ®åº“é›†åˆ
     */
    async _cleanAndRecreateCollection(userId, deviceId, workspacePath) {
        // å¼ºåˆ¶æ‰§è¡Œæ¨¡å¼ï¼šå¦‚æœVectorManagerä¸å­˜åœ¨ï¼Œå°è¯•åˆ›å»ºä¸€ä¸ª
        if (!this.vectorManager) {
            this.log('VectorManagerä¸å­˜åœ¨ï¼Œå°è¯•å¼ºåˆ¶åˆå§‹åŒ–...');
            try {
                // ç¡®ä¿æœ‰åŸºç¡€é…ç½®
                if (!this.config.vectorManager) {
                    this.config.vectorManager = { enabled: true };
                }
                this.vectorManager = new VectorManager(this.config.vectorManager);
                await this.vectorManager.initialize();
                this.log('VectorManagerå¼ºåˆ¶åˆå§‹åŒ–æˆåŠŸ');
            } catch (error) {
                this.error('VectorManagerå¼ºåˆ¶åˆå§‹åŒ–å¤±è´¥:', error);
                this.warn('è·³è¿‡é›†åˆæ¸…ç†æ“ä½œ');
                return;
            }
        }
        
        if (!this.vectorManager.vectorDB) {
            this.warn('VectorDB not available for collection cleanup');
            return;
        }



        this.log('========== å¼€å§‹æ¸…ç†å’Œé‡æ–°åˆ›å»ºé›†åˆ ==========');
        
        // ç”Ÿæˆé›†åˆæ ‡è¯†ç¬¦ï¼ˆä¸VectorManagerä¿æŒä¸€è‡´ï¼‰
        const crypto = __webpack_require__(8);
const { createCollectionName } = __webpack_require__(229);
        const workspaceHash = crypto
            .createHash('sha256')
            .update(workspacePath)
            .digest('hex')
            .substring(0, 16); // å–å‰16ä½
        // ä½¿ç”¨ç»Ÿä¸€çš„collectionåç§°ç”Ÿæˆå·¥å…·
        const collectionName = createCollectionName(userId, deviceId, workspacePath);
        const databaseName = this.config.vectorManager?.database?.query?.defaultDatabase || 'vectorservice-test';
        
        this.log(`é›†åˆæ ‡è¯†: ${collectionName}`);
        this.log(`æ•°æ®åº“å: ${databaseName}`);

        // æ­¥éª¤1ï¼šåˆ é™¤ç°æœ‰é›†åˆï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        this.log(`æ­¥éª¤1: åˆ é™¤ç°æœ‰é›†åˆ ${collectionName}`);
        try {
            const deleteResult = await this.vectorManager.vectorDB.implementation.dropCollection(databaseName, collectionName);
            this.log('âœ… é›†åˆåˆ é™¤æˆåŠŸ:', deleteResult);
        } catch (error) {
            // å¦‚æœé›†åˆä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸çš„
            if (error.message.includes('not exist') || 
                error.message.includes('æ‰¾ä¸åˆ°') || 
                error.message.includes('does not exist') ||
                error.code === 'COLLECTION_NOT_FOUND' || 
                error.status === 404 ||
                error.response?.status === 404) {
                this.log('âœ… é›†åˆä¸å­˜åœ¨ï¼Œæ— éœ€åˆ é™¤ï¼ˆè¿™æ˜¯æ­£å¸¸çš„ï¼‰');
            } else {
                this.warn('âš ï¸ åˆ é™¤é›†åˆæ—¶å‡ºç°é”™è¯¯:', {
                    message: error.message,
                    code: error.code,
                    status: error.status || error.response?.status
                });
                // ç»§ç»­æ‰§è¡Œï¼Œä¸ä¸­æ–­å¤„ç†
            }
        }
        
        // æ­¥éª¤2ï¼šç­‰å¾…ç¡®ä¿åˆ é™¤æ“ä½œå®Œæˆ
        this.log('æ­¥éª¤2: ç­‰å¾…åˆ é™¤æ“ä½œå®Œæˆ...');
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // æ­¥éª¤3ï¼šåˆ›å»ºæ–°çš„å¹²å‡€é›†åˆ
        this.log(`æ­¥éª¤3: åˆ›å»ºæ–°é›†åˆ ${collectionName}`);
        try {
            const createResult = await this.vectorManager.vectorDB.implementation.createCollection(databaseName, collectionName, {
                description: `å·¥ä½œç©ºé—´é›†åˆ - ${collectionName} - ${new Date().toISOString()}`,
                replicaNum: 0,  // è…¾è®¯äº‘è¦æ±‚å¿…é¡»ä¸º0
                shardNum: 1,
                indexes: [
                    // ä¸»é”®ç´¢å¼•
                    {
                        fieldName: "id",
                        fieldType: "string",
                        indexType: "primaryKey"
                    },
                    // å‘é‡ç´¢å¼•
                    {
                        fieldName: "vector",
                        fieldType: "vector",
                        indexType: "HNSW",
                        dimension: this.config.vectorManager?.database?.collections?.vectorDimension || 768,
                        metricType: this.config.vectorManager?.database?.collections?.metricType || "COSINE",
                        params: {
                            M: 16,
                            efConstruction: 200
                        }
                    },
                    // å…ƒæ•°æ®å­—æ®µç´¢å¼•ï¼ˆç”¨äºè¿‡æ»¤ï¼‰
                    {
                        fieldName: "user_id",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "device_id",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "workspace_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "file_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "start_line",
                        fieldType: "uint64",
                        indexType: "filter"
                    },
                    {
                        fieldName: "end_line",
                        fieldType: "uint64",
                        indexType: "filter"
                    },
                    {
                        fieldName: "code",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "vector_model",
                        fieldType: "string",
                        indexType: "filter"
                    }
                ]
            });
            this.log('âœ… é›†åˆåˆ›å»ºæˆåŠŸ:', createResult);
        } catch (error) {
            this.error('âŒ åˆ›å»ºé›†åˆå¤±è´¥:', {
                message: error.message,
                code: error.code,
                status: error.status,
                response: error.response?.data
            });
            throw error;
        }
        
        // æ­¥éª¤4ï¼šéªŒè¯é›†åˆå·²åˆ›å»º
        this.log('æ­¥éª¤4: éªŒè¯é›†åˆçŠ¶æ€');
        try {
            const response = await this.vectorManager.vectorDB.implementation.listCollections(databaseName);
            const collections = response.data?.collections || [];
            
            this.log('éªŒè¯é›†åˆåˆ—è¡¨:', collections.map(col => col.collectionName || col.collection || col.name));
            
            const collectionExists = collections.some(col => 
                col.collectionName === collectionName || 
                col.collection === collectionName ||
                col.name === collectionName
            );
            
            if (collectionExists) {
                this.log('âœ… é›†åˆåˆ›å»ºéªŒè¯æˆåŠŸï¼Œç¯å¢ƒå‡†å¤‡å®Œæ¯•');
            } else {
                this.warn('âš ï¸ åœ¨é›†åˆåˆ—è¡¨ä¸­æœªæ‰¾åˆ°ç›®æ ‡é›†åˆï¼Œä½†è¿™å¯èƒ½æ˜¯æ­£å¸¸çš„ï¼ˆå»¶è¿Ÿï¼‰');
            }
        } catch (error) {
            this.error('âŒ éªŒè¯é›†åˆçŠ¶æ€å¤±è´¥:', error.message);
            throw error;
        }
        
        this.log('========== é›†åˆæ¸…ç†å’Œé‡æ–°åˆ›å»ºå®Œæˆ ==========');
    }
}

module.exports = CodeChunker;

/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  // Export promiseified graceful-fs:
  ...__webpack_require__(12),
  // Export extra methods:
  ...__webpack_require__(22),
  ...__webpack_require__(31),
  ...__webpack_require__(33),
  ...__webpack_require__(39),
  ...__webpack_require__(24),
  ...__webpack_require__(46),
  ...__webpack_require__(44),
  ...__webpack_require__(27),
  ...__webpack_require__(32)
}


/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = (__webpack_require__(13).fromCallback)
const fs = __webpack_require__(14)

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'cp',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'glob',
  'lchmod',
  'lchown',
  'lutimes',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rm',
  'rmdir',
  'stat',
  'statfs',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.cp was added in Node.js v16.7.0
  // fs.statfs was added in Node v19.6.0, v18.15.0
  // fs.glob was added in Node.js v22.0.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export cloned fs:
Object.assign(exports, fs)

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}

// Function signature is
// s.readv(fd, buffers[, position], callback)
// We need to handle the optional arg, so we use ...args
exports.readv = function (fd, buffers, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.readv(fd, buffers, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffers })
    })
  })
}

// Function signature is
// s.writev(fd, buffers[, position], callback)
// We need to handle the optional arg, so we use ...args
exports.writev = function (fd, buffers, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.writev(fd, buffers, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffers })
    })
  })
}

// fs.realpath.native sometimes not available if fs is monkey-patched
if (typeof fs.realpath.native === 'function') {
  exports.realpath.native = u(fs.realpath.native)
} else {
  process.emitWarning(
    'fs.realpath.native is not a function. Is fs being monkey-patched?',
    'Warning', 'fs-extra-WARN0003'
  )
}


/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)
    else {
      return new Promise((resolve, reject) => {
        args.push((err, res) => (err != null) ? reject(err) : resolve(res))
        fn.apply(this, args)
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, args)
    else {
      args.pop()
      fn.apply(this, args).then(r => cb(null, r), cb)
    }
  }, 'name', { value: fn.name })
}


/***/ }),
/* 14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(5)
var polyfills = __webpack_require__(15)
var legacy = __webpack_require__(17)
var clone = __webpack_require__(19)

var util = __webpack_require__(20)

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      resetQueue()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(21).equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  var noReaddirOptionVersions = /^v[0-5]\./
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    var go$readdir = noReaddirOptionVersions.test(process.version)
      ? function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }
      : function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }

    return go$readdir(path, options, cb)

    function fs$readdirCallback (path, options, cb, startTime) {
      return function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([
            go$readdir,
            [path, options, cb],
            err,
            startTime || Date.now(),
            Date.now()
          ])
        else {
          if (files && files.sort)
            files.sort()

          if (typeof cb === 'function')
            cb.call(this, err, files)
        }
      }
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
  retry()
}

// keep track of the timeout between retry() calls
var retryTimer

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now()
  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs[gracefulQueue][i].length > 2) {
      fs[gracefulQueue][i][3] = now // startTime
      fs[gracefulQueue][i][4] = now // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry()
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer)
  retryTimer = undefined

  if (fs[gracefulQueue].length === 0)
    return

  var elem = fs[gracefulQueue].shift()
  var fn = elem[0]
  var args = elem[1]
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2]
  var startTime = elem[3]
  var lastTime = elem[4]

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args)
    fn.apply(null, args)
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args)
    var cb = args.pop()
    if (typeof cb === 'function')
      cb.call(null, err)
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1)
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100)
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args)
      fn.apply(null, args.concat([startTime]))
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs[gracefulQueue].push(elem)
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0)
  }
}


/***/ }),
/* 15 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(16)

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (fs.chmod && !fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (fs.chown && !fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = typeof fs.rename !== 'function' ? fs.rename
    : (function (fs$rename) {
      function rename (from, to, cb) {
        var start = Date.now()
        var backoff = 0;
        fs$rename(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY")
              && Date.now() - start < 60000) {
            setTimeout(function() {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er)
              })
            }, backoff)
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er)
        })
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)
      return rename
    })(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = typeof fs.read !== 'function' ? fs.read
  : (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync
  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else if (fs.futimes) {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000
        if (stats.gid < 0) stats.gid += 0x100000000
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(18).Stream)

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),
/* 20 */
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),
/* 21 */
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),
/* 22 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
module.exports = {
  copy: u(__webpack_require__(23)),
  copySync: __webpack_require__(30)
}


/***/ }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const { mkdirs } = __webpack_require__(24)
const { pathExists } = __webpack_require__(27)
const { utimesMillis } = __webpack_require__(28)
const stat = __webpack_require__(29)

async function copy (src, dest, opts = {}) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    process.emitWarning(
      'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
      '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
      'Warning', 'fs-extra-WARN0001'
    )
  }

  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)

  await stat.checkParentPaths(src, srcStat, dest, 'copy')

  const include = await runFilter(src, dest, opts)

  if (!include) return

  // check if the parent of dest exists, and create it if it doesn't exist
  const destParent = path.dirname(dest)
  const dirExists = await pathExists(destParent)
  if (!dirExists) {
    await mkdirs(destParent)
  }

  await getStatsAndPerformCopy(destStat, src, dest, opts)
}

async function runFilter (src, dest, opts) {
  if (!opts.filter) return true
  return opts.filter(src, dest)
}

async function getStatsAndPerformCopy (destStat, src, dest, opts) {
  const statFn = opts.dereference ? fs.stat : fs.lstat
  const srcStat = await statFn(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)

  if (
    srcStat.isFile() ||
    srcStat.isCharacterDevice() ||
    srcStat.isBlockDevice()
  ) return onFile(srcStat, destStat, src, dest, opts)

  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

async function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)

  if (opts.overwrite) {
    await fs.unlink(dest)
    return copyFile(srcStat, src, dest, opts)
  }
  if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

async function copyFile (srcStat, src, dest, opts) {
  await fs.copyFile(src, dest)
  if (opts.preserveTimestamps) {
    // Make sure the file is writable before setting the timestamp
    // otherwise open fails with EPERM when invoked with 'r+'
    // (through utimes call)
    if (fileIsNotWritable(srcStat.mode)) {
      await makeFileWritable(dest, srcStat.mode)
    }

    // Set timestamps and mode correspondingly

    // Note that The initial srcStat.atime cannot be trusted
    // because it is modified by the read(2) system call
    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
    const updatedSrcStat = await fs.stat(src)
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
  }

  return fs.chmod(dest, srcStat.mode)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return fs.chmod(dest, srcMode | 0o200)
}

async function onDir (srcStat, destStat, src, dest, opts) {
  // the dest directory might not exist, create it
  if (!destStat) {
    await fs.mkdir(dest)
  }

  const promises = []

  // loop through the files in the current directory to copy everything
  for await (const item of await fs.opendir(src)) {
    const srcItem = path.join(src, item.name)
    const destItem = path.join(dest, item.name)

    promises.push(
      runFilter(srcItem, destItem, opts).then(include => {
        if (include) {
          // only copy the item if it matches the filter function
          return stat.checkPaths(srcItem, destItem, 'copy', opts).then(({ destStat }) => {
            // If the item is a copyable file, `getStatsAndPerformCopy` will copy it
            // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively
            return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)
          })
        }
      })
    )
  }

  await Promise.all(promises)

  if (!destStat) {
    await fs.chmod(dest, srcStat.mode)
  }
}

async function onLink (destStat, src, dest, opts) {
  let resolvedSrc = await fs.readlink(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }
  if (!destStat) {
    return fs.symlink(resolvedSrc, dest)
  }

  let resolvedDest = null
  try {
    resolvedDest = await fs.readlink(dest)
  } catch (e) {
    // dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)
    throw e
  }
  if (opts.dereference) {
    resolvedDest = path.resolve(process.cwd(), resolvedDest)
  }
  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
  }

  // do not copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
  }

  // copy the link
  await fs.unlink(dest)
  return fs.symlink(resolvedSrc, dest)
}

module.exports = copy


/***/ }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(13).fromPromise)
const { makeDir: _makeDir, makeDirSync } = __webpack_require__(25)
const makeDir = u(_makeDir)

module.exports = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
}


/***/ }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(12)
const { checkPath } = __webpack_require__(26)

const getMode = options => {
  const defaults = { mode: 0o777 }
  if (typeof options === 'number') return options
  return ({ ...defaults, ...options }).mode
}

module.exports.makeDir = async (dir, options) => {
  checkPath(dir)

  return fs.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  })
}

module.exports.makeDirSync = (dir, options) => {
  checkPath(dir)

  return fs.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  })
}


/***/ }),
/* 26 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Adapted from https://github.com/sindresorhus/make-dir
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

const path = __webpack_require__(4)

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
module.exports.checkPath = function checkPath (pth) {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''))

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`)
      error.code = 'EINVAL'
      throw error
    }
  }
}


/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(13).fromPromise)
const fs = __webpack_require__(12)

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}


/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const u = (__webpack_require__(13).fromPromise)

async function utimesMillis (path, atime, mtime) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  const fd = await fs.open(path, 'r+')

  let closeErr = null

  try {
    await fs.futimes(fd, atime, mtime)
  } finally {
    try {
      await fs.close(fd)
    } catch (e) {
      closeErr = e
    }
  }

  if (closeErr) {
    throw closeErr
  }
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  utimesMillis: u(utimesMillis),
  utimesMillisSync
}


/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const u = (__webpack_require__(13).fromPromise)

function getStats (src, dest, opts) {
  const statFunc = opts.dereference
    ? (file) => fs.stat(file, { bigint: true })
    : (file) => fs.lstat(file, { bigint: true })
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest, opts) {
  let destStat
  const statFunc = opts.dereference
    ? (file) => fs.statSync(file, { bigint: true })
    : (file) => fs.lstatSync(file, { bigint: true })
  const srcStat = statFunc(src)
  try {
    destStat = statFunc(dest)
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

async function checkPaths (src, dest, funcName, opts) {
  const { srcStat, destStat } = await getStats(src, dest, opts)
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      const srcBaseName = path.basename(src)
      const destBaseName = path.basename(dest)
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }

  return { srcStat, destStat }
}

function checkPathsSync (src, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts)

  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      const srcBaseName = path.basename(src)
      const destBaseName = path.basename(dest)
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
async function checkParentPaths (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return

  let destStat
  try {
    destStat = await fs.stat(destParent, { bigint: true })
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }

  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }

  return checkParentPaths(src, srcStat, destParent, funcName)
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try {
    destStat = fs.statSync(destParent, { bigint: true })
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.every((cur, i) => destArr[i] === cur)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

module.exports = {
  // checkPaths
  checkPaths: u(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical
}


/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(14)
const path = __webpack_require__(4)
const mkdirsSync = (__webpack_require__(24).mkdirsSync)
const utimesMillisSync = (__webpack_require__(28).utimesMillisSync)
const stat = __webpack_require__(29)

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    process.emitWarning(
      'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
      '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
      'Warning', 'fs-extra-WARN0002'
    )
  }

  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)
  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirsSync(destParent)
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  fs.copyFileSync(src, dest)
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)
  return setDestMode(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)
  return setDestTimestamps(src, dest)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200)
}

function setDestMode (dest, srcMode) {
  return fs.chmodSync(dest, srcMode)
}

function setDestTimestamps (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs.statSync(src)
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcMode, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return setDestMode(dest, srcMode)
}

function copyDir (src, dest, opts) {
  const dir = fs.opendirSync(src)

  try {
    let dirent

    while ((dirent = dir.readSync()) !== null) {
      copyDirItem(dirent.name, src, dest, opts)
    }
  } finally {
    dir.closeSync()
  }
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  if (opts.filter && !opts.filter(srcItem, destItem)) return
  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)
  return getStats(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (!destStat) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

module.exports = copySync


/***/ }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const mkdir = __webpack_require__(24)
const remove = __webpack_require__(32)

const emptyDir = u(async function emptyDir (dir) {
  let items
  try {
    items = await fs.readdir(dir)
  } catch {
    return mkdir.mkdirs(dir)
  }

  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}


/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(14)
const u = (__webpack_require__(13).fromCallback)

function remove (path, callback) {
  fs.rm(path, { recursive: true, force: true }, callback)
}

function removeSync (path) {
  fs.rmSync(path, { recursive: true, force: true })
}

module.exports = {
  remove: u(remove),
  removeSync
}


/***/ }),
/* 33 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { createFile, createFileSync } = __webpack_require__(34)
const { createLink, createLinkSync } = __webpack_require__(35)
const { createSymlink, createSymlinkSync } = __webpack_require__(36)

module.exports = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
}


/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const path = __webpack_require__(4)
const fs = __webpack_require__(12)
const mkdir = __webpack_require__(24)

async function createFile (file) {
  let stats
  try {
    stats = await fs.stat(file)
  } catch { }
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)

  let dirStats = null
  try {
    dirStats = await fs.stat(dir)
  } catch (err) {
    // if the directory doesn't exist, make it
    if (err.code === 'ENOENT') {
      await mkdir.mkdirs(dir)
      await fs.writeFile(file, '')
      return
    } else {
      throw err
    }
  }

  if (dirStats.isDirectory()) {
    await fs.writeFile(file, '')
  } else {
    // parent is not a directory
    // This is just to cause an internal ENOTDIR error to be thrown
    await fs.readdir(dir)
  }
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch { }
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  try {
    if (!fs.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      fs.readdirSync(dir)
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)
    else throw err
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}


/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const path = __webpack_require__(4)
const fs = __webpack_require__(12)
const mkdir = __webpack_require__(24)
const { pathExists } = __webpack_require__(27)
const { areIdentical } = __webpack_require__(29)

async function createLink (srcpath, dstpath) {
  let dstStat
  try {
    dstStat = await fs.lstat(dstpath)
  } catch {
    // ignore error
  }

  let srcStat
  try {
    srcStat = await fs.lstat(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  if (dstStat && areIdentical(srcStat, dstStat)) return

  const dir = path.dirname(dstpath)

  const dirExists = await pathExists(dir)

  if (!dirExists) {
    await mkdir.mkdirs(dir)
  }

  await fs.link(srcpath, dstpath)
}

function createLinkSync (srcpath, dstpath) {
  let dstStat
  try {
    dstStat = fs.lstatSync(dstpath)
  } catch {}

  try {
    const srcStat = fs.lstatSync(srcpath)
    if (dstStat && areIdentical(srcStat, dstStat)) return
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}


/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const path = __webpack_require__(4)
const fs = __webpack_require__(12)

const { mkdirs, mkdirsSync } = __webpack_require__(24)

const { symlinkPaths, symlinkPathsSync } = __webpack_require__(37)
const { symlinkType, symlinkTypeSync } = __webpack_require__(38)

const { pathExists } = __webpack_require__(27)

const { areIdentical } = __webpack_require__(29)

async function createSymlink (srcpath, dstpath, type) {
  let stats
  try {
    stats = await fs.lstat(dstpath)
  } catch { }

  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs.stat(srcpath),
      fs.stat(dstpath)
    ])

    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = await symlinkPaths(srcpath, dstpath)
  srcpath = relative.toDst
  const toType = await symlinkType(relative.toCwd, type)
  const dir = path.dirname(dstpath)

  if (!(await pathExists(dir))) {
    await mkdirs(dir)
  }

  return fs.symlink(srcpath, dstpath, toType)
}

function createSymlinkSync (srcpath, dstpath, type) {
  let stats
  try {
    stats = fs.lstatSync(dstpath)
  } catch { }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs.statSync(srcpath)
    const dstStat = fs.statSync(dstpath)
    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}


/***/ }),
/* 37 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(4)
const fs = __webpack_require__(12)
const { pathExists } = __webpack_require__(27)

const u = (__webpack_require__(13).fromPromise)

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

async function symlinkPaths (srcpath, dstpath) {
  if (path.isAbsolute(srcpath)) {
    try {
      await fs.lstat(srcpath)
    } catch (err) {
      err.message = err.message.replace('lstat', 'ensureSymlink')
      throw err
    }

    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  }

  const dstdir = path.dirname(dstpath)
  const relativeToDst = path.join(dstdir, srcpath)

  const exists = await pathExists(relativeToDst)
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    }
  }

  try {
    await fs.lstat(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureSymlink')
    throw err
  }

  return {
    toCwd: srcpath,
    toDst: path.relative(dstdir, srcpath)
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  if (path.isAbsolute(srcpath)) {
    const exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  }

  const dstdir = path.dirname(dstpath)
  const relativeToDst = path.join(dstdir, srcpath)
  const exists = fs.existsSync(relativeToDst)
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    }
  }

  const srcExists = fs.existsSync(srcpath)
  if (!srcExists) throw new Error('relative srcpath does not exist')
  return {
    toCwd: srcpath,
    toDst: path.relative(dstdir, srcpath)
  }
}

module.exports = {
  symlinkPaths: u(symlinkPaths),
  symlinkPathsSync
}


/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const u = (__webpack_require__(13).fromPromise)

async function symlinkType (srcpath, type) {
  if (type) return type

  let stats
  try {
    stats = await fs.lstat(srcpath)
  } catch {
    return 'file'
  }

  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

function symlinkTypeSync (srcpath, type) {
  if (type) return type

  let stats
  try {
    stats = fs.lstatSync(srcpath)
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType: u(symlinkType),
  symlinkTypeSync
}


/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const jsonFile = __webpack_require__(40)

jsonFile.outputJson = u(__webpack_require__(43))
jsonFile.outputJsonSync = __webpack_require__(45)
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile


/***/ }),
/* 40 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonFile = __webpack_require__(41)

module.exports = {
  // jsonfile exports
  readJson: jsonFile.readFile,
  readJsonSync: jsonFile.readFileSync,
  writeJson: jsonFile.writeFile,
  writeJsonSync: jsonFile.writeFileSync
}


/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let _fs
try {
  _fs = __webpack_require__(14)
} catch (_) {
  _fs = __webpack_require__(5)
}
const universalify = __webpack_require__(13)
const { stringify, stripBom } = __webpack_require__(42)

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  const fs = options.fs || _fs

  const shouldThrow = 'throws' in options ? options.throws : true

  let data = await universalify.fromCallback(fs.readFile)(file, options)

  data = stripBom(data)

  let obj
  try {
    obj = JSON.parse(data, options ? options.reviver : null)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile)

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  const fs = options.fs || _fs

  const shouldThrow = 'throws' in options ? options.throws : true

  try {
    let content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs

  const str = stringify(obj, options)

  await universalify.fromCallback(fs.writeFile)(file, str, options)
}

const writeFile = universalify.fromPromise(_writeFile)

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs

  const str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
}

module.exports = jsonfile


/***/ }),
/* 42 */
/***/ ((module) => {

function stringify (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : ''
  const str = JSON.stringify(obj, replacer, spaces)

  return str.replace(/\n/g, EOL) + EOF
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  return content.replace(/^\uFEFF/, '')
}

module.exports = { stringify, stripBom }


/***/ }),
/* 43 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { stringify } = __webpack_require__(42)
const { outputFile } = __webpack_require__(44)

async function outputJson (file, data, options = {}) {
  const str = stringify(data, options)

  await outputFile(file, str, options)
}

module.exports = outputJson


/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const mkdir = __webpack_require__(24)
const pathExists = (__webpack_require__(27).pathExists)

async function outputFile (file, data, encoding = 'utf-8') {
  const dir = path.dirname(file)

  if (!(await pathExists(dir))) {
    await mkdir.mkdirs(dir)
  }

  return fs.writeFile(file, data, encoding)
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}


/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { stringify } = __webpack_require__(42)
const { outputFileSync } = __webpack_require__(44)

function outputJsonSync (file, data, options) {
  const str = stringify(data, options)

  outputFileSync(file, str, options)
}

module.exports = outputJsonSync


/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
module.exports = {
  move: u(__webpack_require__(47)),
  moveSync: __webpack_require__(48)
}


/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const { copy } = __webpack_require__(22)
const { remove } = __webpack_require__(32)
const { mkdirp } = __webpack_require__(24)
const { pathExists } = __webpack_require__(27)
const stat = __webpack_require__(29)

async function move (src, dest, opts = {}) {
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, 'move', opts)

  await stat.checkParentPaths(src, srcStat, dest, 'move')

  // If the parent of dest is not root, make sure it exists before proceeding
  const destParent = path.dirname(dest)
  const parsedParentPath = path.parse(destParent)
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent)
  }

  return doRename(src, dest, overwrite, isChangingCase)
}

async function doRename (src, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest)
    } else if (await pathExists(dest)) {
      throw new Error('dest already exists.')
    }
  }

  try {
    // Try w/ rename first, and try copy + remove if EXDEV
    await fs.rename(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') {
      throw err
    }
    await moveAcrossDevice(src, dest, overwrite)
  }
}

async function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  }

  await copy(src, dest, opts)
  return remove(src)
}

module.exports = move


/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(14)
const path = __webpack_require__(4)
const copySync = (__webpack_require__(22).copySync)
const removeSync = (__webpack_require__(32).removeSync)
const mkdirpSync = (__webpack_require__(24).mkdirpSync)
const stat = __webpack_require__(29)

function moveSync (src, dest, opts) {
  opts = opts || {}
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)
  stat.checkParentPathsSync(src, srcStat, dest, 'move')
  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))
  return doRename(src, dest, overwrite, isChangingCase)
}

function isParentRoot (dest) {
  const parent = path.dirname(dest)
  const parsedPath = path.parse(parent)
  return parsedPath.root === parent
}

function doRename (src, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename(src, dest, overwrite)
  if (overwrite) {
    removeSync(dest)
    return rename(src, dest, overwrite)
  }
  if (fs.existsSync(dest)) throw new Error('dest already exists.')
  return rename(src, dest, overwrite)
}

function rename (src, dest, overwrite) {
  try {
    fs.renameSync(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice(src, dest, overwrite)
  }
}

function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  }
  copySync(src, dest, opts)
  return removeSync(src)
}

module.exports = moveSync


/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(50);
var Document = __webpack_require__(55);
var Schema = __webpack_require__(73);
var errors = __webpack_require__(99);
var Alias = __webpack_require__(56);
var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var Scalar = __webpack_require__(63);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var cst = __webpack_require__(115);
var lexer = __webpack_require__(119);
var lineCounter = __webpack_require__(120);
var parser = __webpack_require__(121);
var publicApi = __webpack_require__(122);
var visit = __webpack_require__(54);



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = identity.isAlias;
exports.isCollection = identity.isCollection;
exports.isDocument = identity.isDocument;
exports.isMap = identity.isMap;
exports.isNode = identity.isNode;
exports.isPair = identity.isPair;
exports.isScalar = identity.isScalar;
exports.isSeq = identity.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;


/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_process = __webpack_require__(51);
var directives = __webpack_require__(52);
var Document = __webpack_require__(55);
var errors = __webpack_require__(99);
var identity = __webpack_require__(53);
var composeDoc = __webpack_require__(100);
var resolveEnd = __webpack_require__(110);

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (identity.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (node_process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),
/* 51 */
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var visit = __webpack_require__(54);

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (identity.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (identity.isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (identity.isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

exports.visit = visit;
exports.visitAsync = visitAsync;


/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(56);
var Collection = __webpack_require__(61);
var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var toJS = __webpack_require__(60);
var Schema = __webpack_require__(73);
var stringifyDocument = __webpack_require__(98);
var anchors = __webpack_require__(57);
var applyReviver = __webpack_require__(59);
var createNode = __webpack_require__(62);
var directives = __webpack_require__(52);

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            stringKeys: false,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return identity.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && identity.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return identity.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new directives.Directives({ version: '1.1' });
                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new directives.Directives({ version });
                opt = { resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema.Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (identity.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(57);
var visit = __webpack_require__(54);
var identity = __webpack_require__(53);
var Node = __webpack_require__(58);
var toJS = __webpack_require__(60);

class Alias extends Node.NodeBase {
    constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
            nodes = ctx.aliasResolveCache;
        }
        else {
            nodes = [];
            visit.visit(doc, {
                Node: (_key, node) => {
                    if (identity.isAlias(node) || identity.hasAnchor(node))
                        nodes.push(node);
                }
            });
            if (ctx)
                ctx.aliasResolveCache = nodes;
        }
        let found = undefined;
        for (const node of nodes) {
            if (node === this)
                break;
            if (node.anchor === this.source)
                found = node;
        }
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS.toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var visit = __webpack_require__(54);

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            prevAnchors ?? (prevAnchors = anchorNames(doc));
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var applyReviver = __webpack_require__(59);
var identity = __webpack_require__(53);
var toJS = __webpack_require__(60);

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

exports.NodeBase = NodeBase;


/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                // eslint-disable-next-line @typescript-eslint/no-array-delete
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !identity.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(62);
var identity = __webpack_require__(53);
var Node = __webpack_require__(58);

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!identity.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    identity.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(56);
var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
        value = value.contents;
    if (identity.isNode(value))
        return value;
    if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            ref.anchor ?? (ref.anchor = onAnchor(value));
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[identity.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[identity.SEQ]
                    : schema[identity.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Node = __webpack_require__(58);
var toJS = __webpack_require__(60);

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(identity.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(62);
var stringifyPair = __webpack_require__(65);
var addPairToJSMap = __webpack_require__(70);
var identity = __webpack_require__(53);

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
            key = key.clone(schema);
        if (identity.isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var stringify = __webpack_require__(66);
var stringifyComment = __webpack_require__(67);

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (identity.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            identity.isCollection(key) ||
            (identity.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        identity.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

exports.stringifyPair = stringifyPair;


/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(57);
var identity = __webpack_require__(53);
var stringifyComment = __webpack_require__(67);
var stringifyString = __webpack_require__(68);

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter(t => t.identify?.(obj));
        if (match.length > 1) {
            const testMatch = match.filter(t => t.test);
            if (testMatch.length > 0)
                match = testMatch;
        }
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = identity.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return identity.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;


/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var foldFlowLines = __webpack_require__(69);

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    // Leading | or > is added later
    let header = (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (!literal) {
        const foldedValue = value
            .replace(/\n+/g, '\n$&')
            .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
            .replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {
            foldOptions.onOverflow = () => {
                literalFallback = true;
            };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
            return `>${header}\n${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}\n${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    if (lineWidth < minContentWidth)
        minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
            ch = text[++i];
        }
        else {
            do {
                ch = text[++i];
            } while (ch && ch !== '\n');
            end = i;
            start = i + 1;
            ch = text[start];
        }
    }
    return end;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var log = __webpack_require__(71);
var merge = __webpack_require__(72);
var stringify = __webpack_require__(66);
var identity = __webpack_require__(53);
var toJS = __webpack_require__(60);

function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
    // TODO: Should drop this special case for bare << handling
    else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map, value);
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_process = __webpack_require__(51);

function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        if (typeof node_process.emitWarning === 'function')
            node_process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);

// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
const MERGE_KEY = '<<';
const merge = {
    identify: value => value === MERGE_KEY ||
        (typeof value === 'symbol' && value.description === MERGE_KEY),
    default: 'key',
    tag: 'tag:yaml.org,2002:merge',
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
};
const isMergeKey = (ctx, key) => (merge.identify(key) ||
    (identity.isScalar(key) &&
        (!key.type || key.type === Scalar.Scalar.PLAIN) &&
        merge.identify(key.value))) &&
    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);
function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
        for (const it of value.items)
            mergeValue(ctx, map, it);
    else if (Array.isArray(value))
        for (const it of value)
            mergeValue(ctx, map, it);
    else
        mergeValue(ctx, map, value);
}
function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}

exports.addMergeToJSMap = addMergeToJSMap;
exports.isMergeKey = isMergeKey;
exports.merge = merge;


/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var map = __webpack_require__(74);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var tags = __webpack_require__(80);

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? tags.getTags(compat, 'compat')
            : compat
                ? tags.getTags(null, compat)
                : null;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

exports.Schema = Schema;


/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var YAMLMap = __webpack_require__(75);

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!identity.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
};

exports.map = map;


/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyCollection = __webpack_require__(76);
var addPairToJSMap = __webpack_require__(70);
var Collection = __webpack_require__(61);
var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var Scalar = __webpack_require__(63);

function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (identity.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (identity.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!identity.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var stringify = __webpack_require__(66);
var stringifyComment = __webpack_require__(67);

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = identity.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
        return start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            return `${str}\n${indent}${end}`;
        }
        else {
            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

exports.stringifyCollection = stringifyCollection;


/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var YAMLSeq = __webpack_require__(78);

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!identity.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
};

exports.seq = seq;


/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(62);
var stringifyCollection = __webpack_require__(76);
var Collection = __webpack_require__(61);
var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var toJS = __webpack_require__(60);

class YAMLSeq extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode.createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyString = __webpack_require__(68);

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(74);
var _null = __webpack_require__(81);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var bool = __webpack_require__(82);
var float = __webpack_require__(83);
var int = __webpack_require__(85);
var schema = __webpack_require__(86);
var schema$1 = __webpack_require__(87);
var binary = __webpack_require__(88);
var merge = __webpack_require__(72);
var omap = __webpack_require__(90);
var pairs = __webpack_require__(91);
var schema$2 = __webpack_require__(92);
var set = __webpack_require__(96);
var timestamp = __webpack_require__(97);

const schemas = new Map([
    ['core', schema.schema],
    ['failsafe', [map.map, seq.seq, string.string]],
    ['json', schema$1.schema],
    ['yaml11', schema$2.schema],
    ['yaml-1.1', schema$2.schema]
]);
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:merge': merge.merge,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge)
            ? schemaTags.concat(merge.merge)
            : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    if (addMergeTag)
        tags = tags.concat(merge.merge);
    return tags.reduce((tags, tag) => {
        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;
        if (!tagObj) {
            const tagName = JSON.stringify(tag);
            const keys = Object.keys(tagsByName)
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags.includes(tagObj))
            tags.push(tagObj);
        return tags;
    }, []);
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var stringifyNumber = __webpack_require__(84);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(84);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(74);
var _null = __webpack_require__(81);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var bool = __webpack_require__(82);
var float = __webpack_require__(83);
var int = __webpack_require__(85);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var map = __webpack_require__(74);
var seq = __webpack_require__(77);

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true$|^false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_buffer = __webpack_require__(89);
var Scalar = __webpack_require__(63);
var stringifyString = __webpack_require__(68);

const binary = {
    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof node_buffer.Buffer === 'function') {
            return node_buffer.Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
            return '';
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof node_buffer.Buffer === 'function') {
            str =
                buf instanceof node_buffer.Buffer
                    ? buf.toString('base64')
                    : node_buffer.Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),
/* 89 */
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var toJS = __webpack_require__(60);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var pairs = __webpack_require__(91);

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (identity.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (identity.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var Scalar = __webpack_require__(63);
var YAMLSeq = __webpack_require__(78);

function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (identity.isPair(item))
                continue;
            else if (identity.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(74);
var _null = __webpack_require__(81);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var binary = __webpack_require__(88);
var bool = __webpack_require__(93);
var float = __webpack_require__(94);
var int = __webpack_require__(95);
var merge = __webpack_require__(72);
var omap = __webpack_require__(90);
var pairs = __webpack_require__(91);
var set = __webpack_require__(96);
var timestamp = __webpack_require__(97);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var stringifyNumber = __webpack_require__(84);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(84);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var YAMLMap = __webpack_require__(75);

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (identity.isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair)
            ? identity.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (identity.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(84);

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, '') ?? ''
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var stringify = __webpack_require__(66);
var stringifyComment = __webpack_require__(67);

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (identity.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = 'â€¦' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + 'â€¦';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + 'â€¦\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Document = __webpack_require__(55);
var composeNode = __webpack_require__(101);
var resolveEnd = __webpack_require__(110);
var resolveProps = __webpack_require__(104);

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(56);
var identity = __webpack_require__(53);
var composeCollection = __webpack_require__(102);
var composeScalar = __webpack_require__(111);
var resolveEnd = __webpack_require__(110);
var utilEmptyScalarPosition = __webpack_require__(114);

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, props, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (atKey &&
        ctx.options.stringKeys &&
        (!identity.isScalar(node) ||
            typeof node.value !== 'string' ||
            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {
        const msg = 'With stringKeys, all keys must be strings';
        onError(tag ?? token, 'NON_STRING_KEY', msg);
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var resolveBlockMap = __webpack_require__(103);
var resolveBlockSeq = __webpack_require__(108);
var resolveFlowCollection = __webpack_require__(109);

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (token.type === 'block-seq') {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken
            ? anchor.offset > tagToken.offset
                ? anchor
                : tagToken
            : (anchor ?? tagToken);
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
            const message = 'Missing newline after block sequence props';
            onError(lastProp, 'MISSING_CHAR', message);
        }
    }
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq')) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = identity.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Pair = __webpack_require__(64);
var YAMLMap = __webpack_require__(75);
var resolveProps = __webpack_require__(104);
var utilContainsNewline = __webpack_require__(105);
var utilFlowIndentCheck = __webpack_require__(106);
var utilMapIncludes = __webpack_require__(107);

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: bm.indent,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: bm.indent,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        if (tab) {
            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
            }
            tab = null;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&
                    token.source.includes('\t')) {
                    tab = token;
                }
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else if (!found || indicator !== 'seq-item-ind')
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    newlineAfterProp = token;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline =
                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== '')) {
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    }
    if (tab &&
        ((atNewline && tab.indent <= parentIndent) ||
            next?.type === 'block-map' ||
            next?.type === 'block-seq'))
        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
    };
}

exports.resolveProps = resolveProps;


/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utilContainsNewline = __webpack_require__(105);

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            utilContainsNewline.containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

exports.flowIndentCheck = flowIndentCheck;


/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b || (identity.isScalar(a) && identity.isScalar(b) && a.value === b.value);
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var YAMLSeq = __webpack_require__(78);
var resolveProps = __webpack_require__(104);
var utilFlowIndentCheck = __webpack_require__(106);

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            parentIndent: bs.indent,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var resolveEnd = __webpack_require__(110);
var resolveProps = __webpack_require__(104);
var utilContainsNewline = __webpack_require__(105);
var utilMapIncludes = __webpack_require__(107);

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (identity.isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // â†’ key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            ctx.atKey = true;
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            ctx.atKey = false;
            // value properties
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                const endRange = (valueNode ?? keyNode).range;
                map.range = [keyNode.range[0], endRange[1], endRange[2]];
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var resolveBlockScalar = __webpack_require__(112);
var resolveFlowScalar = __webpack_require__(113);

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
    }
    else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === 'scalar')
        tag = findScalarTagByTest(ctx, value, token, onError);
    else
        tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[identity.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[identity.SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&
        tag.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

exports.composeScalar = composeScalar;


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            if (trimIndent === 0 && !ctx.atRoot) {
                const message = 'Block scalar values in collections must be indented';
                onError(offset, 'BAD_INDENT', message);
            }
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var resolveEnd = __webpack_require__(110);

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0', // null character
    a: '\x07', // bell character
    b: '\b', // backspace
    e: '\x1b', // escape character
    f: '\f', // form feed
    n: '\n', // line feed
    r: '\r', // carriage return
    t: '\t', // horizontal tab
    v: '\v', // vertical tab
    N: '\u0085', // Unicode next line
    _: '\u00a0', // Unicode non-breaking space
    L: '\u2028', // Unicode line separator
    P: '\u2029', // Unicode paragraph separator
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function emptyScalarPosition(offset, before, pos) {
    if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cstScalar = __webpack_require__(116);
var cstStringify = __webpack_require__(117);
var cstVisit = __webpack_require__(118);

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var resolveBlockScalar = __webpack_require__(112);
var resolveFlowScalar = __webpack_require__(113);
var errors = __webpack_require__(99);
var stringifyString = __webpack_require__(68);

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` â€“ Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` â€“ Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` â€“ Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` â€“ The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(115);

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = new Set('0123456789ABCDEFabcdef');
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(',[]{}');
const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== 'string')
                throw TypeError('source is not a string');
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            let cs = line.indexOf('#');
            while (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t') {
                    dirEnd = cs - 1;
                    break;
                }
                else {
                    cs = line.indexOf('#', cs + 1);
                }
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return s === '---' ? 'doc' : 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else {
                this.indentNext =
                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ')
            ch = this.buffer[++i];
        if (ch === '\t') {
            while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')
                ch = this.buffer[++i];
            nl = i - 1;
        }
        else if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && flowIndicatorChars.has(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.has(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.has(this.buffer[i + 1]) &&
                    hexDigits.has(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_process = __webpack_require__(51);
var cst = __webpack_require__(115);
var lexer = __webpack_require__(119);

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !it.explicitKey;
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent &&
                (it.sep || it.explicitKey) &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start, explicitKey: true });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken], explicitKey: true }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key;
                            // @ts-expect-error type guard is wrong here
                            delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (bv.type === 'block-seq') {
                            if (!it.explicitKey &&
                                it.sep &&
                                !includesToken(it.sep, 'newline')) {
                                yield* this.pop({
                                    type: 'error',
                                    offset: this.offset,
                                    message: 'Unexpected block-seq-ind on same line with key',
                                    source: this.source
                                });
                                return;
                            }
                        }
                        else if (atMapIndent) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, explicitKey: true }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(50);
var Document = __webpack_require__(55);
var errors = __webpack_require__(99);
var log = __webpack_require__(71);
var identity = __webpack_require__(53);
var lineCounter = __webpack_require__(120);
var parser = __webpack_require__(121);

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),
/* 123 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);
const fs = __webpack_require__(11);
const yaml = __webpack_require__(49);

class Config {
    constructor(userConfig = {}) {
        this.defaultConfig = this._loadDefaultConfig();
        this.apiConfig = this._loadApiConfig();
        this.config = this._mergeConfigs(userConfig);
    }

    _loadDefaultConfig() {
        const defaultConfigPath = path.join(__dirname, '..', 'config', 'default.yaml');
        let defaultConfig = {};
        
        try {
            if (fs.existsSync(defaultConfigPath)) {
                const defaultConfigContent = fs.readFileSync(defaultConfigPath, 'utf8');
                defaultConfig = yaml.parse(defaultConfigContent);
            }
        } catch (error) {
            console.warn('Error loading default config:', error);
        }

        return defaultConfig;
    }

    _loadApiConfig() {
        try {
            const backendApiConfig = __webpack_require__(124);
            return backendApiConfig;
        } catch (error) {
            console.warn('Error loading backend API config:', error);
            return null;
        }
    }

    _mergeConfigs(userConfig) {
        const mergedConfig = {
            // åŸºç¡€é…ç½®ï¼ˆæ¥è‡ª default.yamlï¼‰
            ...this.defaultConfig,
            
            // APIé…ç½®é›†æˆ
            api: this.apiConfig ? {
                // è·å–å½“å‰ç¯å¢ƒçš„APIé…ç½®
                current: this.apiConfig.get(process.env.NODE_ENV || 'development'),
                // æä¾›è®¿é—®å…¶ä»–ç¯å¢ƒé…ç½®çš„æ–¹æ³•
                get: (env) => this.apiConfig.get(env),
                getApiUrl: (env, endpoint) => this.apiConfig.getApiUrl(env, endpoint),
                parseServerIP: (apiEndpoint) => this.apiConfig.constructor.parseServerIP(apiEndpoint),
                validate: (env) => this.apiConfig.validate(env)
            } : null,

            // ç”¨æˆ·é…ç½®è¦†ç›–
            ...userConfig
        };

        // å¦‚æœæœ‰APIé…ç½®ï¼Œå°†å…¶é›†æˆåˆ°ç›¸å…³ç»„ä»¶ä¸­
        if (this.apiConfig) {
            const currentApiConfig = this.apiConfig.get(process.env.NODE_ENV || 'development');
            
            // é›†æˆåˆ°å‘é€é…ç½®ä¸­
            if (mergedConfig.batchSize && !mergedConfig.maxRetries) {
                mergedConfig.maxRetries = currentApiConfig.retry.maxAttempts;
                mergedConfig.retryDelay = currentApiConfig.retry.delay;
                mergedConfig.apiEndpoint = currentApiConfig.baseURL + currentApiConfig.endpoints.embed;
            }

            // é›†æˆåˆ°vectorManageré…ç½®ä¸­
            if (mergedConfig.vectorManager) {
                mergedConfig.vectorManager.embedding = {
                    endpoint: currentApiConfig.baseURL + currentApiConfig.endpoints.embed,
                    timeout: currentApiConfig.processing.timeout,
                    auth: currentApiConfig.auth
                };
                mergedConfig.vectorManager.retry = {
                    maxAttempts: currentApiConfig.retry.maxAttempts,
                    delay: currentApiConfig.retry.delay
                };
            }
        }

        return mergedConfig;
    }

    get(key) {
        return this.config[key];
    }

    set(key, value) {
        this.config[key] = value;
    }

    getAll() {
        return this.config;
    }

    // æ–°å¢ï¼šè·å–APIé…ç½®çš„ä¾¿æ·æ–¹æ³•
    getApiConfig(env) {
        return this.config.api ? this.config.api.get(env) : null;
    }

    // æ–°å¢ï¼šè·å–API URLçš„ä¾¿æ·æ–¹æ³•
    getApiUrl(endpoint = 'embed', env) {
        return this.config.api ? this.config.api.getApiUrl(env, endpoint) : null;
    }

    // æ–°å¢ï¼šéªŒè¯é…ç½®
    validate(env) {
        if (this.config.api) {
            return this.config.api.validate(env);
        }
        return true;
    }

    // æ–°å¢ï¼šè·å–é…ç½®æ‘˜è¦ï¼ˆç”¨äºè°ƒè¯•ï¼‰
    getConfigSummary() {
        return {
            hasDefaultConfig: Object.keys(this.defaultConfig).length > 0,
            hasApiConfig: this.apiConfig !== null,
            currentEnvironment: process.env.NODE_ENV || 'development',
            configKeys: Object.keys(this.config),
            apiEndpoints: this.config.api ? Object.keys(this.config.api.current.endpoints) : []
        };
    }
}

module.exports = new Config(); 

/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Code Chunker åç«¯APIé›†æˆé…ç½®
 * åŸºäºåç«¯APIæ–‡æ¡£v1.0.3
 */

const path = __webpack_require__(4);

class BackendAPIConfig {
    constructor() {
        this.config = this._loadConfig();
    }

    _loadConfig() {
        // ä»ç¯å¢ƒå˜é‡è·å–æœåŠ¡å™¨IPï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨é»˜è®¤å€¼
        const serverIP = process.env.BACKEND_API_SERVER_IP || '42.193.14.136:8087';
        const protocol = process.env.BACKEND_API_PROTOCOL || 'http';
        
        // æ„å»ºåŸºç¡€URL
        const baseURL = `${protocol}://${serverIP}`;
        
        return {
            development: {
                baseURL: baseURL,
                endpoints: {
                    health: '/healthz',
                    version: '/version',
                    embed: '/api/v1/codebase/embed',
                    embedStatus: '/api/v1/codebase/embed/status',
                    embedResults: '/api/v1/codebase/embed/results',
                },
                auth: {
                    token: process.env.BACKEND_API_TOKEN || 'test_auth_token',
                },
                processing: {
                    mode: 'auto', // 'sync', 'async', 'auto'
                    syncThreshold: 20, // å°äºç­‰äº20ä¸ªå—ä½¿ç”¨åŒæ­¥æ¨¡å¼
                    batchSize: 15, // æ¨èæ‰¹æ¬¡å¤§å°
                    maxConcurrency: 3,
                    timeout: 30000,
                },
                retry: {
                    maxAttempts: 3,
                    delay: 1000,
                    backoffMultiplier: 2,
                },
                async: {
                    pollInterval: 2000,
                    maxPollAttempts: 30,
                },
                monitoring: {
                    enabled: true,
                    logLevel: 'info',
                    metrics: {
                        collectResponseTimes: true,
                        collectErrorRates: true,
                    },
                },
            },
            production: {
                baseURL: baseURL,
                endpoints: {
                    health: '/healthz',
                    version: '/version',
                    embed: '/api/v1/codebase/embed',
                    embedStatus: '/api/v1/codebase/embed/status',
                    embedResults: '/api/v1/codebase/embed/results',
                },
                auth: {
                    token: process.env.BACKEND_API_TOKEN || 'test_auth_token',
                },
                processing: {
                    mode: 'auto',
                    syncThreshold: 20,
                    batchSize: 15,
                    maxConcurrency: 5,
                    timeout: 45000,
                },
                retry: {
                    maxAttempts: 5,
                    delay: 2000,
                    backoffMultiplier: 2,
                },
                async: {
                    pollInterval: 3000,
                    maxPollAttempts: 50,
                },
                monitoring: {
                    enabled: true,
                    logLevel: 'warn',
                    metrics: {
                        collectResponseTimes: true,
                        collectErrorRates: true,
                    },
                },
            },
            test: {
                baseURL: baseURL,
                endpoints: {
                    health: '/healthz',
                    version: '/version',
                    embed: '/api/v1/codebase/embed',
                    embedStatus: '/api/v1/codebase/embed/status',
                    embedResults: '/api/v1/codebase/embed/results',
                },
                auth: {
                    token: process.env.BACKEND_API_TOKEN || 'test_auth_token',
                },
                processing: {
                    mode: 'sync',
                    syncThreshold: 10,
                    batchSize: 5,
                    maxConcurrency: 2,
                    timeout: 15000,
                },
                retry: {
                    maxAttempts: 2,
                    delay: 500,
                    backoffMultiplier: 1.5,
                },
                async: {
                    pollInterval: 1000,
                    maxPollAttempts: 10,
                },
                monitoring: {
                    enabled: true,
                    logLevel: 'debug',
                    metrics: {
                        collectResponseTimes: true,
                        collectErrorRates: true,
                    },
                },
            },
        };
    }

    get(env = 'development') {
        return this.config[env] || this.config.development;
    }

    // è·å–å®Œæ•´çš„API URL
    getApiUrl(env = 'development', endpoint = 'embed') {
        const config = this.get(env);
        return `${config.baseURL}${config.endpoints[endpoint]}`;
    }

    // ä»é…ç½®å­—ç¬¦ä¸²ä¸­è§£ææœåŠ¡å™¨IPï¼ˆæ”¯æŒç°æœ‰çš„<SERVER_IP>æ ¼å¼ï¼‰
    static parseServerIP(apiEndpoint) {
        if (typeof apiEndpoint !== 'string') {
            return null;
        }
        
        // å¦‚æœåŒ…å«<SERVER_IP>å ä½ç¬¦ï¼Œä½¿ç”¨ç¯å¢ƒå˜é‡æ›¿æ¢
        if (apiEndpoint.includes('<SERVER_IP>')) {
            const serverIP = process.env.BACKEND_API_SERVER_IP || '42.193.14.136:8087';
            return apiEndpoint.replace('<SERVER_IP>', serverIP);
        }
        
        return apiEndpoint;
    }

    // éªŒè¯é…ç½®
    validate(env = 'development') {
        const config = this.get(env);
        const errors = [];

        if (!config.baseURL) {
            errors.push('baseURL is required');
        }

        if (!config.auth.token) {
            errors.push('auth.token is required');
        }

        if (!config.endpoints.embed) {
            errors.push('endpoints.embed is required');
        }

        if (errors.length > 0) {
            throw new Error(`Backend API configuration validation failed: ${errors.join(', ')}`);
        }

        return true;
    }
}

module.exports = new BackendAPIConfig(); 

/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const { minimatch } = __webpack_require__(126);
const crypto = __webpack_require__(8);
const PathUtils = __webpack_require__(134);
const FileTypeDetector = __webpack_require__(135);
const IntelligentFileFilter = __webpack_require__(136);

class FileScanner {
    constructor(config, performanceAnalyzer = null) {
        this.config = config;
        this.performanceAnalyzer = performanceAnalyzer;
        
        // ğŸ”¥ å®Œå…¨ä¾èµ–é…ç½®æ–‡ä»¶çš„ç™½åå•ï¼Œç§»é™¤ç¡¬ç¼–ç é»˜è®¤å€¼
        if (!config.scanFileExtensions || !Array.isArray(config.scanFileExtensions) || config.scanFileExtensions.length === 0) {
            throw new Error('âŒ scanFileExtensionsé…ç½®ç¼ºå¤±æˆ–æ— æ•ˆï¼å¿…é¡»åœ¨é…ç½®æ–‡ä»¶ä¸­æŒ‡å®šè¦å¤„ç†çš„æ–‡ä»¶æ‰©å±•åç™½åå•ã€‚');
        }
        
        this.scanFileExtensions = new Set(
            config.scanFileExtensions.map(ext => ext.toLowerCase())
        );
        
        // ğŸ”¥ å®Œå…¨ä¾èµ–é…ç½®çš„å¿½ç•¥æ¨¡å¼ï¼Œç§»é™¤ç¡¬ç¼–ç 
        this.ignorePatterns = config.ignorePatterns || [];
        
        this.maxFileSize = config.maxFileSize || 2 * 1024 * 1024; // é»˜è®¤2MB
        this.workspacePath = config.workspacePath || null;
        
            // æ·»åŠ ç¬¦å·é“¾æ¥å¾ªç¯æ£€æµ‹
            this.visitedPaths = new Set(); // ç”¨äºæ£€æµ‹å¾ªç¯å¼•ç”¨
            this.processSymlinks = config.processSymlinks !== false; // é»˜è®¤å¤„ç†ç¬¦å·é“¾æ¥
            this.maxSymlinkDepth = config.maxSymlinkDepth || 10; // æœ€å¤§ç¬¦å·é“¾æ¥æ·±åº¦
            
            // æ·»åŠ é€’å½’æ·±åº¦æ§åˆ¶
            this.maxDepth = config.maxDepth || 100; // é»˜è®¤æœ€å¤§ç›®å½•æ·±åº¦

            // æ·»åŠ æ–‡ä»¶ç±»å‹æ£€æµ‹å™¨
            this.fileTypeDetector = new FileTypeDetector();
            this.includeTextContentOnly = config.includeTextContentOnly !== false; // é»˜è®¤åªåŒ…å«æ–‡æœ¬å†…å®¹
            this.processBinaryFiles = config.processBinaryFiles !== false; // é»˜è®¤å¤„ç†äºŒè¿›åˆ¶æ–‡ä»¶ä½†ä¸åŒ…å«å†…å®¹
        
        // ğŸ¯ æ·»åŠ æ™ºèƒ½æ–‡ä»¶ç­›é€‰å™¨
        this.intelligentFilter = new IntelligentFileFilter();
        this.enableIntelligentFiltering = config.enableIntelligentFiltering !== false; // é»˜è®¤å¯ç”¨æ™ºèƒ½ç­›é€‰
        
        // ğŸ”¥ å®Œå…¨ä¾èµ–é…ç½®çš„ç›®å½•å¿½ç•¥åˆ—è¡¨
        this.ignoredDirectories = new Set(config.ignoredDirectories || []);
        }

    async scanWorkspace(workspacePath) {
        // å¼€å§‹è®¡æ—¶ï¼šFileScanneråˆå§‹åŒ–
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startModuleTimer('fileScanner', 'initTime');
            this.performanceAnalyzer.recordMemoryUsage('fileScanner_start');
        }

        // å‚æ•°éªŒè¯
        if (!workspacePath || typeof workspacePath !== 'string') {
            throw new Error('Invalid workspace path: path must be a non-empty string');
        }
    
        // è·¯å¾„å­˜åœ¨æ€§å’Œç±»å‹æ£€æŸ¥
        try {
            const stats = await fs.stat(workspacePath);
            if (!stats.isDirectory()) {
                throw new Error(`Path is not a directory: ${workspacePath}`);
            }
        } catch (error) {
            if (error.code === 'ENOENT') {
                throw new Error(`Workspace path does not exist: ${workspacePath}`);
            } else if (error.code === 'EACCES') {
                throw new Error(`Permission denied to access workspace: ${workspacePath}`);
            }
            throw error;
        }
    
        // æƒé™æ£€æŸ¥
        try {
            await fs.access(workspacePath, fs.constants.R_OK);
        } catch (error) {
            throw new Error(`No read permission for workspace: ${workspacePath}`);
        }
    
        this.workspacePath = path.resolve(workspacePath); // è§„èŒƒåŒ–è·¯å¾„
        this.visitedPaths.clear(); // æ¸…ç†ä¹‹å‰çš„è®¿é—®è®°å½•
        const fileList = [];
        const fileHashes = {};
        const fileContents = [];
        const fileInfos = [];
    
        // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯è·Ÿè¸ª
        this.scanStats = {
            totalFilesScanned: 0,
            skippedFiles: 0,
            processedFiles: 0,
            skippedDirectories: 0
        };
    
        // ç»“æŸåˆå§‹åŒ–ï¼Œå¼€å§‹æ‰«æ
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('fileScanner', 'initTime');
            this.performanceAnalyzer.startModuleTimer('fileScanner', 'scanTime');
        }
    
        try {
            await this._scanDirectory(this.workspacePath, fileList, fileHashes, fileContents, fileInfos, 0, 0);
            
            // ç»“æŸæ‰«æï¼Œå¼€å§‹è¿‡æ»¤
            if (this.performanceAnalyzer) {
                this.performanceAnalyzer.endModuleTimer('fileScanner', 'scanTime');
                this.performanceAnalyzer.startModuleTimer('fileScanner', 'filterTime');
            }
            
            const merkleTree = await this._buildMerkleTree(fileList, fileHashes, fileInfos);
            
            // ç»“æŸè¿‡æ»¤
            if (this.performanceAnalyzer) {
                this.performanceAnalyzer.endModuleTimer('fileScanner', 'filterTime');
                this.performanceAnalyzer.recordMemoryUsage('fileScanner_end');
            }
            
            console.log(`[FileScanner] âœ… æ‰«æå®Œæˆ: å‘ç° ${fileList.length} ä¸ªæ–‡ä»¶`);
            
            return { 
                fileList, 
                merkleTree: merkleTree, 
                fileContents, 
                fileHashes,
                scanStats: this.scanStats
            };
        } catch (error) {
            console.error('[FileScanner] âŒ æ‰«æå·¥ä½œåŒºæ—¶å‡ºé”™:', error);
            throw error;
        }
    }

    async _scanDirectory(dir, fileList, fileHashes, fileContents, fileInfos, symlinkDepth = 0, depth = 0) {
        // æ£€æŸ¥é€’å½’æ·±åº¦
        if (depth > this.maxDepth) {
            const relativePath = path.relative(this.workspacePath, dir);
            console.warn(`Maximum directory depth (${this.maxDepth}) exceeded: ${relativePath || '.'}`);
            return;
        }
        
        // ğŸ”¥ ç›®å½•çº§åˆ«çš„å¿«é€Ÿå¿½ç•¥æ£€æŸ¥ - æå‰ç»ˆæ­¢æ•´ä¸ªç›®å½•æ ‘çš„æ‰«æ
        const dirName = path.basename(dir);
        if (this.ignoredDirectories.has(dirName)) {
            return;
        }
        
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            let relativePath = path.relative(this.workspacePath, fullPath);

            // æ ‡å‡†åŒ–è·¯å¾„ä¸ºæ­£æ–œæ æ ¼å¼ï¼ˆè·¨å¹³å°å…¼å®¹ï¼‰
            relativePath = PathUtils.normalizePath(relativePath);

            // ğŸ”¥ å¢å¼ºçš„å¿½ç•¥æ£€æŸ¥ - å…ˆæ£€æŸ¥ç›®å½•çº§å¿½ç•¥ï¼Œå†æ£€æŸ¥æ¨¡å¼åŒ¹é…
            if (entry.isDirectory()) {
                // ç›®å½•çº§å¿«é€Ÿå¿½ç•¥
                if (this.ignoredDirectories.has(entry.name)) {
                    this.scanStats.skippedDirectories++;
                continue;
            }

                // ä½¿ç”¨æ–°çš„æ‰«æé€»è¾‘æ£€æŸ¥ç›®å½•
                if (!this._shouldScan(relativePath + '/')) { // ç›®å½•è·¯å¾„åŠ æ–œæ 
                    this.scanStats.skippedDirectories++;
                    continue;
                }

                await this._scanDirectory(fullPath, fileList, fileHashes, fileContents, fileInfos, symlinkDepth, depth + 1);
            } else if (entry.isFile()) {
                this.scanStats.totalFilesScanned++;
                
                // 1. ğŸ”¥ æ–°çš„ç™½åå•æ‰«ææ£€æŸ¥
                if (!this._shouldScan(relativePath)) {
                    this.scanStats.skippedFiles++;
                    continue;
                }
                
                // 2. ğŸ¯ æ™ºèƒ½æ–‡ä»¶ç­›é€‰æ£€æŸ¥
                if (this.enableIntelligentFiltering) {
                    if (!this.intelligentFilter.isValuableFile(relativePath)) {
                        this.scanStats.skippedFiles++;
                        continue;
                    }
                }
                
                await this._processFile(fullPath, relativePath, fileList, fileHashes, fileContents, fileInfos);
                this.scanStats.processedFiles++;
            } else if (entry.isSymbolicLink()) {
                // æ£€æŸ¥ç¬¦å·é“¾æ¥æ˜¯å¦åº”è¯¥æ‰«æ
                if (!this._shouldScan(relativePath)) {
                    continue;
                }
                
                // å¤„ç†ç¬¦å·é“¾æ¥
                await this._processSymbolicLink(fullPath, relativePath, fileList, fileHashes, fileContents, symlinkDepth);
            } else {
                // è®°å½•å…¶ä»–ç‰¹æ®Šæ–‡ä»¶ç±»å‹
                this._logSpecialFileType(entry, relativePath);
            }
        }
    }

    /**
     * ğŸ”¥ æ–°æ–¹æ³•ï¼šåŸºäºç™½åå•çš„æ–‡ä»¶æ‰«æåˆ¤æ–­
     * åªæ‰«æé…ç½®ä¸­æŒ‡å®šçš„æ–‡ä»¶æ‰©å±•åï¼Œå¤§å¤§æå‡æ‰«ææ•ˆç‡
     */
    _shouldScan(filePath) {
        // ğŸ”¥ å¿«é€Ÿè·¯å¾„æ£€æŸ¥ - æ£€æŸ¥æ˜¯å¦åŒ…å«è¢«å¿½ç•¥çš„ç›®å½•æ®µ
        const pathSegments = filePath.split('/');
        for (const segment of pathSegments) {
            if (this.ignoredDirectories.has(segment)) {
                return false; // è·¯å¾„ä¸­åŒ…å«è¢«å¿½ç•¥çš„ç›®å½•
            }
        }
        
        // ğŸ”¥ ç›®å½•ç‰¹æ®Šå¤„ç†ï¼šç›®å½•æœ¬èº«åº”è¯¥å…è®¸æ‰«æï¼ˆä¸å—æ‰©å±•åé™åˆ¶ï¼‰
        if (filePath.endsWith('/')) {
            // è¿™æ˜¯ç›®å½•ï¼Œåªæ£€æŸ¥æ¨¡å¼åŒ¹é…
            return !this.ignorePatterns.some(pattern => minimatch(filePath, pattern));
        }
        
        // ğŸ”¥ ç‰¹æ®Šæ–‡ä»¶æ£€æŸ¥ - ä¼˜å…ˆçº§æœ€é«˜çš„å¿½ç•¥é€»è¾‘
        const fileBaseName = path.basename(filePath).toLowerCase();
        
        // å¿½ç•¥ CUDA ç›¸å…³çš„å¤§å‹ç”Ÿæˆæ–‡ä»¶
        if (fileBaseName.includes('.cubin.') || fileBaseName.includes('_cubin.') || 
            fileBaseName.includes('.ptx.') || fileBaseName.includes('_ptx.') ||
            fileBaseName.includes('.fatbin.') || fileBaseName.includes('_fatbin.') ||
            fileBaseName.includes('cubin.cpp') || fileBaseName.includes('ptx.cpp')) {
            console.log(`ğŸš« Ignoring CUDA binary file: ${filePath}`);
            return false;
        }
        
        // ğŸ”¥ ç™½åå•æ‰©å±•åæ£€æŸ¥ - è¿™æ˜¯æ ¸å¿ƒé€»è¾‘ï¼ˆåªå¯¹æ–‡ä»¶ç”Ÿæ•ˆï¼‰
        const ext = path.extname(filePath).toLowerCase();
        if (!ext || !this.scanFileExtensions.has(ext)) {
            // æ·»åŠ è°ƒè¯•ä¿¡æ¯æ¥ç¡®è®¤æ–‡ä»¶æ˜¯å¦è¢«æ­£ç¡®å¿½ç•¥
            if (filePath.includes('.cubin')) {
                console.log(`ğŸš« Ignoring cubin file: ${filePath} (extension: ${ext || 'none'})`);
            }
            return false; // æ²¡æœ‰æ‰©å±•åæˆ–æ‰©å±•åä¸åœ¨ç™½åå•ä¸­
        }
        
        // ğŸ”¥ ç‰¹æ®Šæ–‡ä»¶åæ£€æŸ¥ï¼ˆå³ä½¿æ‰©å±•åæ­£ç¡®ä¹Ÿè¦å¿½ç•¥ï¼‰
        const fileName = fileBaseName;
        const specialIgnoredFiles = [
            '.ds_store', 'thumbs.db', 'desktop.ini',
            // ç¼–è¯‘å’Œå‹ç¼©æ–‡ä»¶ï¼ˆå³ä½¿æ‰©å±•ååŒ¹é…ä¹Ÿè¦å¿½ç•¥ï¼‰
            '.min.js', '.min.css', '.bundle.js', '.bundle.css',
            '.chunk.js', '.chunk.css'
        ];
        if (specialIgnoredFiles.includes(fileName)) {
            return false;
        }
        
        // æ£€æŸ¥æ˜¯å¦æ˜¯ç¼–è¯‘/å‹ç¼©æ–‡ä»¶
        if (fileName.includes('.min.') || fileName.includes('.bundle.') || fileName.includes('.chunk.')) {
            return false;
        }
        
        // ğŸ”¥ æœ€åä½¿ç”¨æ¨¡å¼åŒ¹é…è¿›è¡Œé¢å¤–æ£€æŸ¥ï¼ˆæœ€è€—æ—¶ï¼Œæ”¾åœ¨æœ€åï¼‰
        if (this.ignorePatterns.some(pattern => {
            const match = minimatch(filePath, pattern);
            if (match && filePath.includes('.cubin')) {
                console.log(`ğŸš« Ignoring cubin file by pattern: ${filePath} (matched pattern: ${pattern})`);
            }
            return match;
        })) {
            return false;
        }
        
        return true; // é€šè¿‡æ‰€æœ‰æ£€æŸ¥ï¼Œåº”è¯¥æ‰«ææ­¤æ–‡ä»¶
    }
    
    /**
     * ğŸ”¥ ä¿ç•™åŸæœ‰æ–¹æ³•åçš„å…¼å®¹æ€§å°è£…
     * @deprecated å»ºè®®ä½¿ç”¨ _shouldScan æ–¹æ³•
     */
    _shouldIgnore(filePath) {
        return !this._shouldScan(filePath);
    }

        // æå–æ–‡ä»¶å¤„ç†é€»è¾‘ä¸ºç‹¬ç«‹æ–¹æ³•
        async _processFile(fullPath, relativePath, fileList, fileHashes, fileContents, fileInfos) {
            try {
                const stats = await fs.stat(fullPath);
                
                // ğŸ”¥ æå‰æ£€æŸ¥æ–‡ä»¶å¤§å° - é¿å…è¯»å–å¤§æ–‡ä»¶
                if (stats.size > this.maxFileSize) {
                    console.warn(`File ${relativePath} exceeds maximum size limit (${stats.size} bytes, max: ${this.maxFileSize} bytes)`);
                    this.scanStats.skippedFiles++;
                    return;
                }
        
                // ä½¿ç”¨æ–°çš„æ–‡ä»¶è¯»å–å’Œç±»å‹æ£€æµ‹é€»è¾‘
                const buffer = await fs.readFile(fullPath);
                const fileInfo = this.fileTypeDetector.analyzeFile(buffer, relativePath);
                
                // å¤„ç†æ–‡ä»¶ä¿¡æ¯
                if (fileInfo.error) {
                    console.warn(`Failed to analyze file ${relativePath}: ${fileInfo.error}`);
                    return;
                }
                
                // å†³å®šæ˜¯å¦å¤„ç†æ­¤æ–‡ä»¶
                if (fileInfo.isBinary && !this.processBinaryFiles) {
                    return;
                }
                
                // å…³é”®ä¿®å¤ï¼šåªæœ‰æ‰€æœ‰æ“ä½œéƒ½æˆåŠŸåï¼Œæ‰åŒæ—¶æ·»åŠ åˆ°æ‰€æœ‰æ•°æ®ç»“æ„
                // è¿™ç¡®ä¿äº† fileListã€fileContents å’Œ fileHashes çš„ç´¢å¼•å¯¹åº”å…³ç³»
                fileList.push(relativePath);
                fileHashes[relativePath] = fileInfo.hash;

                fileInfos.push({
                    path: relativePath,
                    fullPath: fullPath,
                    stats: stats,
                    hash: fileInfo.hash,
                    isBinary: fileInfo.isBinary,
                    encoding: fileInfo.encoding
                });
                
                if (fileInfo.isBinary) {
                    // å¯¹äºäºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå­˜å‚¨ç‰¹æ®Šæ ‡è®°è€Œä¸æ˜¯å†…å®¹
                    if (this.includeTextContentOnly) {
                        fileContents.push(`[BINARY FILE: ${stats.size} bytes, type: ${this._getFileType(relativePath)}]`);
                    } else {
                        // å¦‚æœéœ€è¦åŒ…å«äºŒè¿›åˆ¶æ–‡ä»¶ï¼Œå¯ä»¥å­˜å‚¨base64ç¼–ç 
                        fileContents.push(`[BINARY:${buffer.toString('base64')}]`);
                    }
                } else {
                    // å¯¹äºæ–‡æœ¬æ–‡ä»¶ï¼Œå­˜å‚¨å†…å®¹
                    fileContents.push(fileInfo.content);
                }
                
            } catch (error) {
                // å®Œæ•´çš„é”™è¯¯å¤„ç†ï¼šå¤„ç†å„ç§å¯èƒ½çš„é”™è¯¯æƒ…å†µ
                if (error.code === 'ENOENT') {
                    console.warn(`File ${relativePath} was deleted during scan`);
                } else if (error.code === 'EACCES') {
                    console.warn(`Permission denied reading file ${relativePath}`);
                } else if (error.code === 'EISDIR') {
                    console.warn(`Expected file but found directory: ${relativePath}`);
                } else if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                    console.warn(`Too many open files, skipping ${relativePath}`);
                } else if (error.message.includes('invalid byte sequence') || 
                           error.message.includes('malformed UTF-8') ||
                           error.message.includes('Invalid or incomplete UTF-8')) {
                    console.warn(`File ${relativePath} contains non-UTF-8 content, skipping`);
                } else {
                    console.warn(`Failed to process file ${relativePath}: ${error.message}`);
                }
                // å¤„ç†å¤±è´¥çš„æ–‡ä»¶ä¸ä¼šè¢«æ·»åŠ åˆ°ä»»ä½•æ•°ç»„ä¸­ï¼Œä¿æŒæ•°æ®ä¸€è‡´æ€§
            }
        }
    
        // ç¬¦å·é“¾æ¥å¤„ç†æ–¹æ³•
        async _processSymbolicLink(fullPath, relativePath, fileList, fileHashes, fileContents, symlinkDepth) {
            if (!this.processSymlinks) {
                console.debug(`Skipping symbolic link (disabled): ${relativePath}`);
                return;
            }
    
            // æ£€æŸ¥ç¬¦å·é“¾æ¥æ·±åº¦
            if (symlinkDepth >= this.maxSymlinkDepth) {
                console.warn(`Maximum symbolic link depth exceeded: ${relativePath} (depth: ${symlinkDepth})`);
                return;
            }
    
            try {
                // è¯»å–ç¬¦å·é“¾æ¥ç›®æ ‡
                const linkTarget = await fs.readlink(fullPath);
                const resolvedPath = path.resolve(path.dirname(fullPath), linkTarget);
                
                // æ£€æŸ¥å¾ªç¯å¼•ç”¨
                if (this._isCircularReference(resolvedPath, fullPath)) {
                    console.warn(`Circular reference detected: ${relativePath} -> ${linkTarget}`);
                    return;
                }
    
                // æ£€æŸ¥é“¾æ¥ç›®æ ‡æ˜¯å¦å­˜åœ¨å¹¶è·å–å…¶çŠ¶æ€
                let targetStats;
                try {
                    targetStats = await fs.stat(resolvedPath);
                } catch (statError) {
                    if (statError.code === 'ENOENT') {
                        console.warn(`Broken symbolic link: ${relativePath} -> ${linkTarget} (target not found)`);
                    } else if (statError.code === 'EACCES') {
                        console.warn(`Broken symbolic link: ${relativePath} -> ${linkTarget} (permission denied)`);
                    } else {
                        console.warn(`Broken symbolic link: ${relativePath} -> ${linkTarget} (${statError.message})`);
                    }
                    return;
                }
    
                // æ£€æŸ¥æ˜¯å¦æŒ‡å‘å·¥ä½œåŒºå¤–éƒ¨
                const resolvedRelative = path.relative(this.workspacePath, resolvedPath);
                if (resolvedRelative.startsWith('..') || path.isAbsolute(resolvedRelative)) {
                    console.warn(`Symbolic link points outside workspace: ${relativePath} -> ${linkTarget}`);
                    return;
                }
    
                // è®°å½•è®¿é—®çš„è·¯å¾„ä»¥æ£€æµ‹å¾ªç¯
                this.visitedPaths.add(path.resolve(fullPath));
    
                try {
                    if (targetStats.isDirectory()) {
                        // å¤„ç†ç›®å½•ç¬¦å·é“¾æ¥
                        await this._scanDirectory(resolvedPath, fileList, fileHashes, fileContents, fileInfos, symlinkDepth + 1, depth + 1);
                    } else if (targetStats.isFile()) {
                        // å¤„ç†æ–‡ä»¶ç¬¦å·é“¾æ¥
                        await this._processFile(resolvedPath, relativePath, fileList, fileHashes, fileContents, fileInfos);
                    }
                } finally {
                    // æ¸…ç†è®¿é—®è®°å½•
                    this.visitedPaths.delete(path.resolve(fullPath));
                }
    
            } catch (error) {
                console.warn(`Error processing symbolic link ${relativePath}: ${error.message}`);
            }
        }
    
        // å¾ªç¯å¼•ç”¨æ£€æµ‹
        _isCircularReference(resolvedPath, currentPath) {
            const normalizedResolved = path.resolve(resolvedPath);
            const normalizedCurrent = path.resolve(currentPath);
            
            // æ£€æŸ¥æ˜¯å¦æŒ‡å‘è‡ªå·±
            if (normalizedResolved === normalizedCurrent) {
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»è®¿é—®è¿‡
            if (this.visitedPaths.has(normalizedResolved)) {
                return true;
            }
            
            // æ£€æŸ¥æ˜¯å¦æŒ‡å‘çˆ¶ç›®å½•ï¼ˆå¯èƒ½é€ æˆå¾ªç¯ï¼‰
            let parent = path.dirname(normalizedCurrent);
            while (parent !== path.dirname(parent)) { // ç›´åˆ°æ ¹ç›®å½•
                if (normalizedResolved === parent) {
                    return true;
                }
                parent = path.dirname(parent);
            }
            
            return false;
        }
    
        // ç‰¹æ®Šæ–‡ä»¶ç±»å‹è®°å½•
        _logSpecialFileType(entry, relativePath) {
            let fileType = 'unknown';
            
            if (entry.isBlockDevice()) {
                fileType = 'block device';
            } else if (entry.isCharacterDevice()) {
                fileType = 'character device';
            } else if (entry.isFIFO()) {
                fileType = 'FIFO/pipe';
            } else if (entry.isSocket()) {
                fileType = 'socket';
            }
            

        }

        // æ·»åŠ æ–‡ä»¶ç±»å‹åˆ¤æ–­æ–¹æ³•
        _getFileType(filePath) {
            const ext = path.extname(filePath).toLowerCase();
            const typeMap = {
                '.jpg': 'image', '.jpeg': 'image', '.png': 'image', '.gif': 'image', '.bmp': 'image',
                '.mp3': 'audio', '.wav': 'audio', '.mp4': 'video', '.avi': 'video',
                '.zip': 'archive', '.rar': 'archive', '.7z': 'archive', '.tar': 'archive',
                '.pdf': 'document', '.doc': 'document', '.docx': 'document',
                '.exe': 'executable', '.dll': 'executable', '.so': 'executable'
            };
            return typeMap[ext] || 'binary';
        }

    async _calculateFileHash(filePath) {
        const content = await fs.readFile(filePath);
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    async _buildMerkleTree(fileList, fileHashes, fileInfos) {
        const merkleTree = {
            // æ ¹èŠ‚ç‚¹ä¿¡æ¯
            root: {
                hash: this._calculateRootHash(fileHashes),
                timestamp: Date.now(),
                fileCount: fileList.length
            },
            
            // æ–‡ä»¶èŠ‚ç‚¹æ˜ å°„
            files: {},
            
            // ç›®å½•èŠ‚ç‚¹æ˜ å°„
            directories: {},
            
            // å¿«é€Ÿç´¢å¼•
            index: {
                byExtension: {},
                bySize: { small: [], medium: [], large: [] },
                recentlyModified: []
            },
            
            // å…ƒæ•°æ®
            metadata: {
                version: "2.0",
                createdAt: Date.now(),
                workspace: this.workspacePath,
                totalSize: 0,
                treeDepth: 0
            }
        };

        // æ„å»ºæ–‡ä»¶å’Œç›®å½•æ˜ å°„
        await this._buildFileDirectoryMappings(fileInfos, fileHashes, merkleTree);
        
        // æ„å»ºç´¢å¼•
        await this._buildIndexes(fileInfos, merkleTree);
        
        return merkleTree;
    }

    async _buildFileDirectoryMappings(fileInfos, fileHashes, tree) {
        const directoryContents = {};
        
        for (const fileInfo of fileInfos) {
            const { path: relativePath, stats } = fileInfo;  // âœ… å¤ç”¨å·²æœ‰çš„statsä¿¡æ¯
            const parentDir = PathUtils.getParentDir(relativePath);
            
            // æ·»åŠ æ–‡ä»¶ä¿¡æ¯ - ä½¿ç”¨å·²æ”¶é›†çš„statsï¼Œé¿å…é‡å¤ç³»ç»Ÿè°ƒç”¨
            tree.files[relativePath] = {
                hash: fileInfo.hash,
                size: stats.size,
                lastModified: stats.mtime.getTime(),
                path: relativePath,
                parentPath: PathUtils.isCurrentDir(parentDir) ? '' : parentDir
            };
            
            // æ”¶é›†ç›®å½•ä¿¡æ¯
            if (!directoryContents[parentDir]) {
                directoryContents[parentDir] = {
                    files: [],
                    subdirs: new Set()
                };
            }
            directoryContents[parentDir].files.push(relativePath);
            
            // å¤„ç†åµŒå¥—ç›®å½•
            let currentDir = parentDir;
            while (currentDir && currentDir !== '' && !PathUtils.isCurrentDir(currentDir)) {
                const parentOfCurrent = PathUtils.getParentOfDir(currentDir);
                if (PathUtils.isCurrentDir(parentOfCurrent) || PathUtils.pathEquals(parentOfCurrent, currentDir)) break;
                
                if (!directoryContents[parentOfCurrent]) {
                    directoryContents[parentOfCurrent] = {
                        files: [],
                        subdirs: new Set()
                    };
                }
                directoryContents[parentOfCurrent].subdirs.add(currentDir);
                currentDir = parentOfCurrent;
            }
        }
        
        // æŒ‰ç›®å½•æ·±åº¦æ’åºï¼Œç¡®ä¿å­ç›®å½•å…ˆäºçˆ¶ç›®å½•å¤„ç†
        const sortedDirs = Object.keys(directoryContents)
            .filter(dir => !PathUtils.isCurrentDir(dir))
            .sort((a, b) => {
                const depthA = PathUtils.getPathDepth(a);
                const depthB = PathUtils.getPathDepth(b);
                return depthB - depthA; // æ·±åº¦å¤§çš„å…ˆå¤„ç†ï¼ˆè‡ªåº•å‘ä¸Šï¼‰
            });
        
        // è‡ªåº•å‘ä¸Šæ„å»ºç›®å½•èŠ‚ç‚¹å¹¶è®¡ç®—æ­£ç¡®çš„å“ˆå¸Œå€¼
        for (const dirPath of sortedDirs) {
            const contents = directoryContents[dirPath];
            const subdirs = Array.from(contents.subdirs);
            const allChildren = [...contents.files, ...subdirs];

            tree.directories[dirPath] = {
                hash: this._calculateDirectoryHash(allChildren, tree.files, tree.directories),
                fileCount: contents.files.length,
                children: allChildren,
                files: contents.files,
                subdirs: subdirs
            };
        }
    }

    async _buildIndexes(fileInfos, tree) {
        for (const fileInfo of fileInfos) {
            const { path: relativePath, stats } = fileInfo;
            const ext = path.extname(relativePath);
            const treeFileInfo = tree.files[relativePath];
            
            // æŒ‰æ‰©å±•ååˆ†ç»„
            if (!tree.index.byExtension[ext]) {
                tree.index.byExtension[ext] = [];
            }
            tree.index.byExtension[ext].push(relativePath);
            
            // æŒ‰å¤§å°åˆ†ç»„
            if (stats.size < 10240) { // âœ… ä½¿ç”¨ stats.size
                tree.index.bySize.small.push(relativePath);
            } else if (stats.size < 102400) { // âœ… ä½¿ç”¨ stats.size
                tree.index.bySize.medium.push(relativePath);
            } else {
                tree.index.bySize.large.push(relativePath);
            }
            
            tree.metadata.totalSize += stats.size; // âœ… ä½¿ç”¨ stats.size
        }
        
        // è®¡ç®—ç›®å½•æ ‘æ·±åº¦
        tree.metadata.treeDepth = this._calculateTreeDepth(Object.keys(tree.directories));
    }

    _calculateDirectoryHash(children, fileMap, directories) {
        const childHashes = children.map(child => {
            if (fileMap[child]) {
                // æ˜¯æ–‡ä»¶ï¼Œè¿”å›æ–‡ä»¶å“ˆå¸Œ
                return fileMap[child].hash;
            } else {
                // æ˜¯å­ç›®å½•ï¼Œè¿”å›å­ç›®å½•çš„å“ˆå¸Œå€¼
                const subDirInfo = directories[child];
                if (subDirInfo && subDirInfo.hash) {
                    return subDirInfo.hash;
                } else {
                    // å¦‚æœå­ç›®å½•ä¿¡æ¯ä¸å­˜åœ¨ï¼Œä½¿ç”¨ç›®å½•åä½œä¸ºå…œåº•
                    console.warn(`Warning: Directory hash not found for ${child}, using directory name as fallback`);
                    return child;
                }
            }
        }).sort();
        
        return crypto.createHash('sha256')
            .update(childHashes.join(''))
            .digest('hex');
    }

    _calculateTreeDepth(directories) {
        return Math.max(...directories.map(dir => PathUtils.getPathDepth(dir)), 0);
    }

    _calculateRootHash(fileHashes) {
        if (!fileHashes || Object.keys(fileHashes).length === 0) {
            return crypto.createHash('sha256').update('').digest('hex');
        }
        
        const sortedHashes = Object.keys(fileHashes)
            .sort()
            .map(key => fileHashes[key])
            .join('');
        return crypto.createHash('sha256').update(sortedHashes).digest('hex');
    }

    // è®¡ç®—å®é™…æ‰«ææ·±åº¦
    _calculateScanDepth(directories) {
        if (!directories || Object.keys(directories).length === 0) {
            return 0;
        }
        
        let maxDepth = 0;
        for (const dirPath of Object.keys(directories)) {
            const depth = dirPath.split(path.sep).length;
            maxDepth = Math.max(maxDepth, depth);
        }
        return maxDepth;
    }

    static findChangedFiles(oldTree, newTree) {
        const changedFiles = [];
        
        // æ£€æŸ¥æ–°å¢å’Œä¿®æ”¹çš„æ–‡ä»¶
        for (const [path, fileInfo] of Object.entries(newTree.files)) {
            const oldFileInfo = oldTree.files[path];
            
            if (!oldFileInfo) {
                changedFiles.push({
                    path,
                    type: 'added',
                    newHash: fileInfo.hash
                });
            } else if (oldFileInfo.hash !== fileInfo.hash) {
                changedFiles.push({
                    path,
                    type: 'modified',
                    oldHash: oldFileInfo.hash,
                    newHash: fileInfo.hash
                });
            }
        }
        
        // æ£€æŸ¥åˆ é™¤çš„æ–‡ä»¶
        for (const [path, fileInfo] of Object.entries(oldTree.files)) {
            if (!newTree.files[path]) {
                changedFiles.push({
                    path,
                    type: 'deleted',
                    oldHash: fileInfo.hash
                });
            }
        }
        
        return changedFiles;
    }
}

module.exports = FileScanner; 

/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(__webpack_require__(127));
const assert_valid_pattern_js_1 = __webpack_require__(129);
const ast_js_1 = __webpack_require__(130);
const escape_js_1 = __webpack_require__(133);
const unescape_js_1 = __webpack_require__(132);
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === exports.GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = __webpack_require__(130);
Object.defineProperty(exports, "AST", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));
var escape_js_2 = __webpack_require__(133);
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));
var unescape_js_2 = __webpack_require__(132);
Object.defineProperty(exports, "unescape", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;
//# sourceMappingURL=index.js.map

/***/ }),
/* 127 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var balanced = __webpack_require__(128);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  if (/\$$/.test(m.pre)) {    
    for (var k = 0; k < post.length; k++) {
      var expansion = pre+ '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length)
      var incr = n.length == 3
        ? Math.abs(numeric(n[2]))
        : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];

      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }

  return expansions;
}



/***/ }),
/* 128 */
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertValidPattern = void 0;
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};
exports.assertValidPattern = assertValidPattern;
//# sourceMappingURL=assert-valid-pattern.js.map

/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// parse a single path portion
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AST = void 0;
const brace_expressions_js_1 = __webpack_require__(131);
const unescape_js_1 = __webpack_require__(132);
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                (0, unescape_js_1.unescape)(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            (0, unescape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
}
exports.AST = AST;
//# sourceMappingURL=ast.js.map

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// translate the various posix character classes into unicode properties
// this works across all unicode locales
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseClass = void 0;
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};
exports.parseClass = parseClass;
//# sourceMappingURL=brace-expressions.js.map

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unescape = void 0;
/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};
exports.unescape = unescape;
//# sourceMappingURL=unescape.js.map

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escape = void 0;
/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};
exports.escape = escape;
//# sourceMappingURL=escape.js.map

/***/ }),
/* 134 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);

/**
 * è·¨å¹³å°è·¯å¾„å¤„ç†å·¥å…·ç±»
 * ç»Ÿä¸€ä½¿ç”¨æ­£æ–œæ ä½œä¸ºå†…éƒ¨è·¯å¾„æ ¼å¼ï¼Œé¿å…Windowså’ŒUnixç³»ç»Ÿçš„è·¯å¾„åˆ†éš”ç¬¦å·®å¼‚
 */
class PathUtils {
    /**
     * æ ‡å‡†åŒ–è·¯å¾„æ ¼å¼ï¼Œç»Ÿä¸€ä½¿ç”¨æ­£æ–œæ 
     * @param {string} pathStr - åŸå§‹è·¯å¾„å­—ç¬¦ä¸²
     * @returns {string} æ ‡å‡†åŒ–åçš„è·¯å¾„
     */
    static normalizePath(pathStr) {
        if (!pathStr) return '';
        return path.normalize(pathStr).replace(/\\/g, '/');
    }

    /**
     * æ ‡å‡†åŒ–ç›®å½•è·¯å¾„ï¼Œç¡®ä¿ä»¥æ­£æ–œæ ç»“å°¾
     * @param {string} dirPath - ç›®å½•è·¯å¾„
     * @returns {string} æ ‡å‡†åŒ–çš„ç›®å½•è·¯å¾„ï¼Œä»¥ '/' ç»“å°¾
     */
    static normalizeDirPath(dirPath) {
        if (!dirPath) return '';
        const normalized = this.normalizePath(dirPath);
        return normalized.endsWith('/') ? normalized : normalized + '/';
    }

    /**
     * è·å–æ–‡ä»¶çš„çˆ¶ç›®å½•è·¯å¾„ï¼Œæ ‡å‡†åŒ–æ ¼å¼
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     * @returns {string} çˆ¶ç›®å½•è·¯å¾„ï¼Œä»¥ '/' ç»“å°¾
     */
    static getParentDir(filePath) {
        if (!filePath) return '';
        return this.normalizeDirPath(path.dirname(filePath));
    }

    /**
     * æ£€æŸ¥æ˜¯å¦ä¸ºæ ¹ç›®å½•
     * @param {string} dirPath - ç›®å½•è·¯å¾„
     * @returns {boolean} æ˜¯å¦ä¸ºæ ¹ç›®å½•
     */
    static isRootDir(dirPath) {
        if (!dirPath) return false;
        const normalized = this.normalizePath(dirPath);
        return normalized === '.' || normalized === '';
    }

    /**
     * æ£€æŸ¥æ˜¯å¦ä¸ºå½“å‰ç›®å½•æ ¼å¼
     * @param {string} dirPath - ç›®å½•è·¯å¾„
     * @returns {boolean} æ˜¯å¦ä¸ºå½“å‰ç›®å½•æ ¼å¼ï¼ˆå¦‚ './' æˆ– '.\'ï¼‰
     */
    static isCurrentDir(dirPath) {
        if (!dirPath) return false;
        const normalized = this.normalizePath(dirPath);
        return normalized === './' || normalized === '.';
    }

    /**
     * è®¡ç®—è·¯å¾„æ·±åº¦ï¼ˆç›®å½•å±‚çº§æ•°ï¼‰
     * @param {string} pathStr - è·¯å¾„å­—ç¬¦ä¸²
     * @returns {number} è·¯å¾„æ·±åº¦
     */
    static getPathDepth(pathStr) {
        if (!pathStr) return 0;
        const normalized = this.normalizePath(pathStr);
        if (this.isRootDir(normalized)) return 0;
        return normalized.split('/').filter(part => part !== '' && part !== '.').length;
    }

    /**
     * è·å–è·¯å¾„çš„çˆ¶ç›®å½•ï¼ˆä¸åŒ…å«æœ«å°¾åˆ†éš”ç¬¦ï¼‰
     * @param {string} dirPath - ç›®å½•è·¯å¾„ï¼ˆä»¥ '/' ç»“å°¾ï¼‰
     * @returns {string} çˆ¶ç›®å½•è·¯å¾„
     */
    static getParentOfDir(dirPath) {
        if (!dirPath || this.isCurrentDir(dirPath)) return '';
        
        // ç§»é™¤æœ«å°¾çš„æ–œæ 
        const cleanPath = dirPath.replace(/\/$/, '');
        if (!cleanPath || cleanPath === '.') return '';
        
        const parentPath = this.normalizePath(path.dirname(cleanPath));
        return this.normalizeDirPath(parentPath);
    }

    /**
     * æ£€æŸ¥è·¯å¾„æ˜¯å¦ç›¸ç­‰ï¼ˆå¿½ç•¥å¹³å°å·®å¼‚ï¼‰
     * @param {string} path1 - è·¯å¾„1
     * @param {string} path2 - è·¯å¾„2
     * @returns {boolean} è·¯å¾„æ˜¯å¦ç›¸ç­‰
     */
    static pathEquals(path1, path2) {
        return this.normalizePath(path1) === this.normalizePath(path2);
    }
}

module.exports = PathUtils;

/***/ }),
/* 135 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

/**
 * æ–‡ä»¶ç±»å‹æ£€æµ‹å·¥å…·ç±»
 * ç”¨äºæ£€æµ‹äºŒè¿›åˆ¶æ–‡ä»¶å’Œæ–‡æœ¬æ–‡ä»¶ç¼–ç 
 */
class FileTypeDetector {
    constructor() {
        // å¸¸è§äºŒè¿›åˆ¶æ–‡ä»¶æ‰©å±•å
        this.binaryExtensions = new Set([
            '.exe', '.dll', '.so', '.dylib', '.app',  // å¯æ‰§è¡Œæ–‡ä»¶
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg', '.webp',  // å›¾ç‰‡
            '.mp3', '.wav', '.mp4', '.avi', '.mov', '.mkv', '.flv',  // éŸ³è§†é¢‘
            '.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz',  // å‹ç¼©æ–‡ä»¶
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',  // åŠå…¬æ–‡æ¡£
            '.bin', '.dat', '.db', '.sqlite', '.mdb',  // æ•°æ®åº“/äºŒè¿›åˆ¶æ•°æ®
            '.ttf', '.otf', '.woff', '.woff2',  // å­—ä½“æ–‡ä»¶
            '.class', '.jar', '.pyc', '.o', '.obj',  // ç¼–è¯‘æ–‡ä»¶
        ]);

        // å¸¸è§æ–‡æœ¬æ–‡ä»¶æ‰©å±•å
        this.textExtensions = new Set([
            '.txt', '.md', '.json', '.xml', '.html', '.htm', '.css', '.js', '.ts',
            '.py', '.java', '.c', '.cpp', '.h', '.hpp', '.cs', '.php', '.rb',
            '.go', '.rs', '.swift', '.kt', '.scala', '.sh', '.bat', '.ps1',
            '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.log',
            '.sql', '.r', '.m', '.pl', '.lua', '.vim', '.dockerfile'
        ]);

        // å¸¸è§æ–‡ä»¶é­”æ•°ï¼ˆå‰å‡ ä¸ªå­—èŠ‚çš„ç‰¹å¾ï¼‰
        this.binarySignatures = [
            [0x89, 0x50, 0x4E, 0x47],  // PNG
            [0xFF, 0xD8, 0xFF],         // JPEG
            [0x47, 0x49, 0x46, 0x38],  // GIF
            [0x25, 0x50, 0x44, 0x46],  // PDF
            [0x50, 0x4B, 0x03, 0x04],  // ZIP
            [0x50, 0x4B, 0x05, 0x06],  // ZIP (empty)
            [0x50, 0x4B, 0x07, 0x08],  // ZIP (spanned)
            [0x52, 0x61, 0x72, 0x21],  // RAR
            [0x7F, 0x45, 0x4C, 0x46],  // ELF (Linuxæ‰§è¡Œæ–‡ä»¶)
            [0x4D, 0x5A],               // Windows PEæ‰§è¡Œæ–‡ä»¶
            [0xCA, 0xFE, 0xBA, 0xBE],  // Java classæ–‡ä»¶
        ];
    }

    /**
     * æ£€æµ‹æ–‡ä»¶æ˜¯å¦ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶
     * @param {Buffer} buffer æ–‡ä»¶å†…å®¹ç¼“å†²åŒº
     * @param {string} filePath æ–‡ä»¶è·¯å¾„ï¼ˆç”¨äºæ‰©å±•åæ£€æµ‹ï¼‰
     * @returns {boolean} æ˜¯å¦ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶
     */
    isBinaryFile(buffer, filePath = '') {
        // 1. æ ¹æ®æ‰©å±•åå¿«é€Ÿåˆ¤æ–­
        const ext = this._getFileExtension(filePath).toLowerCase();
        if (this.binaryExtensions.has(ext)) {
            return true;
        }
        if (this.textExtensions.has(ext)) {
            return false;
        }

        // 2. æ£€æŸ¥æ–‡ä»¶é­”æ•°
        if (this._hasBinarySignature(buffer)) {
            return true;
        }

        // 3. æ£€æŸ¥æ˜¯å¦åŒ…å«ç©ºå­—èŠ‚ï¼ˆnullå­—ç¬¦ï¼‰
        // å¤§å¤šæ•°äºŒè¿›åˆ¶æ–‡ä»¶åŒ…å«ç©ºå­—èŠ‚ï¼Œè€Œæ–‡æœ¬æ–‡ä»¶å¾ˆå°‘æœ‰
        const sampleSize = Math.min(8192, buffer.length);  // æ£€æŸ¥å‰8KB
        const sample = buffer.slice(0, sampleSize);
        
        // æ£€æŸ¥ç©ºå­—èŠ‚
        if (sample.includes(0)) {
            return true;
        }

        // 4. æ£€æŸ¥ä¸å¯æ‰“å°å­—ç¬¦çš„æ¯”ä¾‹
        let nonPrintableCount = 0;
        for (let i = 0; i < sampleSize; i++) {
            const byte = sample[i];
            // ä¸å¯æ‰“å°çš„ASCIIå­—ç¬¦ï¼ˆé™¤äº†å¸¸è§çš„ç©ºç™½å­—ç¬¦ï¼‰
            if (byte < 9 || (byte > 13 && byte < 32) || byte === 127) {
                nonPrintableCount++;
            }
        }

        // å¦‚æœä¸å¯æ‰“å°å­—ç¬¦è¶…è¿‡30%ï¼Œè®¤ä¸ºæ˜¯äºŒè¿›åˆ¶æ–‡ä»¶
        const nonPrintableRatio = nonPrintableCount / sampleSize;
        if (nonPrintableRatio > 0.3) {
            return true;
        }

        // 5. æ£€æŸ¥UTF-8ç¼–ç çš„æœ‰æ•ˆæ€§
        try {
            buffer.toString('utf8');
            // å¦‚æœèƒ½æˆåŠŸè½¬æ¢ä¸ºUTF-8ä¸”æ²¡æœ‰å¤ªå¤šä¸å¯æ‰“å°å­—ç¬¦ï¼Œè®¤ä¸ºæ˜¯æ–‡æœ¬æ–‡ä»¶
            return false;
        } catch (error) {
            // å¦‚æœä¸èƒ½è½¬æ¢ä¸ºæœ‰æ•ˆçš„UTF-8ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶
            return true;
        }
    }

    /**
     * æ£€æµ‹æ–‡æœ¬æ–‡ä»¶çš„ç¼–ç 
     * @param {Buffer} buffer æ–‡ä»¶å†…å®¹ç¼“å†²åŒº
     * @returns {string|null} æ£€æµ‹åˆ°çš„ç¼–ç ï¼Œå¦‚æœæ£€æµ‹å¤±è´¥è¿”å›null
     */
    detectEncoding(buffer) {
        // æ£€æŸ¥BOMï¼ˆå­—èŠ‚é¡ºåºæ ‡è®°ï¼‰
        if (buffer.length >= 3) {
            // UTF-8 BOM
            if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                return 'utf8';
            }
        }
        
        if (buffer.length >= 2) {
            // UTF-16 LE BOM
            if (buffer[0] === 0xFF && buffer[1] === 0xFE) {
                return 'utf16le';
            }
            // UTF-16 BE BOM
            if (buffer[0] === 0xFE && buffer[1] === 0xFF) {
                return 'utf16be';
            }
        }

        // å°è¯•UTF-8æ£€æµ‹
        if (this._isValidUTF8(buffer)) {
            return 'utf8';
        }

        // ç®€å•çš„ASCIIæ£€æµ‹
        if (this._isAscii(buffer)) {
            return 'ascii';
        }

        // å¦‚æœæ— æ³•ç¡®å®šï¼Œè¿”å›nullè®©è°ƒç”¨è€…å†³å®š
        return null;
    }

    /**
     * è¯»å–æ–‡ä»¶å†…å®¹å¹¶è¿”å›è¯¦ç»†ä¿¡æ¯
     * @param {Buffer} buffer æ–‡ä»¶å†…å®¹ç¼“å†²åŒº
     * @param {string} filePath æ–‡ä»¶è·¯å¾„
     * @returns {Object} æ–‡ä»¶ä¿¡æ¯å¯¹è±¡
     */
    analyzeFile(buffer, filePath = '') {
        const isBinary = this.isBinaryFile(buffer, filePath);
        
        if (isBinary) {
            return {
                content: null,
                hash: crypto.createHash('sha256').update(buffer).digest('hex'),
                isBinary: true,
                encoding: null,
                size: buffer.length
            };
        } else {
            const encoding = this.detectEncoding(buffer) || 'utf8';
            let content;
            
            try {
                content = buffer.toString(encoding);
            } catch (error) {
                // å¦‚æœç¼–ç è½¬æ¢å¤±è´¥ï¼Œé€€å›åˆ°utf8
                try {
                    content = buffer.toString('utf8');
                } catch (utf8Error) {
                    // å¦‚æœè¿utf8éƒ½å¤±è´¥ï¼Œå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶è¢«è¯¯åˆ¤
                    return {
                        content: null,
                        hash: crypto.createHash('sha256').update(buffer).digest('hex'),
                        isBinary: true,
                        encoding: null,
                        size: buffer.length,
                        error: 'Encoding conversion failed'
                    };
                }
            }
            
            return {
                content: content,
                hash: crypto.createHash('sha256').update(buffer).digest('hex'),
                isBinary: false,
                encoding: encoding,
                size: buffer.length
            };
        }
    }

    /**
     * è·å–æ–‡ä»¶æ‰©å±•å
     * @private
     */
    _getFileExtension(filePath) {
        const lastDot = filePath.lastIndexOf('.');
        return lastDot === -1 ? '' : filePath.substring(lastDot);
    }

    /**
     * æ£€æŸ¥æ˜¯å¦æœ‰äºŒè¿›åˆ¶æ–‡ä»¶é­”æ•°
     * @private
     */
    _hasBinarySignature(buffer) {
        if (buffer.length < 4) return false;
        
        for (const signature of this.binarySignatures) {
            if (this._matchesSignature(buffer, signature)) {
                return true;
            }
        }
        return false;
    }

    /**
     * æ£€æŸ¥ç¼“å†²åŒºæ˜¯å¦åŒ¹é…ç‰¹å®šçš„é­”æ•°
     * @private
     */
    _matchesSignature(buffer, signature) {
        if (buffer.length < signature.length) return false;
        
        for (let i = 0; i < signature.length; i++) {
            if (buffer[i] !== signature[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8ç¼–ç 
     * @private
     */
    _isValidUTF8(buffer) {
        try {
            const str = buffer.toString('utf8');
            // æ£€æŸ¥è½¬æ¢åçš„å­—ç¬¦ä¸²æ˜¯å¦åŒ…å«Unicodeæ›¿æ¢å­—ç¬¦
            // è¿™é€šå¸¸è¡¨æ˜åŸå§‹æ•°æ®ä¸æ˜¯æœ‰æ•ˆçš„UTF-8
            return !str.includes('\uFFFD');
        } catch (error) {
            return false;
        }
    }

    /**
     * æ£€æŸ¥æ˜¯å¦ä¸ºçº¯ASCIIç¼–ç 
     * @private
     */
    _isAscii(buffer) {
        for (let i = 0; i < buffer.length; i++) {
            if (buffer[i] > 127) {
                return false;
            }
        }
        return true;
    }
}

module.exports = FileTypeDetector;

/***/ }),
/* 136 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);

/**
 * æ™ºèƒ½æ–‡ä»¶ç­›é€‰å™¨
 * ä¸“é—¨è¯†åˆ«å’Œå¤„ç†æœ‰ä»·å€¼çš„æºä»£ç æ–‡ä»¶
 * å½»åº•æ’é™¤ç¬¬ä¸‰æ–¹ä¾èµ–ã€æ„å»ºäº§ç‰©ç­‰æ— å…³æ–‡ä»¶
 */
class IntelligentFileFilter {
    constructor() {
        // ğŸ¯ æœ‰ä»·å€¼çš„æºä»£ç æ–‡ä»¶æ‰©å±•å
        this.valuableExtensions = new Set([
            // Webå‰ç«¯
            '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
            '.css', '.scss', '.sass', '.less', '.styl',
            '.html', '.htm',
            
            // åç«¯è¯­è¨€
            '.py', '.rb', '.php', '.java', '.c', '.cpp', '.cc', '.cxx',
            '.cs', '.go', '.rs', '.kt', '.scala', '.clj', '.cljs',
            '.sh', '.bash', '.zsh', '.ps1',
            
            // ç§»åŠ¨å¼€å‘
            '.swift', '.m', '.mm', '.dart',
            
            // æ•°æ®å’Œé…ç½®ï¼ˆé€‰æ‹©æ€§ï¼‰
            '.sql', '.graphql', '.yaml', '.yml',
            
            // è„šæœ¬å’Œè‡ªåŠ¨åŒ–
            '.lua', '.pl', '.r'
        ]);

        // ğŸš« åº”è¯¥å¤„ç†ä½†éœ€è¦ç‰¹åˆ«æ³¨æ„çš„æ–‡ä»¶ï¼ˆé€šå¸¸æ˜¯ç”¨æˆ·é…ç½®ï¼‰
        this.conditionalExtensions = new Set([
            '.json', '.xml', '.toml', '.ini', '.conf'
        ]);

        // ğŸ¯ æœ‰ä»·å€¼çš„æ–‡ä»¶åæ¨¡å¼ï¼ˆå³ä½¿æ‰©å±•åä¸åœ¨åˆ—è¡¨ä¸­ï¼‰
        this.valuableFilePatterns = [
            /^Dockerfile$/i,
            /^Makefile$/i,
            /^CMakeLists\.txt$/i,
            /^\.env\.example$/i,
            /^\.gitignore$/i,
            /^\.eslintrc$/i,
            /^\.prettierrc$/i,
            /^webpack\.config\./i,
            /^rollup\.config\./i,
            /^vite\.config\./i
        ];

        // ğŸš« æ˜ç¡®æ’é™¤çš„ç›®å½•ï¼ˆæ€§èƒ½ä¼˜åŒ–ï¼‰
        this.excludedDirectories = new Set([
            'node_modules', 'bower_components', 'vendor', 'packages',
            '.git', '.svn', '.hg', 'CVS',
            'dist', 'build', 'out', 'output', 'public', 'bin', 'obj',
            'coverage', '.nyc_output', 'htmlcov',
            '__pycache__', '.pytest_cache', '.tox', 'venv', 'env', '.env',
            '.cache', '.vector-cache', 'tmp', 'temp', '.tmp',
            '.vscode', '.idea', '.vs'
        ]);

        // ğŸš« æ˜ç¡®æ’é™¤çš„æ–‡ä»¶å
        this.excludedFileNames = new Set([
            '.ds_store', 'thumbs.db', 'desktop.ini',
            'license', 'license.txt', 'license.md',
            'changelog', 'changelog.txt', 'changelog.md',
            'readme', 'readme.txt', 'readme.md',
            'contributing', 'contributing.md',
            'code_of_conduct.md', 'security.md',
            'authors', 'contributors', 'maintainers'
        ]);
    }

    /**
     * ğŸ¯ åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å€¼å¾—å¤„ç†
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     * @returns {boolean} æ˜¯å¦åº”è¯¥å¤„ç†è¯¥æ–‡ä»¶
     */
    isValuableFile(filePath) {
        const fileName = path.basename(filePath).toLowerCase();
        const ext = path.extname(filePath).toLowerCase();
        const nameWithoutExt = path.basename(filePath, ext).toLowerCase();

        // 1. æ£€æŸ¥æ˜¯å¦åœ¨æ’é™¤çš„æ–‡ä»¶ååˆ—è¡¨ä¸­
        if (this.excludedFileNames.has(fileName) || 
            this.excludedFileNames.has(nameWithoutExt)) {
            return false;
        }

        // 2. æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰ä»·å€¼çš„æ–‡ä»¶æ¨¡å¼
        for (const pattern of this.valuableFilePatterns) {
            if (pattern.test(path.basename(filePath))) {
                return true;
            }
        }

        // 3. æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
        if (this.valuableExtensions.has(ext)) {
            return true;
        }

        // 4. æœ‰æ¡ä»¶çš„æ‰©å±•åéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥
        if (this.conditionalExtensions.has(ext)) {
            return this._isValuableConfigFile(filePath);
        }

        // 5. é»˜è®¤ä¸å¤„ç†
        return false;
    }

    /**
     * ğŸ¯ æ£€æŸ¥è·¯å¾„æ˜¯å¦åŒ…å«åº”è¯¥æ’é™¤çš„ç›®å½•
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     * @returns {boolean} æ˜¯å¦åº”è¯¥æ’é™¤
     */
    containsExcludedDirectory(filePath) {
        const pathSegments = filePath.split(path.sep);
        return pathSegments.some(segment => this.excludedDirectories.has(segment));
    }

    /**
     * ğŸ¯ åˆ¤æ–­é…ç½®æ–‡ä»¶æ˜¯å¦æœ‰ä»·å€¼
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     * @returns {boolean} æ˜¯å¦æœ‰ä»·å€¼
     */
    _isValuableConfigFile(filePath) {
        const fileName = path.basename(filePath).toLowerCase();
        
        // é¡¹ç›®çº§é…ç½®æ–‡ä»¶é€šå¸¸æœ‰ä»·å€¼
        const valuableConfigPatterns = [
            /^package\.json$/,
            /^composer\.json$/,
            /^requirements\.txt$/,
            /^pipfile$/,
            /^cargo\.toml$/,
            /^go\.mod$/,
            /^pom\.xml$/,
            /^build\.gradle$/,
            /^project\.clj$/,
            /^mix\.exs$/,
            /^.*\.config\.(js|ts|json)$/,
            /^.*rc\.(js|ts|json|yaml|yml)$/,
            /^tsconfig\.json$/,
            /^jsconfig\.json$/
        ];

        return valuableConfigPatterns.some(pattern => pattern.test(fileName));
    }

    /**
     * ğŸ¯ è·å–æ–‡ä»¶ä»·å€¼è¯„åˆ†
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     * @returns {number} ä»·å€¼è¯„åˆ† (0-100)
     */
    getFileValueScore(filePath) {
        if (this.containsExcludedDirectory(filePath)) {
            return 0;
        }

        if (!this.isValuableFile(filePath)) {
            return 0;
        }

        const ext = path.extname(filePath).toLowerCase();
        const fileName = path.basename(filePath);

        // æ ¸å¿ƒæºä»£ç æ–‡ä»¶æœ€é«˜åˆ†
        const coreLanguages = ['.js', '.jsx', '.ts', '.tsx', '.py', '.java', '.c', '.cpp', '.cs', '.go', '.rs'];
        if (coreLanguages.includes(ext)) {
            return 100;
        }

        // å‰ç«¯æ–‡ä»¶é«˜åˆ†
        const frontendFiles = ['.vue', '.svelte', '.css', '.scss', '.sass', '.less'];
        if (frontendFiles.includes(ext)) {
            return 90;
        }

        // è„šæœ¬å’Œé…ç½®æ–‡ä»¶ä¸­ç­‰åˆ†
        const scriptFiles = ['.sh', '.bash', '.ps1', '.sql'];
        if (scriptFiles.includes(ext)) {
            return 80;
        }

        // ç‰¹æ®Šæ–‡ä»¶ä¸­ç­‰åˆ†
        for (const pattern of this.valuableFilePatterns) {
            if (pattern.test(fileName)) {
                return 75;
            }
        }

        // é…ç½®æ–‡ä»¶è¾ƒä½åˆ†
        if (this.conditionalExtensions.has(ext)) {
            return 60;
        }

        return 50;
    }

    /**
     * ğŸ¯ ç”Ÿæˆå¤„ç†å»ºè®®
     * @param {string[]} filePaths - æ–‡ä»¶è·¯å¾„åˆ—è¡¨
     * @returns {Object} å¤„ç†å»ºè®®
     */
    generateProcessingSuggestion(filePaths) {
        const analysis = {
            total: filePaths.length,
            valuable: 0,
            excluded: 0,
            byType: {},
            suggestions: []
        };

        for (const filePath of filePaths) {
            const score = this.getFileValueScore(filePath);
            const ext = path.extname(filePath).toLowerCase() || 'no-ext';

            if (score === 0) {
                analysis.excluded++;
            } else {
                analysis.valuable++;
            }

            if (!analysis.byType[ext]) {
                analysis.byType[ext] = { count: 0, avgScore: 0, totalScore: 0 };
            }
            analysis.byType[ext].count++;
            analysis.byType[ext].totalScore += score;
            analysis.byType[ext].avgScore = analysis.byType[ext].totalScore / analysis.byType[ext].count;
        }

        // ç”Ÿæˆå»ºè®®
        const reductionRate = ((analysis.excluded / analysis.total) * 100).toFixed(1);
        analysis.suggestions.push(`å¯ä»¥è·³è¿‡ ${analysis.excluded} ä¸ªæ–‡ä»¶ (${reductionRate}%)ï¼Œä¸“æ³¨å¤„ç† ${analysis.valuable} ä¸ªæœ‰ä»·å€¼çš„æ–‡ä»¶`);

        if (analysis.excluded > analysis.valuable) {
            analysis.suggestions.push('ğŸ¯ å»ºè®®ï¼šå¯ç”¨æ™ºèƒ½æ–‡ä»¶ç­›é€‰å¯ä»¥æ˜¾è‘—æå‡å¤„ç†æ•ˆç‡');
        }

        return analysis;
    }
}

module.exports = IntelligentFileFilter; 

/***/ }),
/* 137 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);
const BaseParser = __webpack_require__(138);
const AstParser = __webpack_require__(139);
const ReadlineParser = __webpack_require__(142);
const FilenameParser = __webpack_require__(143);

class ParserSelector {
    constructor(config) {
        this.config = config;
        this.parsers = new Map();
        this._initializeParsers();
    }

    _initializeParsers() {
        // åˆå§‹åŒ–æ‰€æœ‰å¯ç”¨çš„è§£æå™¨
        this.parsers.set('ast', new AstParser(this.config));
        this.parsers.set('readline', new ReadlineParser(this.config));
        this.parsers.set('filename', new FilenameParser(this.config));
    }

    selectParser(filePath) {
        const extension = path.extname(filePath).toLowerCase();
        const languageMapping = this.config.languageMapping || {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript'
        };

        const language = languageMapping[extension];
        if (!language) {
            return this.parsers.get('readline'); // é»˜è®¤ä½¿ç”¨è¡Œè§£æå™¨
        }

        // æ ¹æ®è¯­è¨€é€‰æ‹©é€‚å½“çš„è§£æå™¨
        if (['python', 'javascript', 'typescript'].includes(language)) {
            return this.parsers.get('ast');
        }

        return this.parsers.get('readline');
    }
}

module.exports = ParserSelector; 

/***/ }),
/* 138 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

class BaseParser {
    constructor(config, workspacePath = null) {
        this.config = config || {};
        this.workspacePath = workspacePath;
        this.linesPerChunk = this.config.linesPerChunk || 15;
        this.maxChunkSize = 9 * 1024;
    }

    async parse(filePath) {
        // æŠ½è±¡æ–¹æ³•ï¼Œå­ç±»éœ€è¦å®ç°
        throw new Error('parse method must be implemented by subclass');
    }

    generateChunkId(filePath, startLine, endLine) {
        const identifier = `${filePath}:${startLine}:${endLine}`;
        return crypto.createHash('sha256').update(identifier).digest('hex');
    }

    _createChunk(content, startLine, endLine, filePath = 'unknown', language = 'unknown', type = 'default') {
        return {
            chunkId: this.generateChunkId(filePath, startLine, endLine),    
            filePath: filePath,
            language: language,
            startLine: startLine,
            endLine: endLine,
            content: content,
            parser: this.constructor.name.toLowerCase().replace('parser', '') + '_parser',
            type: type
        };
    }

    _splitIntoChunks(content, filePath = 'unknown', language = 'unknown') {
        const lines = content.split('\n');
        const chunks = [];
        
        let currentLines = [];
        let currentStartLine = 1;
        
        // è°ƒè¯•ä¿¡æ¯ï¼šè®°å½•æ–‡ä»¶çš„åŸºæœ¬ä¿¡æ¯

        
        // æ£€æŸ¥æ˜¯å¦æœ‰ç©ºè¡Œåœ¨æ–‡ä»¶æœ«å°¾
        const lastLine = lines[lines.length - 1];
        if (lastLine === '' || lastLine.trim() === '') {

        }
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // è·³è¿‡ç©ºè¡Œï¼Œé¿å…åˆ›å»ºç©ºå†…å®¹ä»£ç å—
            if (line.trim() === '' && currentLines.length === 0) {

                currentStartLine = i + 2; // æ›´æ–°èµ·å§‹è¡Œå·
                continue;
            }
            
            currentLines.push(line);
            
            const shouldEnd = currentLines.length >= this.linesPerChunk ||
                             Buffer.byteLength(currentLines.join('\n'), 'utf8') >= this.maxChunkSize;
            
            if (shouldEnd || i === lines.length - 1) {
                const chunkContent = currentLines.join('\n');
                const contentSize = Buffer.byteLength(chunkContent, 'utf8');
                
                if (contentSize > this.maxChunkSize && currentLines.length > 1) {
                    const midPoint = Math.floor(currentLines.length / 2);
                    const firstHalf = currentLines.slice(0, midPoint);
                    const secondHalf = currentLines.slice(midPoint);
                    
                    chunks.push(this._createChunk(
                        firstHalf.join('\n'),
                        currentStartLine,
                        currentStartLine + firstHalf.length - 1,
                        filePath,
                        language,
                        'default'   
                    ));
                    
                    currentLines = secondHalf;
                    currentStartLine = currentStartLine + firstHalf.length;
                    i--;
                } else {
                    // æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸ºç©ºï¼Œé¿å…åˆ›å»ºç©ºå†…å®¹ä»£ç å—
                    if (!chunkContent || chunkContent.trim() === '') {
        
                        console.log(`   å†…å®¹: "${chunkContent}"`);
                        console.log(`   è¡Œæ•°ç»„: ${JSON.stringify(currentLines)}`);
                        
                        // è·³è¿‡è¿™ä¸ªç©ºä»£ç å—ï¼Œä½†ç»§ç»­å¤„ç†
                        currentStartLine = currentStartLine + currentLines.length;
                        currentLines = [];
                        continue;
                    }
                    
                    const chunk = this._createChunk(
                        chunkContent,
                        currentStartLine,
                        currentStartLine + currentLines.length - 1,
                        filePath,
                        language,
                        'default'
                    );
                    
                    chunks.push(chunk);
                    
                    // ä¿®å¤Bug: æ­£ç¡®è®¡ç®—ä¸‹ä¸€ä¸ªä»£ç å—çš„èµ·å§‹è¡Œå·
                    currentStartLine = currentStartLine + currentLines.length;
                    currentLines = [];
                }
            }
        }
        

        
        return chunks;
    }
}

module.exports = BaseParser; 

/***/ }),
/* 139 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Parser = __webpack_require__(140);
const Python = __webpack_require__(141);
const BaseParser = __webpack_require__(138);
const crypto = __webpack_require__(8);
const path = __webpack_require__(4);

class AstParser extends BaseParser {
    constructor(config) {
        super(config);
        // é™æ€è¯­è¨€è§£æå™¨æ± 
        this.languageParserPool = {};
        this.languageDict = {
            python: PythonParser
        };
        // 10KBé™åˆ¶ï¼ˆç•™1KBä½™é‡ï¼‰
        this.maxChunkSize = 9 * 1024;
        this._initializeParsers();
    }

    _initializeParsers() {
        try {
            // é¢„åˆå§‹åŒ–æ”¯æŒçš„è¯­è¨€è§£æå™¨
            for (const [lang, parserClass] of Object.entries(this.languageDict)) {
                if (!this.languageParserPool[lang]) {
                    this.languageParserPool[lang] = new parserClass(this.config);
                }
            }
        } catch (error) {
            console.warn('Warning: tree-sitter initialization failed. AST parsing may not be available:', error);
        }
    }

    getParserForLanguage(language) {
        // æ£€æŸ¥è¯­è¨€æ˜¯å¦æ”¯æŒ
        if (!this.languageDict[language]) {
            throw new Error(`Unsupported language: ${language}`);
        }

        // æ£€æŸ¥æ± ä¸­æ˜¯å¦æœ‰è¯¥è¯­è¨€çš„è§£æå™¨
        if (!this.languageParserPool[language]) {
            const parserClass = this.languageDict[language];
            this.languageParserPool[language] = new parserClass(this.config);
        }

        return this.languageParserPool[language];
    }

    async parse(filePath, content = null, language = null) {
        // å¦‚æœæ²¡æœ‰æä¾›å†…å®¹ï¼Œè¯»å–æ–‡ä»¶
        if (!content) {
            const fs = (__webpack_require__(5).promises);
            content = await fs.readFile(filePath, 'utf-8');
        }

        if (!language) {
            // å°è¯•ä»æ–‡ä»¶æ‰©å±•åç¡®å®šè¯­è¨€
            const ext = path.extname(filePath);
            const langMapping = this.config.languageMapping || {
                '.py': 'python',
                '.js': 'javascript',
                '.ts': 'typescript'
            };
            language = langMapping[ext] || 'unknown';
        }

        try {
            if (!this.languageDict[language]) {
                // å¦‚æœè¯­è¨€ä¸æ”¯æŒï¼Œä½¿ç”¨çˆ¶ç±»çš„æ™ºèƒ½åˆ†å‰²æ–¹æ³•
                return this._splitIntoChunks(content, filePath, language);
            }

            // è·å–é€‚å½“çš„è¯­è¨€è§£æå™¨
            const langParser = this.getParserForLanguage(language);
            
            // ä½¿ç”¨è¯­è¨€ç‰¹å®šçš„è§£æå™¨è§£æå†…å®¹
            const chunks = await langParser.parseContent(content, filePath);
            
            // æ£€æŸ¥å¹¶åˆ†å‰²è¿‡å¤§çš„å—
            return this._ensureChunkSizeLimit(chunks);

        } catch (error) {
            console.error(`Error parsing file ${filePath}:`, error);
            return [];
        }
    }

    // ç¡®ä¿æ‰€æœ‰å—éƒ½åœ¨å¤§å°é™åˆ¶å†…
    _ensureChunkSizeLimit(chunks) {
        const result = [];
        
        for (const chunk of chunks) {
            const chunkSize = Buffer.byteLength(chunk.content, 'utf8');
            
            if (chunkSize <= this.maxChunkSize) {
                result.push(chunk);
            } else {
                // åˆ†å‰²è¿‡å¤§çš„å—
                const splitChunks = this._splitLargeChunk(chunk);
                result.push(...splitChunks);
            }
        }
        
        return result;
    }

    // åˆ†å‰²è¿‡å¤§çš„ä»£ç å—
    _splitLargeChunk(chunk) {
        const lines = chunk.content.split('\n');
        const chunks = [];
        let currentLines = [];
        let currentStartLine = chunk.startLine;
        
        for (let i = 0; i < lines.length; i++) {
            currentLines.push(lines[i]);
            const currentContent = currentLines.join('\n');
            const currentSize = Buffer.byteLength(currentContent, 'utf8');
            
            // å¦‚æœè¾¾åˆ°å¤§å°é™åˆ¶æˆ–æ˜¯æœ€åä¸€è¡Œ
            if (currentSize >= this.maxChunkSize || i === lines.length - 1) {
                if (currentSize > this.maxChunkSize && currentLines.length > 1) {
                    // ç§»é™¤æœ€åä¸€è¡Œï¼Œä¿å­˜å½“å‰å—
                    currentLines.pop();
                    const finalContent = currentLines.join('\n');
                    
                    chunks.push({
                        ...chunk,
                        content: finalContent,
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        chunkId: this.generateChunkId(chunk.filePath, currentStartLine, currentStartLine + currentLines.length - 1)
                    });
                    
                    // ä»å½“å‰è¡Œé‡æ–°å¼€å§‹ - ä¿®å¤Bug: åº”è¯¥åŸºäºå¤„ç†çš„è¡Œæ•°æ›´æ–°èµ·å§‹è¡Œå·
                    const processedLines = currentLines.length;
                    currentLines = [lines[i]];
                    currentStartLine = currentStartLine + processedLines;
                } else {
                    // ä¿å­˜å½“å‰å—
                    chunks.push({
                        ...chunk,
                        content: currentContent,
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        chunkId: this.generateChunkId(chunk.filePath, currentStartLine, currentStartLine + currentLines.length - 1)
                    });
                    
                    // é‡ç½® - ä¿®å¤Bug: åœ¨é‡ç½®currentLinesä¹‹å‰å…ˆä¿å­˜é•¿åº¦
                    const processedLines = currentLines.length;
                    currentLines = [];
                    currentStartLine = currentStartLine + processedLines;
                }
            }
        }
        
        return chunks;
    }

    generateChunkId(filePath, startLine, endLine) {
        const identifier = `${filePath}:${startLine}:${endLine}`;
        return crypto.createHash('sha256').update(identifier).digest('hex');
    }
}

class PythonParser extends BaseParser {
    constructor(config) {
        super(config);
        // èŠ‚ç‚¹ç±»å‹åˆ†ç±»
        this.nodeTypes = {
            import: ['import_statement', 'import_from_statement'],
            class: ['class_definition'],
            function: ['function_definition'],
            variable: ['expression_statement', 'assignment']
        };
        
        // åˆå§‹åŒ–tree-sitter Pythonè§£æå™¨
        this.parser = new Parser();
        this.parser.setLanguage(Python);
        
        // 10KBé™åˆ¶ï¼ˆç•™1KBä½™é‡ï¼‰
        this.maxChunkSize = 9 * 1024;
    }

    // ä¿®å¤å¤šå­—èŠ‚å­—ç¬¦å¤„ç†é—®é¢˜çš„è¾…åŠ©æ–¹æ³•
    _extractNodeCode(code, startByte, endByte) {
        // å°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºBufferï¼Œä½¿ç”¨å­—èŠ‚ç´¢å¼•è¿›è¡Œåˆ‡ç‰‡ï¼Œç„¶åè½¬æ¢å›å­—ç¬¦ä¸²
        const buffer = Buffer.from(code, 'utf-8');
        return buffer.slice(startByte, endByte).toString('utf-8');
    }

    async parseContent(content, filePath = null) {
        try {
            // éªŒè¯è¾“å…¥å†…å®¹
            if (!content || typeof content !== 'string') {
                console.warn(`Invalid content for Python parsing in file: ${filePath || 'unknown'}`);
                return [];
            }

            // æ£€æŸ¥å†…å®¹æ˜¯å¦ä¸ºç©ºæˆ–è¿‡å¤§
            if (content.length === 0) {
                console.warn(`Empty content for Python parsing in file: ${filePath || 'unknown'}`);
                return [];
            }

            if (content.length > 10 * 1024 * 1024) { // 10MBé™åˆ¶
                console.warn(`Content too large for Python parsing in file: ${filePath || 'unknown'} (${content.length} bytes)`);
                return [];
            }

            // æ¸…ç†å¯èƒ½å¯¼è‡´è§£æå™¨é—®é¢˜çš„å­—ç¬¦
            let cleanContent = content.replace(/\0/g, ''); // ç§»é™¤nullå­—ç¬¦
            
            // å¦‚æœæ–‡ä»¶å¾ˆå¤§ï¼Œå…ˆå°è¯•æˆªå–å‰é¢éƒ¨åˆ†è¿›è¡Œè§£æ
            if (cleanContent.length > 1024 * 1024) { // 1MB
                console.warn(`Large Python file detected: ${filePath || 'unknown'} (${cleanContent.length} bytes), truncating for parsing`);
                cleanContent = cleanContent.substring(0, 1024 * 1024); // æˆªå–å‰1MB
            }

            // å°è¯•è§£æASTï¼Œä½¿ç”¨æ›´å¼ºçš„é”™è¯¯å¤„ç†
            let tree;
            try {
                tree = this.parser.parse(cleanContent);
            } catch (parseError) {
                console.warn(`Direct parsing failed for ${filePath || 'unknown'}: ${parseError.message}`);
                
                // å°è¯•è¿›ä¸€æ­¥æ¸…ç†å†…å®¹
                cleanContent = cleanContent
                    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // ç§»é™¤æ§åˆ¶å­—ç¬¦
                    .replace(/\r\n/g, '\n') // æ ‡å‡†åŒ–æ¢è¡Œç¬¦
                    .replace(/\r/g, '\n');
                
                try {
                    tree = this.parser.parse(cleanContent);
                } catch (secondError) {
                    console.warn(`Second parsing attempt failed for ${filePath || 'unknown'}: ${secondError.message}`);
                    
                    // æœ€åå°è¯•ï¼šåªè§£æå‰å‡ è¡Œ
                    const lines = cleanContent.split('\n').slice(0, 100); // åªå–å‰100è¡Œ
                    const truncatedContent = lines.join('\n');
                    try {
                        tree = this.parser.parse(truncatedContent);
                        console.warn(`Successfully parsed truncated version of ${filePath || 'unknown'} (first 100 lines)`);
                    } catch (finalError) {
                        console.error(`All parsing attempts failed for ${filePath || 'unknown'}: ${finalError.message}`);
                        return [];
                    }
                }
            }
            
            // æ£€æŸ¥è§£æç»“æœ
            if (!tree || !tree.rootNode) {
                console.warn(`Failed to parse AST for file: ${filePath || 'unknown'}`);
                return [];
            }

            const relativePath = filePath ? path.basename(filePath) : 'unknown';

            // æå–ä¸åŒç±»å‹çš„ä»£ç å—
            const imports = this._extractImports(tree, cleanContent);
            const classes = this._extractClasses(tree, cleanContent);
            const functions = this._extractFunctions(tree, cleanContent);
            const variables = this._extractVariables(tree, cleanContent);
            const other = this._extractOther(tree, cleanContent);

            // åˆå¹¶æ‰€æœ‰chunkså¹¶æŒ‰ç±»å‹åˆå¹¶ç›¸é‚»çš„chunks
            const allChunks = [...imports, ...classes, ...functions, ...variables, ...other];
            const mergedChunks = this._mergeAdjacentChunks(allChunks);

            // æ ¼å¼åŒ–chunks
            return mergedChunks.map(chunk => ({
                chunkId: this.generateChunkId(relativePath, chunk.startLine, chunk.endLine),
                filePath: relativePath,
                language: 'python',
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                content: chunk.content,
                parser: 'python_parser',
                type: chunk.type,
                ...(chunk.name && { name: chunk.name })
            }));

        } catch (error) {
            console.error(`Error parsing Python content in file: ${filePath || 'unknown'}:`, error);
            // è¿”å›ç©ºæ•°ç»„è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯ï¼Œè®©å¤„ç†ç»§ç»­è¿›è¡Œ
            return [];
        }
    }

    _extractImports(tree, code) {
        const imports = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.import.includes(child.type)) {
                // ä½¿ç”¨å­—èŠ‚ç´¢å¼•å’ŒBufferè¿›è¡Œæ­£ç¡®çš„å¤šå­—èŠ‚å­—ç¬¦å¤„ç†
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                imports.push({
                    type: 'import',
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return imports;
    }

    _extractClasses(tree, code) {
        const classes = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.class.includes(child.type)) {
                const className = this._getDefinitionName(child);
                // ä½¿ç”¨å­—èŠ‚ç´¢å¼•å’ŒBufferè¿›è¡Œæ­£ç¡®çš„å¤šå­—èŠ‚å­—ç¬¦å¤„ç†
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                classes.push({
                    type: 'class',
                    name: className,
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return classes;
    }

    _extractFunctions(tree, code) {
        const functions = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.function.includes(child.type)) {
                const funcName = this._getDefinitionName(child);
                // ä½¿ç”¨å­—èŠ‚ç´¢å¼•å’ŒBufferè¿›è¡Œæ­£ç¡®çš„å¤šå­—èŠ‚å­—ç¬¦å¤„ç†
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                functions.push({
                    type: 'function',
                    name: funcName,
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return functions;
    }

    _extractVariables(tree, code) {
        const variables = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.variable.includes(child.type)) {
                // ä½¿ç”¨å­—èŠ‚ç´¢å¼•å’ŒBufferè¿›è¡Œæ­£ç¡®çš„å¤šå­—èŠ‚å­—ç¬¦å¤„ç†
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                variables.push({
                    type: 'variable',
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return variables;
    }

    _extractOther(tree, code) {
        const other = [];
        // è·å–æ‰€æœ‰å·²å®šä¹‰çš„èŠ‚ç‚¹ç±»å‹
        const allDefinedTypes = Object.values(this.nodeTypes).flat();
        
        for (const child of tree.rootNode.children) {
            if (!allDefinedTypes.includes(child.type)) {
                // ä½¿ç”¨å­—èŠ‚ç´¢å¼•å’ŒBufferè¿›è¡Œæ­£ç¡®çš„å¤šå­—èŠ‚å­—ç¬¦å¤„ç†
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                other.push({
                    type: 'other',
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return other;
    }

    _mergeAdjacentChunks(chunks) {
        if (!chunks.length) return [];

        // æŒ‰èµ·å§‹è¡Œæ’åº
        const sortedChunks = chunks.sort((a, b) => a.startLine - b.startLine);
        const merged = [];
        let current = sortedChunks[0];

        for (let i = 1; i < sortedChunks.length; i++) {
            const next = sortedChunks[i];
            
            // å¦‚æœæ˜¯ç›¸åŒç±»å‹ä¸”ç›¸é‚»æˆ–éå¸¸æ¥è¿‘ï¼ˆæœ€å¤š1è¡Œé—´éš”ï¼‰
            if (current.type === next.type && next.startLine <= current.endLine + 2) {
                // åˆå¹¶chunks
                let content = current.content;
                if (next.startLine > current.endLine) {
                    content += '\n'.repeat(next.startLine - current.endLine);
                }
                content += next.content;

                current = {
                    type: current.type,
                    content: content,
                    startLine: current.startLine,
                    endLine: next.endLine,
                    ...(current.name && { name: current.name }),
                    ...(next.name && !current.name && { name: next.name })
                };
            } else {
                merged.push(current);
                current = next;
            }
        }
        
        merged.push(current);
        return merged;
    }

    _getDefinitionName(node) {
        for (const child of node.children) {
            if (child.type === 'identifier') {
                return child.text;
            }
        }
        return '';
    }

    generateChunkId(filePath, startLine, endLine) {
        const identifier = `${filePath}:${startLine}:${endLine}`;
        return crypto.createHash('sha256').update(identifier).digest('hex');
    }
}

module.exports = AstParser;

/***/ }),
/* 140 */
/***/ ((module) => {

"use strict";
module.exports = require("tree-sitter");

/***/ }),
/* 141 */
/***/ ((module) => {

"use strict";
module.exports = require("tree-sitter-python");

/***/ }),
/* 142 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BaseParser = __webpack_require__(138);
const path = __webpack_require__(4);

class ReadlineParser extends BaseParser {
    constructor(config, workspacePath = null) {
        super(config, workspacePath);
        // ç¡®ä¿ä½¿ç”¨æ›´å°çš„è¡Œæ•°ä»¥é¿å…10KBé™åˆ¶
        this.linesPerChunk = this.config.linesPerChunk || 15;
    }

    async parse(filePath, content) {
        if (!content || content.trim().length === 0) {
            return [];
        }

        // ä½¿ç”¨çˆ¶ç±»çš„æ™ºèƒ½åˆ†å‰²æ–¹æ³•ï¼Œè‡ªåŠ¨å¤„ç†å¤§å°é™åˆ¶
        return this._splitIntoChunks(content, filePath, this._detectLanguage(filePath));
    }

    _detectLanguage(filePath) {
        const ext = filePath.split('.').pop()?.toLowerCase();
        const languageMap = {
            'py': 'python',
            'js': 'javascript',
            'ts': 'typescript',
            'cs': 'csharp',
            'java': 'java',
            'cpp': 'cpp',
            'c': 'c',
            'h': 'c',
            'hpp': 'cpp'
        };
        return languageMap[ext] || 'unknown';
    }
}

module.exports = ReadlineParser; 

/***/ }),
/* 143 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BaseParser = __webpack_require__(138);
const path = __webpack_require__(4);

class FilenameParser extends BaseParser {
    async parse(filePath, content = null) {
        // å¦‚æœæ²¡æœ‰æä¾›å†…å®¹ï¼Œè¯»å–æ–‡ä»¶
        if (!content) {
            const fs = (__webpack_require__(5).promises);
            content = await fs.readFile(filePath, 'utf-8');
        }
        
        // ä»æ–‡ä»¶æ‰©å±•åæ¨æ–­è¯­è¨€
        const ext = path.extname(filePath);
        const langMapping = this.config.languageMapping || {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c'
        };
        const language = langMapping[ext] || 'unknown';
        const relativePath = path.basename(filePath);
        const lineCount = content.split('\n').length;
        
        return [this._createChunk(content, 1, lineCount, relativePath, language, 'file')];
    }
}

module.exports = FilenameParser; 

/***/ }),
/* 144 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const { Worker } = __webpack_require__(145);
const ParserSelector = __webpack_require__(137);

class Dispatcher {
    constructor(config) {
        this.config = config;
        // æ›´æ¿€è¿›åœ°é™ä½æœ€å¤§Workeræ•°é‡ï¼Œé»˜è®¤ç¦ç”¨Worker
        this.maxWorkers = Math.min(config.maxWorkers || 1, 1); // æœ€å¤š1ä¸ªWorker
        this.workspacePath = config.workspacePath;
        this.progressTracker = config.progressTracker;
        
        // é»˜è®¤ç¦ç”¨Workeræ¨¡å¼ï¼Œä¼˜å…ˆä½¿ç”¨åŒæ­¥å¤„ç†é¿å…å†…å­˜é—®é¢˜
        this.useWorkers = false; // æ”¹ä¸ºé»˜è®¤ç¦ç”¨
        
        // æ·»åŠ Workerç»Ÿè®¡
        this.activeWorkers = 0;
        this.maxActiveWorkers = 0;
        this.workerFailures = 0;
        
        // æ·»åŠ å†…å­˜ç›‘æ§
        this.memoryThreshold = 0.7; // 70%å†…å­˜ä½¿ç”¨ç‡æ—¶åœæ­¢Worker
        this.processedFiles = 0;
        this.maxFilesPerBatch = 100; // æ¯æ‰¹æœ€å¤šå¤„ç†100ä¸ªæ–‡ä»¶
    }

    log(message) {
        console.log(`[Dispatcher] ${message}`);
    }

    error(message) {
        console.error(`[Dispatcher] ${message}`);
    }

    warn(message) {
        console.warn(`[Dispatcher] ${message}`);
    }

    async processFiles(fileList, parserSelector) {
        this.log('fileList:', fileList);
        const chunks = [];

        for (const file of fileList) {
            if (!file || !file.path) {
                this.warn('Invalid file entry:', file);
                continue;
            }
            try {
                const fullPath = path.join(this.workspacePath, file.path);
                const content = await fs.readFile(fullPath, 'utf8');
                const parser = parserSelector.selectParser(file.path);
                // ä¿®å¤ï¼šä½¿ç”¨æ­£ç¡®çš„å‚æ•°é¡ºåº parse(filePath, content)
                const fileChunks = await parser.parse(fullPath, content);
                
                // ä¸ºåŒæ­¥æ–¹æ³•æ‰‹åŠ¨è®¾ç½®chunkå±æ€§ï¼ˆå› ä¸ºæ²¡æœ‰workerå¤„ç†ï¼‰
                fileChunks.forEach((chunk, index) => {
                    // ç”Ÿæˆå”¯ä¸€çš„chunk IDï¼ŒåŒ…å«è·¯å¾„å“ˆå¸Œç¡®ä¿å”¯ä¸€æ€§
                    const crypto = __webpack_require__(8);
                    const pathHash = crypto.createHash('md5').update(file.path).digest('hex').substring(0, 8);
                    const timestamp = Date.now().toString(36);
                    chunk.id = `${path.basename(file.path, path.extname(file.path))}_${pathHash}_${chunk.startLine || index}-${chunk.endLine || index}_${timestamp}_${index}`;
                    chunk.filePath = file.path;
                    
                    // æ³¨å†Œ chunk åˆ° ProgressTracker
                    if (this.progressTracker) {
                        this.progressTracker.registerChunk(chunk.id, {
                            filePath: chunk.filePath,
                            startLine: chunk.startLine,
                            endLine: chunk.endLine,
                            content: chunk.content,
                            parser: chunk.parser,
                            type: chunk.type,
                            language: chunk.language
                        });
                    }
                });
                
                chunks.push(...fileChunks);
            } catch (error) {
                this.error(`Error processing file ${file && file.path}:`, error);
            }
        }

        return chunks;
    }

    async processFilesConcurrently(fileList, parserSelector) {
        const chunks = [];
        const validFiles = fileList.filter(file => file && file.path);
        
        if (validFiles.length === 0) {
            this.warn('No valid files to process');
            return chunks;
        }

        // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
        const memUsage = this.checkMemoryUsage();
        this.log(`å½“å‰å†…å­˜ä½¿ç”¨ç‡: ${(memUsage * 100).toFixed(2)}%`);

        // å¯¹äºå¤§å‹é¡¹ç›®ï¼Œåˆ†æ‰¹å¤„ç†ä»¥é¿å…å†…å­˜é—®é¢˜
        if (validFiles.length > this.maxFilesPerBatch) {
            this.warn(`æ–‡ä»¶æ•°é‡è¿‡å¤š (${validFiles.length})ï¼Œåˆ†æ‰¹å¤„ç†ä»¥é¿å…å†…å­˜é—®é¢˜`);
            
            const batches = [];
            for (let i = 0; i < validFiles.length; i += this.maxFilesPerBatch) {
                batches.push(validFiles.slice(i, i + this.maxFilesPerBatch));
            }
            
            for (let i = 0; i < batches.length; i++) {
                this.log(`å¤„ç†æ‰¹æ¬¡ ${i + 1}/${batches.length} (${batches[i].length} ä¸ªæ–‡ä»¶)`);
                
                const batchChunks = await this.processFiles(batches[i], parserSelector);
                chunks.push(...batchChunks);
                
                // æ‰¹æ¬¡é—´æ£€æŸ¥å†…å­˜å¹¶å¼ºåˆ¶åƒåœ¾å›æ”¶
                this.checkMemoryUsage();
                if (global.gc) {
                    global.gc();
                }
                
                // æ‰¹æ¬¡é—´å°å»¶è¿Ÿï¼Œé‡Šæ”¾èµ„æº
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            return chunks;
        }

        // å¦‚æœworkerä¸å¯ç”¨æˆ–æ–‡ä»¶æ•°é‡é€‚ä¸­ï¼Œä½¿ç”¨åŒæ­¥å¤„ç†
        if (!this.useWorkers) {
            this.log('ä½¿ç”¨åŒæ­¥å¤„ç†æ¨¡å¼ (Workerå·²ç¦ç”¨æˆ–ä¸å¯ç”¨)');
            return await this.processFiles(validFiles, parserSelector);
        }

        try {
            // ä½¿ç”¨æ‰¹å¤„ç†æ–¹å¼æ§åˆ¶å¹¶å‘æ•°é‡
            const batchSize = this.maxWorkers;
            const batches = [];
            
            for (let i = 0; i < validFiles.length; i += batchSize) {
                batches.push(validFiles.slice(i, i + batchSize));
            }

            // æŒ‰æ‰¹æ¬¡å¤„ç†æ–‡ä»¶
            for (const batch of batches) {
                const batchPromises = batch.map(file => this._createWorkerPromise(file, chunks, parserSelector));
                
                // ç­‰å¾…å½“å‰æ‰¹æ¬¡çš„æ‰€æœ‰ worker å®Œæˆ
                const results = await Promise.allSettled(batchPromises);
                
                // è®°å½•ä»»ä½•å¤±è´¥çš„ä»»åŠ¡
                results.forEach((result, index) => {
                    if (result.status === 'rejected') {
                        this.error(`Batch processing failed for file ${batch[index].path}:`, result.reason);
                    }
                });
                
                // æ‰¹æ¬¡é—´æ£€æŸ¥å†…å­˜
                this.checkMemoryUsage();
            }
        } catch (error) {
            this.error('Worker processing failed, switching to synchronous mode:', error);
            this.useWorkers = false;
            return await this.processFiles(validFiles, parserSelector);
        }

        return chunks;
    }

    /**
     * åˆ›å»ºWorker Promiseï¼Œè´Ÿè´£åè°ƒworkerçš„æ‰§è¡Œ
     * æ³¨æ„ï¼šchunkçš„idå’ŒfilePathå±æ€§ç”±worker.jsè´Ÿè´£è®¾ç½®ï¼Œæ­¤æ–¹æ³•åªè´Ÿè´£ProgressTrackeræ³¨å†Œ
     */
    _createWorkerPromise(file, chunks, parserSelector) {
        return new Promise((resolve, reject) => {
            let worker;
            
            // æ£€æŸ¥Workerå¤±è´¥ç‡ï¼Œå¦‚æœå¤ªé«˜å°±ç›´æ¥ä½¿ç”¨åŒæ­¥å¤„ç†
            if (this.workerFailures > 10) {
                this.warn(`Workerå¤±è´¥æ¬¡æ•°è¿‡å¤š(${this.workerFailures})ï¼Œåˆ‡æ¢åˆ°åŒæ­¥å¤„ç†æ¨¡å¼`);
                this.useWorkers = false;
                this._processSingleFileSync(file, chunks, parserSelector)
                    .then(resolve)
                    .catch(reject);
                return;
            }
            
            try {
                worker = this._createWorker(file);
                this.activeWorkers++;
                this.maxActiveWorkers = Math.max(this.maxActiveWorkers, this.activeWorkers);
            } catch (error) {
                this.workerFailures++;
                this.error(`Failed to create worker for file ${file.path} (å¤±è´¥æ¬¡æ•°: ${this.workerFailures}):`, error);
                // å›é€€åˆ°åŒæ­¥å¤„ç†å•ä¸ªæ–‡ä»¶
                this._processSingleFileSync(file, chunks, parserSelector)
                    .then(resolve)
                    .catch(reject);
                return;
            }

            // è®¾ç½®è¶…æ—¶å¤„ç†ï¼ˆé˜²æ­¢workerå¡æ­»ï¼‰
            const timeout = setTimeout(() => {
                if (worker) {
                    worker.terminate();
                }
                reject(new Error(`Worker timeout for file ${file.path}`));
            }, 30000); // 30ç§’è¶…æ—¶

            worker.on('message', (result) => {
                clearTimeout(timeout);
                this.activeWorkers--;
                
                if (result.chunks) {
                    // chunkçš„idå’ŒfilePathå·²ç»åœ¨workerä¸­è®¾ç½®ï¼Œè¿™é‡Œåªéœ€è¦è¿›è¡ŒProgressTrackeræ³¨å†Œ
                    result.chunks.forEach(chunk => {
                        // éªŒè¯workeræ˜¯å¦æ­£ç¡®è®¾ç½®äº†å¿…è¦å±æ€§
                        if (!chunk.id || !chunk.filePath) {
                            this.warn(`Missing chunk properties from worker for file ${file.path}:`, {
                                hasId: !!chunk.id,
                                hasFilePath: !!chunk.filePath
                            });
                        }
                        
                        // æ³¨å†Œ chunk åˆ° ProgressTracker
                        if (this.progressTracker && chunk.id) {
                            this.progressTracker.registerChunk(chunk.id, {
                                filePath: chunk.filePath,
                                startLine: chunk.startLine,
                                endLine: chunk.endLine,
                                content: chunk.content,
                                parser: chunk.parser,
                                type: chunk.type,
                                language: chunk.language
                            });
                        }
                    });
                    chunks.push(...result.chunks);
                }
                resolve(result);
            });

            worker.on('error', (error) => {
                clearTimeout(timeout);
                this.activeWorkers--;
                this.workerFailures++;
                this.error(`Worker error for file ${file.path} (å¤±è´¥æ¬¡æ•°: ${this.workerFailures}):`, error);
                
                // å›é€€åˆ°åŒæ­¥å¤„ç†
                this._processSingleFileSync(file, chunks, parserSelector)
                    .then(() => resolve({ chunks: [] }))
                    .catch(reject);
            });

            worker.on('exit', (code) => {
                clearTimeout(timeout);
                this.activeWorkers--;
                if (code !== 0) {
                    this.workerFailures++;
                    const error = new Error(`Worker stopped with exit code ${code}`);
                    this.error(`Worker exit error for file ${file.path} (å¤±è´¥æ¬¡æ•°: ${this.workerFailures}):`, error);
                    
                    // å›é€€åˆ°åŒæ­¥å¤„ç†
                    this._processSingleFileSync(file, chunks, parserSelector)
                        .then(() => resolve({ chunks: [] }))
                        .catch(reject);
                } else {
                    resolve();
                }
            });
        });
    }

    /**
     * åŒæ­¥å¤„ç†å•ä¸ªæ–‡ä»¶ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
     */
    async _processSingleFileSync(file, chunks, parserSelector) {
        try {
            const fullPath = path.join(this.workspacePath, file.path);
            const content = await fs.readFile(fullPath, 'utf8');
            const parser = parserSelector.selectParser(file.path);
            const fileChunks = await parser.parse(fullPath, content);
            
            // è®¾ç½®chunkå±æ€§
            fileChunks.forEach((chunk, index) => {
                const crypto = __webpack_require__(8);
                const pathHash = crypto.createHash('md5').update(file.path).digest('hex').substring(0, 8);
                const timestamp = Date.now().toString(36);
                chunk.id = `${path.basename(file.path, path.extname(file.path))}_${pathHash}_${chunk.startLine || index}-${chunk.endLine || index}_${timestamp}_${index}`;
                chunk.filePath = file.path;
                
                // æ³¨å†Œ chunk åˆ° ProgressTracker
                if (this.progressTracker) {
                    this.progressTracker.registerChunk(chunk.id, {
                        filePath: chunk.filePath,
                        startLine: chunk.startLine,
                        endLine: chunk.endLine,
                        content: chunk.content,
                        parser: chunk.parser,
                        type: chunk.type,
                        language: chunk.language
                    });
                }
            });
            
            chunks.push(...fileChunks);
            this.log(`Processed file synchronously: ${file.path} (${fileChunks.length} chunks)`);
        } catch (error) {
            this.error(`Error in sync processing for file ${file.path}:`, error);
        }
    }

    _createWorker(file) {
        // å°è¯•å¤šä¸ªå¯èƒ½çš„workerè·¯å¾„
        const possiblePaths = [
            path.join(__dirname, 'worker.js'),
            path.resolve(__dirname, 'worker.js'),
            path.join(process.cwd(), 'code-chunker', 'src', 'worker.js'),
            path.join(process.cwd(), 'src', 'worker.js')
        ];

        let workerPath = null;
        for (const p of possiblePaths) {
            if (fs.existsSync(p)) {
                workerPath = p;
                break;
            }
        }

        if (!workerPath) {
            throw new Error(`Worker script not found at any of these paths: ${possiblePaths.join(', ')}`);
        }

        const worker = new Worker(workerPath, {
            workerData: {
                file,
                workspacePath: this.workspacePath,
                config: this.config
            }
        });

        return worker;
    }

    /**
     * è·å–Workerç»Ÿè®¡ä¿¡æ¯
     */
    getWorkerStats() {
        return {
            maxWorkers: this.maxWorkers,
            activeWorkers: this.activeWorkers,
            maxActiveWorkers: this.maxActiveWorkers,
            workerFailures: this.workerFailures,
            useWorkers: this.useWorkers
        };
    }

    /**
     * é‡ç½®Workerç»Ÿè®¡
     */
    resetWorkerStats() {
        this.activeWorkers = 0;
        this.maxActiveWorkers = 0;
        this.workerFailures = 0;
        this.useWorkers = false;
    }

    // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
    checkMemoryUsage() {
        const memUsage = process.memoryUsage();
        const totalMem = (__webpack_require__(146).totalmem)();
        const usedPercentage = memUsage.heapUsed / totalMem;
        
        if (usedPercentage > this.memoryThreshold) {
            this.warn(`é«˜å†…å­˜ä½¿ç”¨ç‡æ£€æµ‹åˆ°: ${(usedPercentage * 100).toFixed(2)}%ï¼Œåˆ‡æ¢åˆ°åŒæ­¥æ¨¡å¼`);
            this.useWorkers = false;
            
            // å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (global.gc) {
                global.gc();
            }
        }
        
        return usedPercentage;
    }
}

module.exports = Dispatcher; 

/***/ }),
/* 145 */
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),
/* 146 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 147 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const axios = __webpack_require__(148);
const ProgressTracker = __webpack_require__(220);
const VectorManager = __webpack_require__(221);
const EmbeddingClient = __webpack_require__(231);
const config = __webpack_require__(123);

class Sender {
    constructor(senderConfig, progressTracker, externalVectorManager = null, performanceAnalyzer = null) {
        // æ”¯æŒä¼ å…¥é…ç½®å¯¹è±¡æˆ–ä½¿ç”¨å…¨å±€é…ç½®
        this.config = senderConfig || config.getAll();
        this.progressTracker = progressTracker;
        this.performanceAnalyzer = performanceAnalyzer;
        
        // ç¡®ä¿å¿…è¦çš„APIé”å®šé…ç½®å­˜åœ¨
        this.config.userId = this.config.userId || "user123";
        this.config.deviceId = this.config.deviceId || "device123";
        this.config.workspacePath = this.config.workspacePath || process.cwd();
        
        // åˆå§‹åŒ–åµŒå…¥å®¢æˆ·ç«¯
        this.embeddingClient = new EmbeddingClient({
            apiEndpoint: this.config.apiEndpoint,
            token: this.config.token,
            timeout: this.config.timeout,
            batchSize: this.config.batchSize,
            maxRetries: this.config.maxRetries,
            retryDelay: this.config.retryDelay
        });
        
        // ä¼ é€’æ€§èƒ½åˆ†æå™¨ç»™EmbeddingClient
        if (this.performanceAnalyzer) {
            this.embeddingClient.performanceAnalyzer = this.performanceAnalyzer;
        }
        
        this.stats = {
            totalChunks: 0,
            successfulChunks: 0,
            failedChunks: 0,
            totalEmbeddings: 0,
            processingTime: 0
        };
        
        this.batchSize = this.config.batchSize || 10;
        this.retryAttempts = this.config.retryAttempts || 3;
        this.retryDelay = this.config.retryDelay || 1000;
        this.asyncTimeout = this.config.asyncTimeout || 60000; // å¼‚æ­¥å¤„ç†è¶…æ—¶æ—¶é—´
        this.pendingAsyncResults = new Map(); // è·Ÿè¸ªå¾…å¤„ç†çš„å¼‚æ­¥ç»“æœ
        
        // APIé”å®šæœºåˆ¶ç®¡ç†
        this.lockedTasks = new Map(); // è·Ÿè¸ªè¢«é”å®šçš„ä»»åŠ¡: key -> timestamp
        this.lockDuration = 30000; // 30ç§’é”å®šæ—¶é—´
        
        // å¯åŠ¨å®šæœŸæ¸…ç†è¿‡æœŸé”å®š
        this.lockCleanupInterval = setInterval(() => {
            this._cleanupExpiredLocks();
        }, 10000); // æ¯10ç§’æ¸…ç†ä¸€æ¬¡
        
        // ä½¿ç”¨å¤–éƒ¨ä¼ å…¥çš„VectorManagerï¼Œé¿å…é‡å¤åˆå§‹åŒ–
        if (externalVectorManager) {
            this.vectorManager = externalVectorManager;
        } else if (this.config.vectorManager?.enabled) {
            this.vectorManager = new VectorManager(this.config.vectorManager);
            this.vectorManager.initialize().catch(error => {
                console.error('Failed to initialize VectorManager:', error);
            });
        }
    }

    async _sendBatch(batch) {
        try {
            // ä¸ºæ¯ä¸ªchunké¢„è®¾ç½®çŠ¶æ€ä¸ºprocessing
            if (this.progressTracker) {
                for (const chunk of batch) {
                    this.progressTracker.updateChunkStatus(chunk.id, 'processing', {
                        batchSize: batch.length,
                        startTime: new Date().toISOString()
                    });
                }
            }

            // å‡†å¤‡ä»£ç å—æ•°æ® - ä¸è¿‡æ»¤ç©ºå†…å®¹ï¼Œè®©é—®é¢˜æš´éœ²å‡ºæ¥
            const codeChunks = batch.map(chunk => ({
                chunkId: chunk.id,
                filePath: chunk.filePath,
                language: chunk.language || 'unknown',
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                content: chunk.content,
                parser: chunk.parser || 'tree_sitter'
            }));

            // è®°å½•ç©ºå†…å®¹ä»£ç å—ä½†ä¸è¿‡æ»¤ï¼Œè®©é—®é¢˜æš´éœ²
            codeChunks.forEach((chunk, index) => {
                if (!chunk.content || chunk.content.trim().length === 0) {
                    console.warn(`ğŸš¨ å‘ç°ç©ºå†…å®¹ä»£ç å— ${index + 1}: ${chunk.chunkId} (è¡Œå·: ${chunk.startLine}-${chunk.endLine})`);
                    console.warn(`   æ–‡ä»¶è·¯å¾„: ${chunk.filePath}`);
                    console.warn(`   å†…å®¹é•¿åº¦: ${chunk.content ? chunk.content.length : 'null/undefined'}`);
                }
            });

           

            // ä½¿ç”¨æ–°çš„EmbeddingClientå‘é€è¯·æ±‚
            const embeddingOptions = {
                uniqueId: `${this.config.userId}-${this.config.deviceId}-${Date.now()}`,
                parserVersion: '1.0.0',
                processingMode: 'sync', // ä¼˜å…ˆä½¿ç”¨åŒæ­¥æ¨¡å¼
                autoPolling: true,
                onProgress: (progress) => {
                    // å¤„ç†è¿›åº¦æ›´æ–°
                }
            };
            
            // è®°å½•ç½‘ç»œè¯·æ±‚å¼€å§‹æ—¶é—´
            const networkStartTime = Date.now();
            const result = await this.embeddingClient.embedCodeBlocks(codeChunks, embeddingOptions);
            const networkEndTime = Date.now();
            
            // è®°å½•ç½‘ç»œè¯·æ±‚æ€§èƒ½
            if (this.performanceAnalyzer) {
                this.performanceAnalyzer.recordNetworkRequest('embedding', networkEndTime - networkStartTime, true);
                this.performanceAnalyzer.updatePeakMemory();
            }
            
            // å¤„ç†ç»“æœå¹¶æ›´æ–°çŠ¶æ€
            const processedResults = await this._processEmbeddingResults(result, batch);
            await this._saveDataToLocal(processedResults, batch);
            return {
                status: 'completed',
                results: processedResults,
                batchId: this._generateBatchId(batch),
                processingMode: result.processingMode,
                totalProcessingTimeMs: result.totalProcessingTimeMs
            };

        } catch (error) {
            console.error('âŒ æ‰¹æ¬¡å‘é€å¤±è´¥:', error.message);
            console.error('âŒ é”™è¯¯è¯¦æƒ…:', {
                name: error.name,
                message: error.message,
                stack: error.stack,
                embeddingError: error.embeddingError
            });

            // æ›´æ–°æ‰€æœ‰chunkçŠ¶æ€ä¸ºå¤±è´¥
            if (this.progressTracker) {
                for (const chunk of batch) {
                    this.progressTracker.updateChunkStatus(chunk.id, 'failed', {
                        error: error.message,
                        errorType: error.embeddingError?.type || 'ProcessingError',
                        timestamp: new Date().toISOString()
                    });
                }
            }

            throw error;
        }
    }

    async _saveDataToLocal(codeChunks, originalBatch) {
        try {
            // å‚æ•°éªŒè¯
            if (!codeChunks || !Array.isArray(codeChunks)) {
                console.warn('Invalid codeChunks parameter for _saveDataToLocal:', codeChunks);
                codeChunks = []; // ä½¿ç”¨ç©ºæ•°ç»„ä½œä¸ºé»˜è®¤å€¼
            }
            
            if (!originalBatch || !Array.isArray(originalBatch)) {
                console.warn('Invalid originalBatch parameter for _saveDataToLocal:', originalBatch);
                originalBatch = []; // ä½¿ç”¨ç©ºæ•°ç»„ä½œä¸ºé»˜è®¤å€¼
            }
            
            const fs = (__webpack_require__(5).promises);
            const path = __webpack_require__(4);
            
            // åˆ›å»ºæœ¬åœ°æ•°æ®ç›®å½•
            const dataDir = path.join(process.cwd(), 'local_data', 'send_logs');
            await fs.mkdir(dataDir, { recursive: true });
            
            // ç”Ÿæˆæ—¶é—´æˆ³å’Œæ‰¹æ¬¡ID
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const batchId = this._generateBatchId(originalBatch);
            
            // å‡†å¤‡ä¿å­˜çš„æ•°æ®
            const saveData = {
                batchInfo: {
                    batchId: batchId,
                    timestamp: new Date().toISOString(),
                    chunkCount: codeChunks.length,
                    userId: this.config.userId || 'unknown',
                    deviceId: this.config.deviceId || 'unknown'
                },
                embeddingOptions: {
                    uniqueId: `${this.config.userId || 'unknown'}-${this.config.deviceId || 'unknown'}-${Date.now()}`,
                    parserVersion: '1.0.0',
                    processingMode: 'sync'
                },
                codeChunks: codeChunks,
                originalChunkData: originalBatch.map(chunk => ({
                    id: chunk?.id || 'unknown',
                    filePath: chunk?.filePath || 'unknown',
                    fileName: chunk?.fileName || null,
                    type: chunk?.type || 'unknown',
                    contentPreview: chunk?.content ? chunk.content.substring(0, 200) + '...' : 'No content'
                }))
            };
            
            // ä¿å­˜å®Œæ•´æ•°æ®åˆ°JSONæ–‡ä»¶
            const fileName = `batch_${batchId}_${timestamp}.json`;
            const filePath = path.join(dataDir, fileName);
            
            await fs.writeFile(filePath, JSON.stringify(saveData, null, 2), 'utf8');
            
            // åŒæ—¶ä¿å­˜ä¸€ä»½ç®€åŒ–çš„æ‘˜è¦ä¿¡æ¯
            const summaryData = {
                batchId: batchId,
                timestamp: new Date().toISOString(),
                chunkCount: codeChunks.length,
                files: [...new Set(codeChunks.map(chunk => chunk?.filePath || 'unknown').filter(path => path !== 'unknown'))],
                languages: [...new Set(codeChunks.map(chunk => chunk?.language || 'unknown').filter(lang => lang !== 'unknown'))],
                totalLines: codeChunks.reduce((sum, chunk) => {
                    const startLine = chunk?.startLine || 0;
                    const endLine = chunk?.endLine || 0;
                    return sum + (endLine > startLine ? endLine - startLine + 1 : 0);
                }, 0)
            };
            
            const summaryFileName = `summary_${batchId}_${timestamp}.json`;
            const summaryFilePath = path.join(dataDir, summaryFileName);
            await fs.writeFile(summaryFilePath, JSON.stringify(summaryData, null, 2), 'utf8');
            
        } catch (error) {
            console.warn('ä¿å­˜æœ¬åœ°æ•°æ®å¤±è´¥:', error.message);
            console.warn('é”™è¯¯è¯¦æƒ…:', error.stack);
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå…è®¸ç»§ç»­å¤„ç†
        }
    }

    async _processEmbeddingResults(embeddingResult, originalBatch) {
        // å‚æ•°éªŒè¯
        if (!embeddingResult || !embeddingResult.results || !Array.isArray(embeddingResult.results)) {
            console.warn('Invalid embedding result format:', embeddingResult);
            return []; // è¿”å›ç©ºæ•°ç»„é¿å…åç»­é”™è¯¯
        }
        
        const processedResults = []; // æ”¶é›†å¤„ç†ç»“æœ
        
        // å¤„ç†æ¯ä¸ªåµŒå…¥ç»“æœ
        for (const result of embeddingResult.results) {
            try {
                
                if (result.status === 'success' && (result.vector || result.compressedVector)) {
                    // å­˜å‚¨å‘é‡åˆ°VectorManager (æ”¯æŒå‹ç¼©å‘é‡)
                    const stored = await this._storeEmbeddingVector(result, originalBatch);
                    
                    // æ„å»ºå¤„ç†ç»“æœï¼Œæ”¯æŒå‹ç¼©å‘é‡æ ¼å¼
                    const processedResult = {
                        chunkId: result.chunkId,
                        status: 'success',
                        vector: result.vector,
                        compressedVector: result.compressedVector,
                        isCompressed: result.isCompressed || false,
                        vectorDimension: result.vectorDimension || (result.vector ? result.vector.length : 0),
                        stored: stored,
                        filePath: result.filePath || 'unknown',
                        startLine: result.startLine || 0,
                        endLine: result.endLine || 0,
                        language: result.language || 'unknown',
                        processingMode: 'embedding_success',
                        modelVersion: result.modelVersion
                    };
                    
                    processedResults.push(processedResult);
                    
                    if (stored) {
                        // æ›´æ–°è¿›åº¦ï¼šæˆåŠŸ
                        if (this.progressTracker) {
                            this.progressTracker.updateChunkStatus(result.chunkId, 'completed', {
                                vectorStored: true,
                                vectorDimension: result.vectorDimension || (result.vector ? result.vector.length : 0),
                                isCompressed: result.isCompressed || false,
                                processingMode: 'embedding_success'
                            });
                        }
                    } else {
                        // å­˜å‚¨å¤±è´¥ï¼ˆå¯èƒ½å› ä¸ºVectorManagerå…³é—­ï¼‰ï¼Œä½†ä¸ç®—ä½œé”™è¯¯
                        console.warn(`Vector storage failed for chunk ${result.chunkId}, marking as completed anyway`);
                        if (this.progressTracker) {
                            this.progressTracker.updateChunkStatus(result.chunkId, 'completed', {
                                vectorStored: false,
                                vectorDimension: result.vectorDimension || (result.vector ? result.vector.length : 0),
                                isCompressed: result.isCompressed || false,
                                processingMode: 'embedding_success_storage_skipped',
                                warning: 'Vector storage skipped (VectorManager unavailable)'
                            });
                        }
                    }
                } else {
                    // åµŒå…¥å¤±è´¥
                    console.warn(`åµŒå…¥ç”Ÿæˆå¤±è´¥: ${result.chunkId} - ${result.error || 'Unknown error'}`);
                    
                    // æ„å»ºå¤±è´¥ç»“æœ
                    const failedResult = {
                        chunkId: result.chunkId,
                        status: 'failed',
                        error: result.error || 'Embedding generation failed',
                        filePath: result.filePath || 'unknown',
                        startLine: result.startLine || 0,
                        endLine: result.endLine || 0,
                        language: result.language || 'unknown',
                        processingMode: 'embedding_failure'
                    };
                    
                    processedResults.push(failedResult);
                    
                    if (this.progressTracker) {
                        this.progressTracker.updateChunkStatus(result.chunkId, 'failed', {
                            error: result.error || 'Embedding generation failed',
                            processingMode: 'embedding_failure'
                        });
                    }
                }
            } catch (error) {
                console.error(`å¤„ç†ä»£ç å— ${result.status} ${result.chunkId} ${result.startLine || 'unknown'}-${result.endLine || 'unknown'} ${result.chunkId.substring(0, 8)} ${result.vectorDimension || 0} ç»“æœæ—¶å‡ºé”™:`, error);
                
                // æ„å»ºé”™è¯¯ç»“æœ
                const errorResult = {
                    chunkId: result.chunkId || 'unknown',
                    status: 'error',
                    error: error.message,
                    filePath: 'unknown',
                    startLine: 0,
                    endLine: 0,
                    language: 'unknown',
                    processingMode: 'embedding_processing_error'
                };
                
                processedResults.push(errorResult);
                
                // æ›´æ–°è¿›åº¦ï¼šå¤„ç†é”™è¯¯
                if (this.progressTracker) {
                    this.progressTracker.updateChunkStatus(result.chunkId, 'failed', {
                        error: error.message,
                        processingMode: 'embedding_processing_error'
                    });
                }
                
                // ä¸é‡æ–°æŠ›å‡ºé”™è¯¯ï¼Œç»§ç»­å¤„ç†å…¶ä»–ç»“æœ
            }
        }
        

        return processedResults; // è¿”å›å¤„ç†ç»“æœæ•°ç»„
    }

    async _setupAsyncResultHandling(responseData, originalBatch) {
        const requestId = responseData.requestId;
        const estimatedTime = responseData.estimatedProcessingTimeMs || 30000;
        
        if (!requestId) {
            throw new Error('Missing requestId in async response');
        }

        // ä¸ºæ‰¹æ¬¡ä¸­çš„æ¯ä¸ªchunkè®¾ç½®å¼‚æ­¥ç­‰å¾…çŠ¶æ€
        if (this.progressTracker) {
            for (const chunk of originalBatch) {
                this.progressTracker.updateChunkStatus(chunk.id, 'async_pending', {
                    requestId: requestId,
                    estimatedTime: estimatedTime,
                    submittedAt: new Date().toISOString()
                });
            }
        }

        // å­˜å‚¨å¼‚æ­¥è¯·æ±‚ä¿¡æ¯
        this.pendingAsyncResults.set(requestId, {
            batch: originalBatch,
            submittedAt: Date.now(),
            estimatedTime: estimatedTime,
            callbackUrl: responseData.callbackUrl
        });

        // å¯åŠ¨è½®è¯¢æˆ–è®¾ç½®å›è°ƒ
        if (responseData.callbackUrl) {
            // å¦‚æœæœ‰å›è°ƒURLï¼Œå¯ä»¥è®¾ç½®webhookå¤„ç†
    
        } else {
            // å¯åŠ¨è½®è¯¢æ£€æŸ¥ç»“æœ
            this._startPollingForResult(requestId, estimatedTime);
        }

        return {
            requestId: requestId,
            status: 'pending',
            estimatedTime: estimatedTime,
            chunkCount: originalBatch.length
        };
    }

    async _startPollingForResult(requestId, estimatedTime) {
        // ç­‰å¾…ä¼°è®¡æ—¶é—´çš„80%åå¼€å§‹è½®è¯¢
        const initialDelay = estimatedTime * 0.8;
        setTimeout(async () => {
            await this._pollAsyncResult(requestId);
        }, initialDelay);
    }

    async _pollAsyncResult(requestId, attempt = 1) {
        const maxPollingAttempts = 10;
        const pollingInterval = 5000; // 5ç§’é—´éš”

        try {
            const response = await axios.get(`${this.config.endpoint}/results/${requestId}`, {
                headers: {
                    'Authorization': `Bearer ${this.config.token}`
                },
                timeout: 15000
            });

            if (response.status === 200 && response.data.status === 'completed') {
                // å¼‚æ­¥å¤„ç†å®Œæˆ
                const pendingInfo = this.pendingAsyncResults.get(requestId);
                if (pendingInfo) {
                    await this._processSyncEmbeddingResults(response.data, pendingInfo.batch);
                    this.pendingAsyncResults.delete(requestId);
        
                }
            } else if (response.status === 200 && response.data.status === 'processing') {
                // ä»åœ¨å¤„ç†ä¸­ï¼Œç»§ç»­è½®è¯¢
                if (attempt < maxPollingAttempts) {
                    setTimeout(() => {
                        this._pollAsyncResult(requestId, attempt + 1);
                    }, pollingInterval);
                } else {
                    console.error(`Polling timeout for requestId: ${requestId}`);
                    this._handleAsyncTimeout(requestId);
                }
            } else {
                console.error(`Async processing failed for requestId: ${requestId}`, response.data);
                this._handleAsyncFailure(requestId, response.data.error);
            }
        } catch (error) {
            console.error(`Error polling async result for ${requestId}:`, error);
            if (attempt < maxPollingAttempts) {
                setTimeout(() => {
                    this._pollAsyncResult(requestId, attempt + 1);
                }, pollingInterval);
            } else {
                this._handleAsyncTimeout(requestId);
            }
        }
    }

    async _storeEmbeddingVector(result, originalBatch) {
        const maxRetries = 2; // æœ€å¤šé‡è¯•2æ¬¡
        let lastError = null;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                // è·å–å¯¹åº”çš„åŸå§‹chunkä¿¡æ¯
                const originalChunk = originalBatch.find(chunk => chunk.id === result.chunkId);
                if (!originalChunk) {
                    console.warn(`Original chunk not found for ${result.chunkId}`);
                    return false;
                }

                // ç”Ÿæˆé”å®šé”®ï¼šåŸºäºsnippet_id + user_id + device_id
                const lockKey = `${result.chunkId}_${this.config.userId}_${this.config.deviceId}`;
                
                // æ£€æŸ¥æ˜¯å¦åœ¨é”å®šæœŸå†…
                if (this.lockedTasks.has(lockKey)) {
                    const lockTime = this.lockedTasks.get(lockKey);
                    const timeElapsed = Date.now() - lockTime;
                    
                    if (timeElapsed < this.lockDuration) {
                        const waitTime = this.lockDuration - timeElapsed;
        
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        
                        // æ¸…é™¤é”å®šè®°å½•
                        this.lockedTasks.delete(lockKey);
                    } else {
                        // é”å®šå·²è¿‡æœŸï¼Œæ¸…é™¤è®°å½•
                        this.lockedTasks.delete(lockKey);
                    }
                }

                // ç›´æ¥ä½¿ç”¨EmbeddingClientçš„upsert APIæ¥å£
                try {
                    // å‡†å¤‡æ–‡æ¡£æ•°æ®ï¼Œæ”¯æŒå‹ç¼©å‘é‡æ ¼å¼
                    const documents = [{
                        snippet_id: result.chunkId,
                        user_id: this.config.userId,
                        device_id: this.config.deviceId,
                        workspace_path: this.config.workspacePath,
                        file_path: originalChunk.filePath || 'unknown',
                        start_line: originalChunk.startLine || 1,
                        end_line: originalChunk.endLine || 1,
                        code: originalChunk.content || '',
                        vector: result.isCompressed ? null : result.vector,
                        compressedVector: result.isCompressed ? result.compressedVector : null,
                        isCompressed: result.isCompressed || false,
                        vector_model: result.modelVersion || "CoCoSoDa-v1.0",
                        compressionFormat: 'base64',
                        originalDimensions: 768,
                    }];

                    // ç”Ÿæˆè¯·æ±‚ID
                    const requestId = `req-store-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    
                    // å‡†å¤‡upsertè¯·æ±‚æ•°æ®
                    const upsertData = {
                        requestId: requestId,
                        database: this.config.database || 'codebase_db',
                        collection: this.config.collection || 'code_vectors1',  // ä½¿ç”¨é…ç½®ä¸­çš„collectionåç§°ï¼Œé»˜è®¤ä¸ºcode_vectors1
                        documents: documents,
                        buildIndex: true
                    };

                    // ===== è¯¦ç»†è¯·æ±‚æ—¥å¿— =====
                    console.log(`\nğŸ” ===== UPSERT API è¯·æ±‚è¯¦æƒ… =====`);
                    console.log(`ğŸ“¡ URL: POST /api/v1/codebase/upsert`);
                    console.log(`ğŸ†” Request ID: ${requestId}`);
                    console.log(`ğŸ“¦ Chunk ID: ${result.chunkId}`);
                    console.log(`ğŸ“Š è¯·æ±‚ä½“å¤§å°: ${JSON.stringify(upsertData).length} å­—ç¬¦`);
                    console.log(`ğŸ“‹ å®Œæ•´è¯·æ±‚ä½“:`, JSON.stringify(upsertData, null, 2));
                    
                    // åˆ†æå‘é‡æ•°æ®
                    const doc = documents[0];
                    if (doc.isCompressed) {
                        console.log(`ğŸ—œï¸ å‹ç¼©å‘é‡ä¿¡æ¯:`);
                        console.log(`   - å‹ç¼©æ ¼å¼: ${doc.compressionFormat}`);
                        console.log(`   - åŸå§‹ç»´åº¦: ${doc.originalDimensions}`);
                        console.log(`   - å‹ç¼©æ•°æ®é•¿åº¦: ${doc.compressedVector ? doc.compressedVector.length : 'null'}`);
                    } else {
                        console.log(`ğŸ¯ æ ‡å‡†å‘é‡ä¿¡æ¯:`);
                        console.log(`   - å‘é‡ç»´åº¦: ${doc.vector ? doc.vector.length : 'null'}`);
                        console.log(`   - å‘é‡ç±»å‹: ${Array.isArray(doc.vector) ? 'Array' : typeof doc.vector}`);
                    }
                    
                    console.log(`ğŸ“„ æ–‡æ¡£ä¿¡æ¯:`);
                    console.log(`   - æ–‡ä»¶è·¯å¾„: ${doc.file_path}`);
                    console.log(`   - è¡Œå·èŒƒå›´: ${doc.start_line}-${doc.end_line}`);
                    console.log(`   - ä»£ç é•¿åº¦: ${doc.code.length} å­—ç¬¦`);
                    console.log(`   - å‘é‡æ¨¡å‹: ${doc.vector_model}`);
                    console.log(`ğŸ” ================================\n`);
    
                    // ç›´æ¥è°ƒç”¨APIæ¥å£
                    const response = await this.embeddingClient._makeRequest('POST', '/api/v1/codebase/upsert', upsertData);
                    
                    // ===== è¯¦ç»†å“åº”æ—¥å¿— =====
                    console.log(`\nğŸ“¥ ===== UPSERT API å“åº”è¯¦æƒ… =====`);
                    console.log(`ğŸ†” Request ID: ${requestId}`);
                    console.log(`ğŸ“¦ Chunk ID: ${result.chunkId}`);
                    console.log(`ğŸ“Š å“åº”ä½“å¤§å°: ${JSON.stringify(response).length} å­—ç¬¦`);
                    console.log(`ğŸ“‹ å®Œæ•´å“åº”ä½“:`, JSON.stringify(response, null, 2));
                    
                    // åˆ†æå“åº”çŠ¶æ€
                    const status = response.status || response['status:'];
                    const hasStatusField = 'status' in response;
                    const hasStatusColonField = 'status:' in response;
                    
                    console.log(`ğŸ“Š çŠ¶æ€å­—æ®µåˆ†æ:`);
                    console.log(`   - 'status' å­—æ®µå­˜åœ¨: ${hasStatusField}`);
                    console.log(`   - 'status:' å­—æ®µå­˜åœ¨: ${hasStatusColonField}`);
                    console.log(`   - æœ€ç»ˆçŠ¶æ€å€¼: "${status}"`);
                    console.log(`   - çŠ¶æ€ç±»å‹: ${typeof status}`);
                    
                    if (response.error) {
                        console.log(`âŒ é”™è¯¯ä¿¡æ¯: ${response.error}`);
                    }
                    
                    console.log(`ğŸ“¥ ================================\n`);
                    
                    // å…¼å®¹åç«¯è¿”å›çš„å­—æ®µåé”™è¯¯ï¼šæ”¯æŒ "status:" å’Œ "status"
                    
                    if (status === 'success') {
                        console.log(`âœ… APIå­˜å‚¨æˆåŠŸ - Chunk: ${result.chunkId}`);
                        // æˆåŠŸæ—¶æ¸…é™¤å¯èƒ½å­˜åœ¨çš„é”å®šè®°å½•
                        this.lockedTasks.delete(lockKey);
                        return true;
                    } else {
                        const errorMsg = response.error || 'Unknown API error';
                        // å¢å¼ºé”™è¯¯æ—¥å¿—ï¼Œæ˜¾ç¤ºå®Œæ•´çš„å“åº”ä¿¡æ¯
                        console.warn(`âŒ API storage failed for chunk ${result.chunkId} (attempt ${attempt}/${maxRetries}): ${errorMsg}`);
                        console.warn(`ğŸ“‹ å®Œæ•´é”™è¯¯å“åº”:`, JSON.stringify(response, null, 2));
                        
                        // å¦‚æœæ˜¯é”å®šç›¸å…³çš„é”™è¯¯ï¼Œè®°å½•é”å®šæ—¶é—´å¹¶ç»§ç»­é‡è¯•
                        if (errorMsg.includes('ä»»åŠ¡æ­£åœ¨æ‰§è¡Œ') || 
                            errorMsg.includes('é”å®š') ||
                            errorMsg.includes('locked') ||
                            errorMsg.includes('busy')) {
                            
                            this.lockedTasks.set(lockKey, Date.now());
                            lastError = new Error(`API locked: ${errorMsg}`);
                            
                            // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œç»§ç»­é‡è¯•
                            if (attempt < maxRetries) {
                                continue;
                            }
                        } else {
                            // éé”å®šé”™è¯¯ï¼Œä¸é‡è¯•
                            lastError = new Error(`API error: ${errorMsg}`);
                            break;
                        }
                    }
                    
                } catch (apiError) {
                    // ===== è¯¦ç»†å¼‚å¸¸æ—¥å¿— =====
                    console.error(`\nğŸ’¥ ===== UPSERT API å¼‚å¸¸è¯¦æƒ… =====`);
                    console.error(`ğŸ†” Request ID: ${requestId}`);
                    console.error(`ğŸ“¦ Chunk ID: ${result.chunkId}`);
                    console.error(`ğŸ”¢ å°è¯•æ¬¡æ•°: ${attempt}/${maxRetries}`);
                    console.error(`âŒ å¼‚å¸¸ç±»å‹: ${apiError.constructor.name}`);
                    console.error(`ğŸ“ å¼‚å¸¸æ¶ˆæ¯: ${apiError.message}`);
                    console.error(`ğŸ“š å¼‚å¸¸å †æ ˆ:`, apiError.stack);
                    
                    // å¦‚æœæœ‰å“åº”ç›¸å…³çš„ä¿¡æ¯
                    if (apiError.response) {
                        console.error(`ğŸ“¡ HTTPçŠ¶æ€ç : ${apiError.response.status}`);
                        console.error(`ğŸ“‹ å“åº”å¤´:`, apiError.response.headers);
                        console.error(`ğŸ“„ å“åº”ä½“:`, apiError.response.data);
                    }
                    
                    // å¦‚æœæœ‰è¯·æ±‚ç›¸å…³çš„ä¿¡æ¯
                    if (apiError.request) {
                        console.error(`ğŸ“¤ è¯·æ±‚é…ç½®:`, {
                            method: apiError.request.method,
                            url: apiError.request.url,
                            headers: apiError.request.headers,
                            timeout: apiError.request.timeout
                        });
                    }
                    
                    console.error(`ğŸ’¥ ================================\n`);
                    
                    console.error(`âŒ API storage failed for chunk ${result.chunkId} (attempt ${attempt}/${maxRetries}): ${apiError.message}`);
                    lastError = apiError;
                    
                    // ç½‘ç»œé”™è¯¯ä¹Ÿå¯èƒ½å¯¼è‡´é”å®šï¼Œè®°å½•é”å®šæ—¶é—´
                    if (apiError.message.includes('timeout') || 
                        apiError.message.includes('ECONNRESET') ||
                        apiError.message.includes('ETIMEDOUT')) {
                        
                        this.lockedTasks.set(lockKey, Date.now());
                        
                        // ç½‘ç»œé”™è¯¯æ—¶ç»§ç»­é‡è¯•
                        if (attempt < maxRetries) {
                            continue;
                        }
                    } else {
                        // éç½‘ç»œé”™è¯¯ï¼Œä¸é‡è¯•
                        break;
                    }
                }

            } catch (error) {
                console.error(`Failed to store vector for chunk ${result.chunkId} (attempt ${attempt}/${maxRetries}):`, error);
                lastError = error;
                break; // è‡´å‘½é”™è¯¯ï¼Œä¸é‡è¯•
            }
        }
        
        // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
        console.error(`Failed to store vector for chunk ${result.chunkId} after ${maxRetries} attempts. Last error:`, lastError?.message);
        return false;
    }

    async _handleBatchAsPartialFailure(batch, reason) {
        const results = [];
        for (const chunk of batch) {
            if (this.progressTracker) {
                this.progressTracker.updateChunkStatus(chunk.id, 'failed', {
                    error: reason,
                    processingMode: 'batch_failure'
                });
            }
            results.push({
                chunkId: chunk.id,
                status: 'failed',
                error: reason
            });
        }
        return results;
    }

    async _handleAsyncTimeout(requestId) {
        const pendingInfo = this.pendingAsyncResults.get(requestId);
        if (pendingInfo && this.progressTracker) {
            for (const chunk of pendingInfo.batch) {
                this.progressTracker.updateChunkStatus(chunk.id, 'timeout', {
                    requestId: requestId,
                    message: 'Async processing timeout'
                });
            }
        }
        this.pendingAsyncResults.delete(requestId);
    }

    async _handleAsyncFailure(requestId, error) {
        const pendingInfo = this.pendingAsyncResults.get(requestId);
        if (pendingInfo && this.progressTracker) {
            for (const chunk of pendingInfo.batch) {
                this.progressTracker.updateChunkStatus(chunk.id, 'failed', {
                    requestId: requestId,
                    error: error,
                    processingMode: 'async_failure'
                });
            }
        }
        this.pendingAsyncResults.delete(requestId);
    }

    _generateBatchId(batch) {
        const crypto = __webpack_require__(8);
        
        // å‚æ•°éªŒè¯
        if (!batch || !Array.isArray(batch) || batch.length === 0) {
            console.warn('Invalid batch parameter for _generateBatchId:', batch);
            // ä¸ºç©ºæ‰¹æ¬¡ç”Ÿæˆé»˜è®¤ID
            return crypto.createHash('md5').update(`empty_batch_${Date.now()}`).digest('hex').substring(0, 8);
        }
        
        try {
            const chunkIds = batch.map(chunk => chunk?.id || 'unknown').sort().join('|');
            return crypto.createHash('md5').update(chunkIds).digest('hex').substring(0, 8);
        } catch (error) {
            console.warn('Error generating batch ID:', error.message);
            // ç”Ÿæˆåå¤‡ID
            return crypto.createHash('md5').update(`fallback_batch_${Date.now()}`).digest('hex').substring(0, 8);
        }
    }

    _generateRequestId() {
        const crypto = __webpack_require__(8);
        return crypto.randomUUID();
    }

    _calculateVectorNorm(vector) {
        return Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
    }

    _extractFileName(filePath) {
        const path = __webpack_require__(4);
        return path.basename(filePath);
    }

    async sendChunks(chunks, merkleRootHash) {
        // æ³¨æ„ï¼šmerkleRootHashå‚æ•°å·²ä¸å†ä½¿ç”¨ï¼Œä¿ç•™ä»…ä¸ºå‘åå…¼å®¹
        
        // å¼€å§‹è®¡æ—¶ï¼šSenderåˆå§‹åŒ–å’Œå‡†å¤‡
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startModuleTimer('sender', 'initTime');
            this.performanceAnalyzer.recordMemoryUsage('sender_start');
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºæµ‹è¯•æ¨¡å¼ï¼Œè·³è¿‡ç½‘ç»œè¯·æ±‚
        if (process.env.NODE_ENV === 'development' && this.config.testMode !== false) {
            
            // æ›´æ–°è¿›åº¦è·Ÿè¸ªå™¨çŠ¶æ€
            if (this.progressTracker) {
                chunks.forEach(chunk => {
                    this.progressTracker.updateChunkStatus(chunk.id, 'completed', {
                        testMode: true,
                        skippedNetworkRequest: true,
                        timestamp: new Date().toISOString()
                    });
                });
            }
            
            return {
                totalBatches: Math.ceil(chunks.length / this.batchSize),
                successful: Math.ceil(chunks.length / this.batchSize),
                failed: 0,
                asyncPending: 0,
                completedImmediately: Math.ceil(chunks.length / this.batchSize),
                testMode: true,
                results: []
            };
        }
        
        // å¼€å§‹è®¡æ—¶ï¼šæ•°æ®å‡†å¤‡
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'initTime');
            this.performanceAnalyzer.startModuleTimer('sender', 'prepareTime');
        }
        
        const batches = [];
        for (let i = 0; i < chunks.length; i += this.batchSize) {
            batches.push(chunks.slice(i, i + this.batchSize));
        }
        
        // ç»“æŸæ•°æ®å‡†å¤‡ï¼Œå¼€å§‹å‘é€
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'prepareTime');
            this.performanceAnalyzer.startModuleTimer('sender', 'sendTime');
        }

        // å¹¶å‘å‘é€æ‰€æœ‰æ‰¹æ¬¡ï¼Œä½†æ§åˆ¶å¹¶å‘æ•°
        const maxConcurrentBatches = this.config.maxConcurrentBatches || 3;
        const results = [];
        
        for (let i = 0; i < batches.length; i += maxConcurrentBatches) {
            const currentBatches = batches.slice(i, i + maxConcurrentBatches);
            const batchPromises = currentBatches.map(batch => this._sendBatch(batch));
            const batchResults = await Promise.allSettled(batchPromises);
            results.push(...batchResults);
        }

        // ç»Ÿè®¡ç»“æœ
        const successfulBatches = results.filter(r => r.status === 'fulfilled');
        const failedBatches = results.filter(r => r.status === 'rejected');
        const asyncBatches = successfulBatches.filter(r => r.value.status === 'accepted');
        const completedBatches = successfulBatches.filter(r => r.value.status === 'completed');



        if (failedBatches.length > 0) {
            console.warn(`${failedBatches.length} batches failed to send`);
            failedBatches.forEach((failure, index) => {
                console.error(`ğŸ”¥ Batch ${index} failure:`, failure.reason?.message || failure.reason);
                console.error(`ğŸ”¥ Batch ${index} detailed error:`, {
                    name: failure.reason?.name,
                    message: failure.reason?.message,
                    stack: failure.reason?.stack,
                    embeddingError: failure.reason?.embeddingError
                });
            });
        }

        // ç»“æŸå‘é€è®¡æ—¶ï¼Œå¼€å§‹æ‰¹å¤„ç†è®¡æ—¶
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'sendTime');
            this.performanceAnalyzer.startModuleTimer('sender', 'batchTime');
        }

        // è®°å½•embeddingç”Ÿæˆå®Œæˆç»Ÿè®¡
        if (this.performanceAnalyzer) {
            const totalRequests = batches.length;
            const successRequests = successfulBatches.length;
            const failedRequests = failedBatches.length;
            this.performanceAnalyzer.endEmbeddingGeneration(totalRequests, successRequests, failedRequests);
        }

        // æ•°æ®å·²ç›´æ¥å‘é€åˆ°å‘é‡æ•°æ®åº“ï¼Œæ— éœ€é¢å¤–æŒä¹…åŒ–
        
        // ç»“æŸæ‰¹å¤„ç†è®¡æ—¶
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'batchTime');
            this.performanceAnalyzer.recordMemoryUsage('sender_end');
        }

        return {
            totalBatches: batches.length,
            successful: successfulBatches.length,
            failed: failedBatches.length,
            asyncPending: asyncBatches.length,
            completedImmediately: completedBatches.length,
            pendingAsyncRequests: Array.from(this.pendingAsyncResults.keys()),
            results: results
        };
    }

    async getPendingAsyncResults() {
        return Array.from(this.pendingAsyncResults.entries()).map(([requestId, info]) => ({
            requestId,
            chunkCount: info.batch.length,
            submittedAt: new Date(info.submittedAt).toISOString(),
            estimatedTime: info.estimatedTime,
            callbackUrl: info.callbackUrl
        }));
    }

    async shutdown() {
        // ç­‰å¾…æ‰€æœ‰å¼‚æ­¥ç»“æœå®Œæˆæˆ–è¶…æ—¶
        if (this.pendingAsyncResults.size > 0) {
            const timeout = this.asyncTimeout;
            const startTime = Date.now();
            
            while (this.pendingAsyncResults.size > 0 && (Date.now() - startTime) < timeout) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            if (this.pendingAsyncResults.size > 0) {
                console.warn(`Shutdown with ${this.pendingAsyncResults.size} pending async results remaining`);
            }
        }

        // åœæ­¢é”å®šæ¸…ç†å®šæ—¶å™¨
        if (this.lockCleanupInterval) {
            clearInterval(this.lockCleanupInterval);
            this.lockCleanupInterval = null;
        }

        if (this.vectorManager) {
            await this.vectorManager.shutdown();
        }
    }

    /**
     * æ¸…ç†è¿‡æœŸçš„é”å®šè®°å½•
     */
    _cleanupExpiredLocks() {
        const now = Date.now();
        const expiredKeys = [];
        
        for (const [key, timestamp] of this.lockedTasks) {
            if (now - timestamp >= this.lockDuration) {
                expiredKeys.push(key);
            }
        }
        
        expiredKeys.forEach(key => {
            this.lockedTasks.delete(key);
        });
        

    }

    /**
     * è·å–å½“å‰é”å®šçŠ¶æ€
     */
    getLockStatus() {
        const now = Date.now();
        const activeLocks = [];
        
        for (const [key, timestamp] of this.lockedTasks) {
            const timeElapsed = now - timestamp;
            if (timeElapsed < this.lockDuration) {
                const remainingTime = this.lockDuration - timeElapsed;
                activeLocks.push({
                    key: key,
                    remainingSeconds: Math.round(remainingTime / 1000)
                });
            }
        }
        
        return {
            totalLocks: activeLocks.length,
            locks: activeLocks
        };
    }

    /**
     * æ‰‹åŠ¨æ¸…é™¤ç‰¹å®šä»»åŠ¡çš„é”å®š
     */
    clearLock(chunkId) {
        const lockKey = `${chunkId}_${this.config.userId}_${this.config.deviceId}`;
        const wasLocked = this.lockedTasks.has(lockKey);
        this.lockedTasks.delete(lockKey);
        

        
        return wasLocked;
    }
}

module.exports = Sender;

/***/ }),
/* 148 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*! Axios v1.10.0 Copyright (c) 2025 Matt Zabriskie and contributors */


const FormData$1 = __webpack_require__(149);
const crypto = __webpack_require__(8);
const url = __webpack_require__(154);
const proxyFromEnv = __webpack_require__(205);
const http = __webpack_require__(152);
const https = __webpack_require__(153);
const util = __webpack_require__(20);
const followRedirects = __webpack_require__(206);
const zlib = __webpack_require__(218);
const stream = __webpack_require__(18);
const events = __webpack_require__(219);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
const crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
const url__default = /*#__PURE__*/_interopDefaultLegacy(url);
const proxyFromEnv__default = /*#__PURE__*/_interopDefaultLegacy(proxyFromEnv);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);
const https__default = /*#__PURE__*/_interopDefaultLegacy(https);
const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
const followRedirects__default = /*#__PURE__*/_interopDefaultLegacy(followRedirects);
const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData__default["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (utils$1.isBoolean(value)) {
      return value.toString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const InterceptorManager$1 = InterceptorManager;

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams = url__default["default"].URLSearchParams;

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  const randomValues = new Uint32Array(size);
  crypto__default["default"].randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }

  return str;
};


const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData__default["default"],
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: [ 'http', 'https', 'file', 'data' ]
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

const utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv,
  navigator: _navigator,
  origin: origin
});

const platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

const defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders);

const AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const VERSION = "1.10.0";

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}

const kInternals = Symbol('internals');

class AxiosTransformStream extends stream__default["default"].Transform{
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

const AxiosTransformStream$1 = AxiosTransformStream;

const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};

const readBlob$1 = readBlob;

const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util__default["default"].TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils$1.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils$1.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils$1.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

const formDataToStream$1 = formDataToStream;

class ZlibHeaderTransformStream extends stream__default["default"].Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;

const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};

const callbackify$1 = callbackify;

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

const zlibOptions = {
  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
};

const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = followRedirects__default["default"];

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
};

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils$1.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
};

const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new events.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    };

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__default["default"].Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders$1(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError(
        'Unsupported protocol ' + protocol,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = AxiosHeaders$1.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = formDataToStream$1(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__default["default"].promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__default["default"].Readable.from(readBlob$1(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          'Request body larger than maxBodyLength limit',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());

    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream__default["default"].Readable.from(data, {objectMode: false});
      }

      data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new ZlibHeaderTransformStream$1());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];

      const offListeners = stream__default["default"].finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new AxiosError(
            'stream has been aborted',
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          'error trying to parse `config.timeout` to int',
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;

const cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$1.asap(unsubscribe);

    return signal;
  }
};

const composeSignals$1 = composeSignals;

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request, fetchOptions);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

const adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

const Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

const CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

const HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

module.exports = axios;
//# sourceMappingURL=axios.cjs.map


/***/ }),
/* 149 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CombinedStream = __webpack_require__(150);
var util = __webpack_require__(20);
var path = __webpack_require__(4);
var http = __webpack_require__(152);
var https = __webpack_require__(153);
var parseUrl = (__webpack_require__(154).parse);
var fs = __webpack_require__(5);
var Stream = (__webpack_require__(18).Stream);
var mime = __webpack_require__(155);
var asynckit = __webpack_require__(158);
var setToStringTag = __webpack_require__(168);
var hasOwn = __webpack_require__(202);
var populate = __webpack_require__(204);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {}; // eslint-disable-line no-param-reassign
  for (var option in options) { // eslint-disable-line no-restricted-syntax
    this[option] = options[option];
  }
}

// make it a Stream
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function (field, value, options) {
  options = options || {}; // eslint-disable-line no-param-reassign

  // allow filename as single option
  if (typeof options === 'string') {
    options = { filename: options }; // eslint-disable-line no-param-reassign
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value === 'number' || value == null) {
    value = String(value); // eslint-disable-line no-param-reassign
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (Array.isArray(value)) {
    /*
     * Please convert your array into string
     * the way web server expects it
     */
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function (header, value, options) {
  var valueLength = 0;

  /*
   * used w/ getLengthSync(), when length is known.
   * e.g. for streaming directly from a remote server,
   * w/ a known file a size, and not wanting to wait for
   * incoming file to finish to get its size.
   */
  if (options.knownLength != null) {
    valueLength += Number(options.knownLength);
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || (!value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function (value, callback) {
  if (hasOwn(value, 'fd')) {
    // take read range into a account
    // `end` = Infinity â€“> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {
      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return

      // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function (err, stat) {
        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        var fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

    // or http response
  } else if (hasOwn(value, 'httpVersion')) {
    callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return

    // or request stream http://github.com/mikeal/request
  } else if (hasOwn(value, 'httpModule')) {
    // wait till response come back
    value.on('response', function (response) {
      value.pause();
      callback(null, Number(response.headers['content-length']));
    });
    value.resume();

    // something else
  } else {
    callback('Unknown stream'); // eslint-disable-line callback-return
  }
};

FormData.prototype._multiPartHeader = function (field, value, options) {
  /*
   * custom header specified (as string)?
   * it becomes responsible for boundary
   * (e.g. to handle extra CRLFs on .NET servers)
   */
  if (typeof options.header === 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header === 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) { // eslint-disable-line no-restricted-syntax
    if (hasOwn(headers, prop)) {
      header = headers[prop];

      // skip nullish headers.
      if (header == null) {
        continue; // eslint-disable-line no-restricted-syntax, no-continue
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header];
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function (value, options) { // eslint-disable-line consistent-return
  var filename;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || (value && (value.name || value.path))) {
    /*
     * custom filename take precedence
     * formidable and the browser add a name property
     * fs- and request- streams have path property
     */
    filename = path.basename(options.filename || (value && (value.name || value.path)));
  } else if (value && value.readable && hasOwn(value, 'httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    return 'filename="' + filename + '"';
  }
};

FormData.prototype._getContentType = function (value, options) {
  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && value && typeof value === 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function () {
  return function (next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function () {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function (userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) { // eslint-disable-line no-restricted-syntax
    if (hasOwn(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function (boundary) {
  if (typeof boundary !== 'string') {
    throw new TypeError('FormData boundary must be a string');
  }
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function () {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function () {
  var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {
      // Add content to the buffer.
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};

FormData.prototype._generateBoundary = function () {
  // This generates a 50 character boundary similar to those used by Firefox.

  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually and add it as knownLength option
FormData.prototype.getLengthSync = function () {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    /*
     * Some async length retrievers are present
     * therefore synchronous length calculation is false.
     * Please use getLength(callback) to get proper length
     */
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function () {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function (cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function (length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function (params, cb) {
  var request;
  var options;
  var defaults = { method: 'post' };

  // parse provided url if it's string or treat it as options object
  if (typeof params === 'string') {
    params = parseUrl(params); // eslint-disable-line no-param-reassign
    /* eslint sort-keys: 0 */
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);
  } else { // use custom params
    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol === 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol === 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function (err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce); // eslint-disable-line no-invalid-this
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function (err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
setToStringTag(FormData, 'FormData');

// Public API
module.exports = FormData;


/***/ }),
/* 150 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(20);
var Stream = (__webpack_require__(18).Stream);
var DelayedStream = __webpack_require__(151);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),
/* 151 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(18).Stream);
var util = __webpack_require__(20);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),
/* 152 */
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),
/* 153 */
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),
/* 154 */
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(156)
var extname = (__webpack_require__(4).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),
/* 156 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(157)


/***/ }),
/* 157 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),
/* 158 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(159),
  serial        : __webpack_require__(166),
  serialOrdered : __webpack_require__(167)
};


/***/ }),
/* 159 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(160)
  , initState  = __webpack_require__(164)
  , terminator = __webpack_require__(165)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),
/* 160 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(161)
  , abort = __webpack_require__(163)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),
/* 161 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(162);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),
/* 162 */
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),
/* 163 */
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),
/* 164 */
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),
/* 165 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(163)
  , async = __webpack_require__(161)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),
/* 166 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(167);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),
/* 167 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(160)
  , initState  = __webpack_require__(164)
  , terminator = __webpack_require__(165)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),
/* 168 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(169);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasToStringTag = __webpack_require__(203)();
var hasOwn = __webpack_require__(202);
var $TypeError = __webpack_require__(176);

var toStringTag = hasToStringTag ? Symbol.toStringTag : null;

/** @type {import('.')} */
module.exports = function setToStringTag(object, value) {
	var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
	var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
	if (
		(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')
		|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
	) {
		throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
	}
	if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
		if ($defineProperty) {
			$defineProperty(object, toStringTag, {
				configurable: !nonConfigurable,
				enumerable: false,
				value: value,
				writable: false
			});
		} else {
			object[toStringTag] = value; // eslint-disable-line no-param-reassign
		}
	}
};


/***/ }),
/* 169 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(170);

var $Error = __webpack_require__(171);
var $EvalError = __webpack_require__(172);
var $RangeError = __webpack_require__(173);
var $ReferenceError = __webpack_require__(174);
var $SyntaxError = __webpack_require__(175);
var $TypeError = __webpack_require__(176);
var $URIError = __webpack_require__(177);

var abs = __webpack_require__(178);
var floor = __webpack_require__(179);
var max = __webpack_require__(180);
var min = __webpack_require__(181);
var pow = __webpack_require__(182);
var round = __webpack_require__(183);
var sign = __webpack_require__(184);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(186);
var $defineProperty = __webpack_require__(188);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(189)();

var getProto = __webpack_require__(191);
var $ObjectGPO = __webpack_require__(193);
var $ReflectGPO = __webpack_require__(192);

var $apply = __webpack_require__(200);
var $call = __webpack_require__(198);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(196);
var hasOwn = __webpack_require__(202);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),
/* 170 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),
/* 171 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),
/* 172 */
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),
/* 173 */
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),
/* 174 */
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),
/* 175 */
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),
/* 176 */
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),
/* 177 */
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),
/* 178 */
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),
/* 179 */
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),
/* 180 */
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),
/* 181 */
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),
/* 182 */
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),
/* 183 */
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),
/* 184 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(185);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),
/* 185 */
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),
/* 186 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(187);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),
/* 187 */
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),
/* 188 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),
/* 189 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(190);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),
/* 190 */
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 191 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(192);
var originalGetProto = __webpack_require__(193);

var getDunderProto = __webpack_require__(194);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),
/* 192 */
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),
/* 193 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(170);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),
/* 194 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(195);
var gOPD = __webpack_require__(186);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),
/* 195 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(196);
var $TypeError = __webpack_require__(176);

var $call = __webpack_require__(198);
var $actualApply = __webpack_require__(199);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),
/* 196 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(197);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 197 */
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 198 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),
/* 199 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(196);

var $apply = __webpack_require__(200);
var $call = __webpack_require__(198);
var $reflectApply = __webpack_require__(201);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),
/* 200 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),
/* 201 */
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(196);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),
/* 203 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(190);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),
/* 204 */
/***/ ((module) => {

"use strict";


// populates missing values
module.exports = function (dst, src) {
  Object.keys(src).forEach(function (prop) {
    dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign
  });

  return dst;
};


/***/ }),
/* 205 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var parseUrl = (__webpack_require__(154).parse);

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),
/* 206 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(154);
var URL = url.URL;
var http = __webpack_require__(152);
var https = __webpack_require__(153);
var Writable = (__webpack_require__(18).Writable);
var assert = __webpack_require__(21);
var debug = __webpack_require__(207);

// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
}());

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL(""));
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC7230Â§5.3.1: When making a request directly to an origin server, [â€¦]
  // a client MUST send only the absolute path [â€¦] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, [â€¦]
    // a client MUST send the target URI in absolute-form [â€¦].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      // istanbul ignore else
      if (request === self._currentRequest) {
        // Report any write errors
        // istanbul ignore if
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          // istanbul ignore else
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231Â§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC7231Â§6.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC7231Â§6.4: Automatic redirection needs to done with
  // care for methods not known to be safe, [â€¦]
  // RFC7231Â§6.4.2â€“3: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC7231Â§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource [â€¦]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) [â€¦]
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  // istanbul ignore else
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  // istanbul ignore next
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    // istanbul ignore else
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),
/* 207 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(208)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(209);
} else {
	module.exports = __webpack_require__(212);
}


/***/ }),
/* 209 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(210)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 210 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(211);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(/\s+/g, ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 211 */
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 212 */
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(213);
const util = __webpack_require__(20);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(214);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(210)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),
/* 213 */
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),
/* 214 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSupportsColor: () => (/* binding */ createSupportsColor),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(215);
/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(216);
/* harmony import */ var node_tty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(217);




// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : node_process__WEBPACK_IMPORTED_MODULE_0__.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = node_process__WEBPACK_IMPORTED_MODULE_0__;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = node_os__WEBPACK_IMPORTED_MODULE_1__.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {
			return 3;
		}

		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(1)}),
	stderr: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(2)}),
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supportsColor);


/***/ }),
/* 215 */
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),
/* 216 */
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),
/* 217 */
/***/ ((module) => {

"use strict";
module.exports = require("node:tty");

/***/ }),
/* 218 */
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),
/* 219 */
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),
/* 220 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);

class ProgressTracker {
    constructor() {
        this.chunks = new Map();
        this.fileProgress = new Map();
        
        // æ–°å¢ï¼šæ–‡ä»¶çº§åˆ«è·Ÿè¸ª
        this.fileStatus = new Map(); // filePath -> 'pending'|'processing'|'completed'|'failed'
        this.totalFiles = 0;
        this.completedFiles = 0;
        this.processingFiles = 0;
        this.failedFiles = 0;
    }

    registerChunk(chunkId, metadata) {
        if (!this.chunks.has(chunkId)) {
            const chunkInfo = {
                chunkId,
                filePath: metadata.filePath,
                language: this._detectLanguage(metadata.filePath),
                startLine: metadata.startLine,
                endLine: metadata.endLine,
                content: metadata.content || '',
                parser: metadata.parser || this._getDefaultParser(metadata.filePath),
                type: metadata.type || 'unknown',
                registeredAt: Date.now(),
                status: 'pending',
                startTime: Date.now(),
                endTime: null,
                retries: 0,
                metadata: metadata
            };

            this.chunks.set(chunkId, chunkInfo);
            
            // åˆå§‹åŒ–æ–‡ä»¶è¿›åº¦
            const filePath = metadata.filePath;
            if (!this.fileProgress.has(filePath)) {
                this.fileProgress.set(filePath, {
                    total: 0,
                    pending: 0,
                    processing: 0,
                    completed: 0,
                    failed: 0,
                    language: chunkInfo.language
                });
            }
            
            const fileStats = this.fileProgress.get(filePath);
            fileStats.total++;
            fileStats.pending++;
        }
    }

    _detectLanguage(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const languageMap = {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c',
            '.go': 'go',
            '.rs': 'rust',
            '.php': 'php',
            '.rb': 'ruby',
            '.swift': 'swift',
            '.kt': 'kotlin',
            '.scala': 'scala',
            '.hs': 'haskell',
            '.lua': 'lua',
            '.pl': 'perl',
            '.sh': 'shell',
            '.sql': 'sql',
            '.html': 'html',
            '.css': 'css',
            '.json': 'json',
            '.xml': 'xml',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.md': 'markdown'
        };
        return languageMap[ext] || 'unknown';
    }

    _getDefaultParser(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const parserMap = {
            '.py': 'python_parser',
            '.js': 'javascript_parser',
            '.ts': 'typescript_parser',
            '.java': 'java_parser',
            '.cpp': 'cpp_parser',
            '.c': 'c_parser',
            '.go': 'go_parser',
            '.rs': 'rust_parser',
            '.php': 'php_parser',
            '.rb': 'ruby_parser',
            '.swift': 'swift_parser',
            '.kt': 'kotlin_parser',
            '.scala': 'scala_parser',
            '.hs': 'haskell_parser',
            '.lua': 'lua_parser',
            '.pl': 'perl_parser',
            '.sh': 'shell_parser',
            '.sql': 'sql_parser',
            '.html': 'html_parser',
            '.css': 'css_parser',
            '.json': 'json_parser',
            '.xml': 'xml_parser',
            '.yaml': 'yaml_parser',
            '.yml': 'yaml_parser',
            '.md': 'markdown_parser'
        };
        return parserMap[ext] || 'default_parser';
    }

    updateChunkStatus(chunkId, status) {
        const chunk = this.chunks.get(chunkId);
        if (!chunk) {
            console.warn(`Chunk ${chunkId} not found in progress tracker`);
            return;
        }

        const oldStatus = chunk.status;
        chunk.status = status;
        chunk.endTime = ['completed', 'failed'].includes(status) ? Date.now() : null;
        
        if (status === 'processing') {
            chunk.retries++;
        }
        
        // æ›´æ–°æ–‡ä»¶è¿›åº¦
        const filePath = chunk.filePath;
        const fileStats = this.fileProgress.get(filePath);
        
        // å‡å°‘æ—§çŠ¶æ€çš„è®¡æ•°
        if (oldStatus) {
            fileStats[oldStatus]--;
        }
        
        // å¢åŠ æ–°çŠ¶æ€çš„è®¡æ•°
        fileStats[status]++;
        
        // æ–°å¢ï¼šè‡ªåŠ¨æ›´æ–°æ–‡ä»¶çº§åˆ«çš„çŠ¶æ€
        this._updateFileStatusByChunks();
    }

    getOverallProgress() {
        let pendingChunks = 0;
        let processingChunks = 0;
        let completedChunks = 0;
        let failedChunks = 0;
        let totalChunks = this.chunks.size;

        for (const chunk of this.chunks.values()) {
            switch (chunk.status) {
                case 'pending':
                    pendingChunks++;
                    break;
                case 'processing':
                    processingChunks++;
                    break;
                case 'completed':
                    completedChunks++;
                    break;
                case 'failed':
                    failedChunks++;
                    break;
            }
        }

        return {
            pendingChunks,
            processingChunks,
            completedChunks,
            failedChunks,
            totalChunks,
            successRate: totalChunks > 0 ? (completedChunks / totalChunks) * 100 : 0
        };
    }

    getFileProgressSummary() {
        const summary = [];
        for (const [file, stats] of this.fileProgress.entries()) {
            summary.push({
                file: path.basename(file),
                language: stats.language,
                pending: stats.pending,
                processing: stats.processing,
                completed: stats.completed,
                failed: stats.failed,
                total: stats.total,
                successRate: stats.total > 0 ? (stats.completed / stats.total) * 100 : 0
            });
        }
        return summary;
    }

    getChunkDetails(chunkId) {
        return this.chunks.get(chunkId);
    }

    getAllChunks() {
        return Array.from(this.chunks.values());
    }

    getChunksByStatus(status) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.status === status);
    }

    getChunksByFile(filePath) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.filePath === filePath);
    }

    getChunksByLanguage(language) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.language === language);
    }

    getChunksByType(type) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.type === type);
    }

    // æ–°å¢ï¼šæ–‡ä»¶çº§åˆ«çš„è¿›åº¦è·Ÿè¸ªæ–¹æ³•
    
    /**
     * æ³¨å†Œæ–‡ä»¶åˆ°è¿›åº¦è·Ÿè¸ªå™¨
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     */
    registerFile(filePath) {
        if (!this.fileStatus.has(filePath)) {
            this.fileStatus.set(filePath, 'pending');
            this.totalFiles++;
        }
    }

    /**
     * æ‰¹é‡æ³¨å†Œæ–‡ä»¶
     * @param {Array} fileList - æ–‡ä»¶è·¯å¾„æ•°ç»„
     */
    registerFiles(fileList) {
        fileList.forEach(filePath => {
            this.registerFile(filePath);
        });
    }

    /**
     * æ›´æ–°æ–‡ä»¶å¤„ç†çŠ¶æ€
     * @param {string} filePath - æ–‡ä»¶è·¯å¾„
     * @param {string} status - çŠ¶æ€ï¼š'pending'|'processing'|'completed'|'failed'
     */
    updateFileStatus(filePath, status) {
        const oldStatus = this.fileStatus.get(filePath);
        
        if (oldStatus) {
            // å‡å°‘æ—§çŠ¶æ€çš„è®¡æ•°
            switch (oldStatus) {
                case 'processing':
                    this.processingFiles = Math.max(0, this.processingFiles - 1);
                    break;
                case 'completed':
                    this.completedFiles = Math.max(0, this.completedFiles - 1);
                    break;
                case 'failed':
                    this.failedFiles = Math.max(0, this.failedFiles - 1);
                    break;
            }
        }
        
        // è®¾ç½®æ–°çŠ¶æ€
        this.fileStatus.set(filePath, status);
        
        // å¢åŠ æ–°çŠ¶æ€çš„è®¡æ•°
        switch (status) {
            case 'processing':
                this.processingFiles++;
                break;
            case 'completed':
                this.completedFiles++;
                break;
            case 'failed':
                this.failedFiles++;
                break;
        }
    }

    /**
     * è·å–æ–‡ä»¶çº§åˆ«çš„å¤„ç†è¿›åº¦
     * @returns {Object} åŒ…å«æ–‡ä»¶å¤„ç†è¿›åº¦çš„å¯¹è±¡
     */
    getFileProgress() {
        return {
            totalFiles: this.totalFiles,
            completedFiles: this.completedFiles,
            processingFiles: this.processingFiles,
            failedFiles: this.failedFiles,
            pendingFiles: this.totalFiles - this.completedFiles - this.processingFiles - this.failedFiles,
            progressPercentage: this.totalFiles > 0 ? (this.completedFiles / this.totalFiles) * 100 : 0
        };
    }

    /**
     * è·å–æ–‡ä»¶å¤„ç†è¿›åº¦ç™¾åˆ†æ¯”ï¼ˆ0-100æµ®ç‚¹æ•°ï¼‰
     * @returns {number} è¿›åº¦ç™¾åˆ†æ¯”
     */
    getFileProgressPercentage() {
        return this.totalFiles > 0 ? (this.completedFiles / this.totalFiles) * 100 : 0;
    }

    /**
     * è·å–æ‰€æœ‰æ–‡ä»¶çš„çŠ¶æ€è¯¦æƒ…
     * @returns {Array} æ–‡ä»¶çŠ¶æ€è¯¦æƒ…æ•°ç»„
     */
    getFileStatusDetails() {
        const details = [];
        for (const [filePath, status] of this.fileStatus.entries()) {
            details.push({
                filePath,
                status,
                language: this._detectLanguage(filePath)
            });
        }
        return details;
    }

    /**
     * æ ¹æ®æ–‡ä»¶ä¸­çš„chunksæ¥è‡ªåŠ¨æ›´æ–°æ–‡ä»¶çŠ¶æ€
     * å½“æ–‡ä»¶ä¸­æ‰€æœ‰chunkséƒ½å®Œæˆæ—¶ï¼Œæ–‡ä»¶çŠ¶æ€è‡ªåŠ¨å˜ä¸ºcompleted
     */
    _updateFileStatusByChunks() {
        const fileChunkStatus = new Map();
        
        // ç»Ÿè®¡æ¯ä¸ªæ–‡ä»¶çš„chunkçŠ¶æ€
        for (const chunk of this.chunks.values()) {
            const filePath = chunk.filePath;
            if (!fileChunkStatus.has(filePath)) {
                fileChunkStatus.set(filePath, {
                    total: 0,
                    completed: 0,
                    failed: 0,
                    processing: 0
                });
            }
            
            const fileStats = fileChunkStatus.get(filePath);
            fileStats.total++;
            
            switch (chunk.status) {
                case 'completed':
                    fileStats.completed++;
                    break;
                case 'failed':
                    fileStats.failed++;
                    break;
                case 'processing':
                    fileStats.processing++;
                    break;
            }
        }
        
        // æ ¹æ®chunkçŠ¶æ€æ›´æ–°æ–‡ä»¶çŠ¶æ€
        for (const [filePath, stats] of fileChunkStatus.entries()) {
            let newFileStatus = 'pending';
            
            if (stats.processing > 0) {
                newFileStatus = 'processing';
            } else if (stats.completed === stats.total) {
                newFileStatus = 'completed';
            } else if (stats.failed > 0 && stats.completed + stats.failed === stats.total) {
                newFileStatus = 'failed';
            }
            
            const currentStatus = this.fileStatus.get(filePath);
            if (currentStatus !== newFileStatus) {
                this.updateFileStatus(filePath, newFileStatus);
            }
        }
    }
}

module.exports = ProgressTracker; 

/***/ }),
/* 221 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const VectorManager = __webpack_require__(222);

module.exports = VectorManager;

/***/ }),
/* 222 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const VectorDB = __webpack_require__(223);
const EmbeddingClient = __webpack_require__(231);
const PathEncryption = __webpack_require__(232);
const Logger = __webpack_require__(225);
const Validator = __webpack_require__(235);
const RetryHelper = __webpack_require__(230);
const TencentVectorDB = __webpack_require__(226);
const TencentVectorDBAdapter = __webpack_require__(236);
const { createCollectionName } = __webpack_require__(229);

class VectorManager {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('VectorManager', config.logLevel);
        this.validator = new Validator();
        this.retryHelper = new RetryHelper(config.retry);
        
        // æ ¸å¿ƒç»„ä»¶
        this.vectorDB = null;
        this.embeddingClient = null;
        this.pathEncryption = null;
        
        // çŠ¶æ€ç®¡ç†
        this.isInitialized = false;
        this.isShuttingDown = false;
        this.uploadInProgress = new Set(); // è·Ÿè¸ªæ­£åœ¨ä¸Šä¼ çš„ comboKey
        
        // ä¸´æ—¶å­˜å‚¨ï¼ˆç”¨äºå¼€å‘æ¨¡å¼ï¼Œæ›¿ä»£ç¼“å­˜ï¼‰
        this.tempVectors = new Map();
    }

    async initialize() {
        if (this.isInitialized) {
            this.logger.warn('VectorManager is already initialized');
            return;
        }

        try {
            this.logger.info('Initializing VectorManager...');
            
            // æ£€æŸ¥æ˜¯å¦é…ç½®äº†æ•°æ®åº“ä¸”ä¸æ˜¯localç±»å‹
            const shouldInitFullMode = this.config.database && 
                                     this.config.database.type !== 'local' && 
                                     this.config.database.type !== 'disabled';
            
            // åœ¨å¼€å‘å’Œæµ‹è¯•ç¯å¢ƒä¸­ç®€åŒ–åˆå§‹åŒ–ï¼Œä½†å¦‚æœé…ç½®äº†åœ¨çº¿æ•°æ®åº“åˆ™å®Œæ•´åˆå§‹åŒ–
            if ((process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') && !shouldInitFullMode) {
                this.logger.info('Development mode: simplified VectorManager initialization');
                
                // æœ€å°åŒ–åˆå§‹åŒ–
                if (this.config.embedding) {
                this.embeddingClient = new EmbeddingClient(this.config.embedding);
                this.logger.info('EmbeddingClient initialized');
                }
                
                // è·³è¿‡å…¶ä»–å¤æ‚ç»„ä»¶çš„åˆå§‹åŒ–
                this.pathEncryption = null;
                this.vectorDB = null;
                
            } else {
                // ç”Ÿäº§ç¯å¢ƒæˆ–åœ¨çº¿æ¨¡å¼å®Œæ•´åˆå§‹åŒ–
                this.logger.info('Production mode: full VectorManager initialization');
                
                try {
                    // 1. åˆå§‹åŒ–å®‰å…¨æ¨¡å—
                    if (this.config.security && this.config.security.enabled) {
                        this.pathEncryption = new PathEncryption(this.config.security);
                        await this.pathEncryption.initialize();
                        this.logger.info('PathEncryption initialized');
                    } else {
                        this.logger.info('PathEncryption disabled, using passthrough mode');
                        this.pathEncryption = new PathEncryption({ enabled: false });
                        await this.pathEncryption.initialize();
                    }
                    
                    // 2. è·³è¿‡æ•°æ®åº“è¿æ¥åˆå§‹åŒ– - åªä½¿ç”¨APIæ¥å£
                    if (this.config.database && this.config.database.enabled && this.config.database.type !== 'api_only') {
                        // æ ¹æ®é…ç½®ç±»å‹é€‰æ‹©ä¸åŒçš„æ•°æ®åº“å®ç°
                        if (this.config.database.type === 'tencent_vectordb') {
                            // ä½¿ç”¨è…¾è®¯äº‘å‘é‡æ•°æ®åº“é€‚é…å™¨
                            this.vectorDB = new TencentVectorDBAdapter(this.config.database);
                            await this.vectorDB.initialize();
                            this.logger.info('Tencent VectorDB Adapter initialized');
                        } else if (this.config.database.type === 'tencent_cloud') {
                            // ä½¿ç”¨é»˜è®¤VectorDBå®ç°
                            this.vectorDB = new VectorDB(this.config.database);
                            await this.vectorDB.initialize();
                            this.logger.info('VectorDB initialized with Tencent Cloud');
                        }
                    } else {
                        this.logger.info('Database disabled or API-only mode, skipping VectorDB initialization');
                        this.vectorDB = null;
                    }
                    
                    // 3. åˆå§‹åŒ–åµŒå…¥æœåŠ¡å®¢æˆ·ç«¯
                    if (this.config.embedding) {
                    this.embeddingClient = new EmbeddingClient(this.config.embedding);
                    this.logger.info('EmbeddingClient initialized');
                    }
                    
                    // 4. æ³¨å†Œæ¸…ç†å›è°ƒ
                    this._registerCleanupHandlers();
                    
                } catch (error) {
                    this.logger.error('Failed to initialize production components, falling back to simplified mode:', error);
                    
                    // é™çº§åˆ°ç®€åŒ–æ¨¡å¼ï¼Œä½†ä»å°è¯•åˆå§‹åŒ–åŸºç¡€ç»„ä»¶
                    this.pathEncryption = new PathEncryption({ enabled: false });
                    await this.pathEncryption.initialize();
                    this.vectorDB = null;
                    
                    // å°è¯•åˆå§‹åŒ–åµŒå…¥å®¢æˆ·ç«¯
                    try {
                        if (this.config.embedding) {
                        this.embeddingClient = new EmbeddingClient(this.config.embedding);
                        this.logger.info('EmbeddingClient initialized in fallback mode');
                        }
                    } catch (embeddingError) {
                        this.logger.warn('Failed to initialize EmbeddingClient in fallback mode:', embeddingError);
                        this.embeddingClient = null;
                    }
                    
                    // å¯ç”¨ä¸´æ—¶å­˜å‚¨æœºåˆ¶
                    this.tempVectors = new Map();
                    this.logger.info('Temporary vector storage enabled for fallback mode');
                }
            }
            
            this.isInitialized = true;
            this.logger.info('VectorManager initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize VectorManager:', error);
            await this._cleanup();
            throw error;
        }
    }

    async addVector(data) {
        if (!this.isInitialized) {
            throw new Error('VectorManager not initialized');
        }
        
        if (this.isShuttingDown) {
            console.warn(`VectorManager is shutting down, skipping vector ${data.chunkId}`);
            return false;
        }
        
        try {
            // 1. æ•°æ®éªŒè¯
            this._validateVectorData(data);
            
            // 2. ç”Ÿæˆç»„åˆé”®
            const comboKey = this._generateComboKey(data.userId, data.deviceId, data.workspacePath);
            
            // 3. å¦‚æœæœ‰vectorDBï¼Œç›´æ¥ä¸Šä¼ ï¼›å¦åˆ™å­˜å‚¨åˆ°ä¸´æ—¶ä½ç½®
            if (this.vectorDB) {
                // ç¡®ä¿ç›®æ ‡é›†åˆå­˜åœ¨
                await this._ensureCollectionExists(comboKey);
                
                // ç›´æ¥ä¸Šä¼ åˆ°å‘é‡æ•°æ®åº“
                const vectorData = {
                    id: data.chunkId,
                    vector: data.vector,
                    user_id: data.userId || 'unknown',
                    device_id: data.deviceId || 'unknown',
                    workspace_path: data.workspacePath || 'unknown',
                    file_path: this.pathEncryption ? this.pathEncryption.encryptPath(data.filePath) : data.filePath,
                    code: data.content || data.code || '',
                    start_line: data.startLine || data.start_line || 0,
                    end_line: data.endLine || data.end_line || 0,
                    vector_model: data.vector_model || 'CoCoSoDa-v1.0',
                    metadata: {
                        timestamp: Date.now(),
                        ...data.metadata
                    }
                };
                
                await this.vectorDB.upsert(comboKey, [vectorData]);
                this.logger.debug(`Added vector ${data.chunkId} directly to database for ${comboKey}`);
                return true;
            } else {
                // ä¸´æ—¶å­˜å‚¨æ¨¡å¼
                if (!this.tempVectors.has(comboKey)) {
                    this.tempVectors.set(comboKey, []);
                }
                
                const tempVector = {
                    id: data.chunkId,
                    vector: data.vector,
                    filePath: data.filePath,
                    fileName: data.fileName,
                    userId: data.userId,
                    deviceId: data.deviceId,
                    workspacePath: data.workspacePath,
                    ...data.metadata
                };
                
                this.tempVectors.get(comboKey).push(tempVector);
                this.logger.debug(`Added vector ${data.chunkId} to temporary storage for ${comboKey}`);
                return true;
            }
            
        } catch (error) {
            this.logger.error(`Error adding vector ${data.chunkId}:`, error);
            
            if (this._isCriticalError(error)) {
                throw error;
            }
            
            return false;
        }
    }

    async search(query, topK = 10, options = {}) {
        if (!this.isInitialized) {
            throw new Error('VectorManager not initialized');
        }
        
        try {
            // 1. å‚æ•°éªŒè¯
            if (!query || typeof query !== 'string') {
                throw new Error('Query must be a non-empty string');
            }
            
            if (!Number.isInteger(topK) || topK <= 0) {
                throw new Error('topK must be a positive integer');
            }
            
            // 2. ç”Ÿæˆç»„åˆé”®ï¼ˆç”¨äºé™å®šæœç´¢èŒƒå›´ï¼‰
            const comboKey = this._generateComboKey(
                options.userId, 
                options.deviceId, 
                options.workspacePath
            );
            
            // 3. å¦‚æœæ²¡æœ‰vectorDBä½†æœ‰ä¸´æ—¶å­˜å‚¨ï¼Œä½¿ç”¨ç®€å•çš„æ–‡æœ¬åŒ¹é…
            if (!this.vectorDB && this.tempVectors && this.tempVectors.has(comboKey)) {
                this.logger.debug(`Using temporary storage for search: ${comboKey}`);
                
                const vectors = this.tempVectors.get(comboKey);
                const results = vectors.filter(vector => {
                    // ç®€å•çš„æ–‡æœ¬åŒ¹é…æœç´¢
                    const content = vector.content || '';
                    const filePath = vector.filePath || '';
                    const language = vector.language || '';
                    
                    return content.toLowerCase().includes(query.toLowerCase()) ||
                           filePath.toLowerCase().includes(query.toLowerCase()) ||
                           language.toLowerCase().includes(query.toLowerCase());
                }).slice(0, topK).map((vector, index) => ({
                    chunkId: vector.id,
                    id: vector.id,
                    score: 0.9 - (index * 0.1), // æ¨¡æ‹Ÿç›¸ä¼¼åº¦åˆ†æ•°
                    similarity: 0.9 - (index * 0.1),
                    filePath: vector.filePath,
                    fileName: vector.fileName,
                    startLine: vector.startLine,
                    endLine: vector.endLine,
                    content: vector.content,
                    metadata: {
                        userId: vector.userId,
                        deviceId: vector.deviceId,
                        workspacePath: vector.workspacePath,
                        language: vector.language,
                        parser: vector.parser,
                        type: vector.type,
                        vectorModel: 'temp-storage',
                        originalScore: 0.9 - (index * 0.1)
                    }
                }));
                
                this.logger.info(`Temporary storage search completed: found ${results.length} results`);
                return results;
            }
            
            // 3. è·å–æŸ¥è¯¢å‘é‡ - æ”¯æŒå‹ç¼©å‘é‡æ ¼å¼
            const queryEmbedding = await this.retryHelper.executeWithRetry(
                () => this.embeddingClient.getEmbedding(query),
                'Getting embedding for query'
            );
            
            // å¤„ç†å‹ç¼©å‘é‡æ ¼å¼ï¼šå¦‚æœæ˜¯å‹ç¼©å‘é‡ï¼Œéœ€è¦è§£å‹ç¼©æˆ–ä½¿ç”¨å‹ç¼©å‘é‡æœç´¢
            let queryVector;
            if (queryEmbedding.isCompressed && queryEmbedding.compressedVector) {
                // å¦‚æœåç«¯æ”¯æŒå‹ç¼©å‘é‡æœç´¢ï¼Œç›´æ¥ä½¿ç”¨å‹ç¼©å‘é‡
                // å¦åˆ™è¿™é‡Œéœ€è¦è§£å‹ç¼©é€»è¾‘ï¼ˆç›®å‰æš‚æ—¶æŠ›å‡ºé”™è¯¯æé†’å¼€å‘è€…ï¼‰
                this.logger.warn('Query embedding is compressed. Current implementation requires uncompressed vectors for search.');
                // TODO: å®ç°å‹ç¼©å‘é‡çš„è§£å‹ç¼©é€»è¾‘æˆ–æ”¯æŒå‹ç¼©å‘é‡æœç´¢
                throw new Error('Compressed vector search not yet implemented. Please ensure query embedding returns uncompressed vector.');
            } else {
                queryVector = queryEmbedding.vector; // ä½¿ç”¨æœªå‹ç¼©çš„å‘é‡
            }
            
            // 4. æ‰§è¡Œå‘é‡æœç´¢
            const searchResults = await this.retryHelper.executeWithRetry(
                () => this.vectorDB.search(queryVector, topK, comboKey),
                'Searching vectors in database'
            );
            
            // 5. å¤„ç†æœç´¢ç»“æœ
            const processedResults = await this._processSearchResults(searchResults);
            
            this.logger.info(`Search completed: found ${processedResults.length} results for query "${query.substring(0, 50)}..."`);
            
            return processedResults;
            
        } catch (error) {
            this.logger.error(`Error searching vectors for query "${query}":`, error);
            throw error;
        }
    }

    async flushVectors() {
        if (!this.isInitialized) {
            throw new Error('VectorManager not initialized');
        }
        
        // å¦‚æœæ²¡æœ‰vectorDBæˆ–tempVectorsï¼Œç›´æ¥è¿”å›
        if (!this.vectorDB || !this.tempVectors) {
            this.logger.debug('No vectors to flush');
            return 0;
        }
        
        try {
            let totalUploaded = 0;
            
            for (const [comboKey, vectors] of this.tempVectors.entries()) {
                if (vectors.length === 0) continue;
                
                // ç¡®ä¿ç›®æ ‡é›†åˆå­˜åœ¨
                await this._ensureCollectionExists(comboKey);
                
                // è½¬æ¢å‘é‡æ ¼å¼å¹¶ä¸Šä¼ 
                const vectorsForUpload = vectors.map(vector => ({
                    id: vector.id,
                    vector: vector.vector,
                    user_id: vector.userId || 'unknown',
                    device_id: vector.deviceId || 'unknown',
                    workspace_path: vector.workspacePath || 'unknown',
                    file_path: this.pathEncryption ? this.pathEncryption.encryptPath(vector.filePath) : vector.filePath,
                    code: vector.content || vector.code || '',
                    start_line: vector.startLine || vector.start_line || 0,
                    end_line: vector.endLine || vector.end_line || 0,
                    vector_model: vector.vector_model || 'CoCoSoDa-v1.0',
                    metadata: {
                        timestamp: Date.now(),
                        ...vector.metadata
                    }
                }));
                
                await this.vectorDB.upsert(comboKey, vectorsForUpload);
                totalUploaded += vectorsForUpload.length;
                
                // æ¸…ç©ºä¸´æ—¶å­˜å‚¨
                this.tempVectors.set(comboKey, []);
            }
            
            this.logger.info(`Flush completed: uploaded ${totalUploaded} vectors`);
            return totalUploaded;
            
        } catch (error) {
            this.logger.error('Error flushing vectors:', error);
            return 0;
        }
    }

    async getVectorInfo() {
        try {
            if (this.tempVectors) {
                // ä¸´æ—¶å­˜å‚¨æ¨¡å¼
                let totalVectors = 0;
                for (const vectors of this.tempVectors.values()) {
                    totalVectors += vectors.length;
                }
                
                return {
                    totalVectors,
                    cacheSize: totalVectors * 1024, // ä¼°ç®—å¤§å°
                    lastUpdate: new Date().toISOString()
                };
            } else {
                return {
                    totalVectors: 0,
                    cacheSize: 0,
                    lastUpdate: undefined
                };
            }
        } catch (error) {
            this.logger.error('Error getting vector info:', error);
            return {
                totalVectors: 0,
                cacheSize: 0,
                lastUpdate: undefined
            };
        }
    }

    // å†…éƒ¨è¾…åŠ©æ–¹æ³•
    _generateComboKey(userId, deviceId, workspacePath) {
        if (!userId || !deviceId || !workspacePath) {
            throw new Error('Missing required parameters for combo key generation');
        }
        
        // ä½¿ç”¨ç»Ÿä¸€çš„collectionåç§°ç”Ÿæˆå·¥å…·
        return createCollectionName(userId, deviceId, workspacePath);
    }

    async _ensureCollectionExists(comboKey) {
        try {
            if (this.vectorDB && typeof this.vectorDB.ensureCollection === 'function') {
                await this.vectorDB.ensureCollection(comboKey);
                this.logger.debug(`Ensured collection exists for ${comboKey}`);
            } else {
                this.logger.debug(`VectorDB not available or ensureCollection not supported for ${comboKey}`);
            }
        } catch (error) {
            this.logger.warn(`Failed to ensure collection exists for ${comboKey}:`, error);
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©ä¸Šä¼ ç»§ç»­è¿›è¡Œ
        }
    }

    async _processSearchResults(searchResults) {
        const processedResults = [];
        
        this.logger.debug(`_processSearchResultsæ¥æ”¶åˆ°çš„åŸå§‹æ•°æ®:`, JSON.stringify(searchResults, null, 2));
        
        // ä¿®å¤ï¼šå¤„ç†è…¾è®¯äº‘å®é™…è¿”å›çš„åµŒå¥—æ•°æ®ç»“æ„
        // å®é™…æœç´¢ç»“æœåœ¨ç¬¬ä¸€ä¸ªå…ƒç´ çš„metadataæ•°ç»„ä¸­
        let actualResults = [];
        
        if (Array.isArray(searchResults) && searchResults.length > 0) {
            const firstItem = searchResults[0];
            if (firstItem && Array.isArray(firstItem.metadata)) {
                // çœŸæ­£çš„æœç´¢ç»“æœåœ¨metadataæ•°ç»„ä¸­
                actualResults = firstItem.metadata;
                this.logger.info(`ä»metadataæ•°ç»„ä¸­æå–åˆ° ${actualResults.length} ä¸ªå®é™…æœç´¢ç»“æœ`);
            } else {
                // å¦‚æœæ•°æ®ç»“æ„æ­£å¸¸ï¼Œç›´æ¥ä½¿ç”¨
                actualResults = searchResults;
                this.logger.info(`ä½¿ç”¨åŸå§‹æ•°æ®ç»“æ„ï¼ŒåŒ…å« ${actualResults.length} ä¸ªæœç´¢ç»“æœ`);
            }
        } else {
            this.logger.warn(`æœç´¢ç»“æœä¸ºç©ºæˆ–æ ¼å¼å¼‚å¸¸`);
            return [];
        }
        
        this.logger.debug(`Processing ${actualResults.length} actual search results`);
        
        for (const result of actualResults) {
            try {
                this.logger.debug(`Processing search result:`, JSON.stringify(result, null, 2));
                
                // ä¿®å¤ï¼šå¤„ç†è…¾è®¯äº‘å®é™…è¿”å›çš„å­—æ®µç»“æ„
                const filePath = result.file_path || result.filePath || 'unknown';
                const fileName = result.fileName || null;
                const chunkId = result.id || result.chunkId || 'unknown';
                const score = result.score || 0;
                
                // è§£å¯†æ–‡ä»¶è·¯å¾„
                let decryptedPath = filePath;
                try {
                    decryptedPath = this.pathEncryption.decryptPath(filePath);
                } catch (decryptError) {
                    this.logger.warn(`Failed to decrypt path ${filePath}, using original path:`, decryptError.message);
                    decryptedPath = filePath;
                }
                
                // æ„é€ è¿”å›ç»“æœ - å…¼å®¹å¤šç§æ•°æ®æ ¼å¼
                const processedResult = {
                    chunkId: chunkId,
                    score: score, // ä¿æŒåŸå§‹åˆ†æ•°å­—æ®µ
                    similarity: score, // åŒæ—¶ä¿ç•™similarityå­—æ®µä¾›å‘åå…¼å®¹
                    filePath: decryptedPath,
                    fileName: fileName ? this.pathEncryption.decryptPath(fileName) : null,
                    offset: result.offset || 0,
                    
                    // å°è¯•ä»å¤šä¸ªå¯èƒ½çš„å­—æ®µä¸­è·å–å†…å®¹
                    content: result.content || result.code || '', 
                    
                    // å°è¯•ä»å¤šä¸ªå¯èƒ½çš„å­—æ®µä¸­è·å–è¡Œå·
                    startLine: result.startLine || result.start_line || 0,
                    endLine: result.endLine || result.end_line || 0,
                    
                    metadata: {
                        // å°è¯•ä»å¤šä¸ªå¯èƒ½çš„å­—æ®µä¸­è·å–ç”¨æˆ·ä¿¡æ¯
                        userId: result.userId || result.user_id || 'unknown',
                        deviceId: result.deviceId || result.device_id || 'unknown',
                        workspacePath: result.workspacePath || result.workspace_path || '',
                        
                        // å°è¯•ä»å¤šä¸ªå¯èƒ½çš„å­—æ®µä¸­è·å–å…¶ä»–å…ƒæ•°æ®
                        language: result.language || result.metadata?.language || '',
                        parser: result.parser || result.metadata?.parser || '',
                        type: result.type || result.metadata?.type || '',
                        vectorModel: result.vectorModel || result.vector_model || result.metadata?.vectorModel || '',
                        processingTimeMs: result.processingTimeMs || result.processing_time_ms || result.metadata?.processingTimeMs || 0,
                        createdAt: result.createdAt || result.created_at || result.metadata?.createdAt || '',
                        
                        originalScore: result.score // ä¿ç•™åŸå§‹åˆ†æ•°
                    }
                };
                
                processedResults.push(processedResult);
                this.logger.debug(`Successfully processed result ${chunkId} with score ${score}`);
                
            } catch (error) {
                this.logger.error(`Error processing search result ${result?.id || 'unknown'}:`, error);
                this.logger.error(`Result data:`, JSON.stringify(result, null, 2));
                // è·³è¿‡å¤„ç†å¤±è´¥çš„ç»“æœï¼Œä½†ä¸ä¸­æ–­æ•´ä¸ªå¤„ç†æµç¨‹
            }
        }
        
        this.logger.info(`Successfully processed ${processedResults.length}/${actualResults.length} search results`);
        return processedResults;
    }

    _startPeriodicTasks() {
        // å®šæœŸæ¸…ç†ä»»åŠ¡ï¼ˆä¿ç•™åŸºç¡€æ¸…ç†åŠŸèƒ½ï¼‰
        this.cleanupTimer = setInterval(async () => {
            try {
                await this._periodicCleanup();
            } catch (error) {
                this.logger.error('Error in periodic cleanup:', error);
            }
        }, 600000); // 10åˆ†é’Ÿ
    }

    async shutdown() {
        if (this.isShuttingDown) {
            this.logger.warn('VectorManager is already shutting down, waiting for completion...');
            // ç­‰å¾…å½“å‰å…³é—­æµç¨‹å®Œæˆ
            const maxWait = 10000; // æœ€å¤šç­‰å¾…10ç§’
            const startTime = Date.now();
            while (this.isShuttingDown && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return;
        }
        
        this.isShuttingDown = true;
        this.logger.info('Shutting down VectorManager...');
        
        try {
            // 1. åœæ­¢å®šæ—¶ä»»åŠ¡
            if (this.cleanupTimer) {
                clearInterval(this.cleanupTimer);
                this.cleanupTimer = null;
            }
            
            // 2. ç»™æ­£åœ¨è¿›è¡Œçš„æ“ä½œæ›´å¤šæ—¶é—´å®Œæˆ
            this.logger.info('Waiting for ongoing operations to complete...');
            await new Promise(resolve => setTimeout(resolve, 2000)); // ç­‰å¾…2ç§’
            
            // 3. ç­‰å¾…æ­£åœ¨è¿›è¡Œçš„ä¸Šä¼ å®Œæˆ
            await this._waitForUploadsToComplete();
            
            // 4. åˆ·æ–°ä¸´æ—¶å­˜å‚¨çš„å‘é‡ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
            try {
                await this.flushVectors();
            } catch (error) {
                this.logger.warn('Error during final vector flush (ignoring):', error);
            }
            
            // 5. å…³é—­å„ç»„ä»¶
            await this._cleanup();
            
            this.isShuttingDown = false; // é‡ç½®çŠ¶æ€
            this.logger.info('VectorManager shutdown completed');
            
        } catch (error) {
            this.logger.error('Error during shutdown:', error);
            this.isShuttingDown = false; // å³ä½¿å‡ºé”™ä¹Ÿè¦é‡ç½®çŠ¶æ€
            throw error;
        }
    }

    _validateVectorData(data) {
        const requiredFields = ['chunkId', 'vector', 'filePath', 'userId', 'deviceId', 'workspacePath'];
        
        for (const field of requiredFields) {
            if (!data[field]) {
                throw new Error(`Missing required field: ${field}`);
            }
        }
        
        if (!Array.isArray(data.vector)) {
            throw new Error('Vector must be an array');
        }
        
        if (data.vector.length === 0) {
            throw new Error('Vector cannot be empty');
        }
        
        if (!data.vector.every(v => typeof v === 'number')) {
            throw new Error('Vector must contain only numbers');
        }
        
        if (typeof data.chunkId !== 'string' || data.chunkId.length === 0) {
            throw new Error('chunkId must be a non-empty string');
        }
    }

    _handleError(error, context) {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
        };
        
        this.logger.error('VectorManager error:', errorInfo);
        
        // æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦éœ€è¦å‘Šè­¦
        if (this._isCriticalError(error)) {
            this._sendAlert(errorInfo);
        }
    }

    _isCriticalError(error) {
        // åˆ¤æ–­æ˜¯å¦ä¸ºå…³é”®é”™è¯¯
        const criticalPatterns = [
            'database connection',
            'authentication failed',
            'out of memory',
            'permission denied'
        ];
        
        return criticalPatterns.some(pattern => 
            error.message.toLowerCase().includes(pattern)
        );
    }

    async _cleanup() {
        try {
            if (this.vectorDB) {
                // VectorDBä½¿ç”¨closeæ–¹æ³•ï¼Œä¸æ˜¯shutdown
                if (typeof this.vectorDB.shutdown === 'function') {
                    await this.vectorDB.shutdown();
                } else if (typeof this.vectorDB.close === 'function') {
                    await this.vectorDB.close();
                }
            }
            // EmbeddingClientæ²¡æœ‰shutdownæ–¹æ³•ï¼Œè·³è¿‡
            if (this.embeddingClient) {
                this.logger.info('EmbeddingClient cleanup completed (no explicit shutdown needed)');
            }
            // PathEncryptionæ²¡æœ‰shutdownæ–¹æ³•ï¼Œè·³è¿‡
            if (this.pathEncryption) {
                this.logger.info('PathEncryption cleanup completed (no explicit shutdown needed)');
            }
        } catch (error) {
            this.logger.error('Error during cleanup:', error);
        }
    }

    async _waitForUploadsToComplete() {
        const maxWaitTime = 30000; // 30ç§’
        const startTime = Date.now();
        
        while (this.uploadInProgress.size > 0) {
            if (Date.now() - startTime > maxWaitTime) {
                this.logger.warn('Timeout waiting for uploads to complete');
                break;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    _splitVectorsIntoBatches(vectors, batchSize) {
        const batches = [];
        for (let i = 0; i < vectors.length; i += batchSize) {
            batches.push(vectors.slice(i, i + batchSize));
        }
        return batches;
    }

    async _periodicCleanup() {
        try {
            if (this.vectorDB) {
                await this.vectorDB.cleanup();
            }
        } catch (error) {
            this.logger.error('Error in periodic cleanup:', error);
        }
    }

    _registerCleanupHandlers() {
        // ä¼˜åŒ–æ¸…ç†å¤„ç†å™¨ï¼Œé¿å…è¿‡äºæ¿€è¿›çš„å…³é—­
        let shutdownInProgress = false;
        
        const gracefulShutdown = async (signal) => {
            if (shutdownInProgress) {
                this.logger.warn(`Shutdown already in progress, ignoring ${signal}`);
                return;
            }
            shutdownInProgress = true;
            
            this.logger.info(`Received ${signal} signal, initiating graceful shutdown...`);
            try {
                await this.shutdown();
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during graceful shutdown:', error);
                process.exit(1);
            }
        };

        process.on('SIGINT', async () => {
            await gracefulShutdown('SIGINT');
        });

        process.on('SIGTERM', async () => {
            await gracefulShutdown('SIGTERM');
        });

        // å¯¹äºæœªæ•è·å¼‚å¸¸ï¼Œç»™æ›´å¤šå®¹é”™æ€§
        process.on('uncaughtException', async (error) => {
            this.logger.error('Uncaught exception:', error);
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯å…³é”®é”™è¯¯
            if (this._isCriticalError(error)) {
                this.logger.error('Critical error detected, shutting down immediately');
                if (!shutdownInProgress) {
                    shutdownInProgress = true;
                    try {
                        await this.shutdown();
                    } catch (shutdownError) {
                        this.logger.error('Error during emergency shutdown:', shutdownError);
                    }
                    process.exit(1);
                }
            } else {
                // éå…³é”®é”™è¯¯ï¼Œè®°å½•ä½†ä¸å…³é—­
                this.logger.warn('Non-critical uncaught exception, continuing operation');
            }
        });

        // å¯¹äºæœªå¤„ç†çš„Promiseæ‹’ç»ï¼Œä¹Ÿç»™æ›´å¤šå®¹é”™æ€§
        process.on('unhandledRejection', async (reason, promise) => {
            this.logger.error('Unhandled rejection:', reason);
            
            // åªæœ‰åœ¨ç¡®å®æ˜¯å…³é”®é”™è¯¯æ—¶æ‰å…³é—­
            if (reason && typeof reason === 'object' && this._isCriticalError(reason)) {
                this.logger.error('Critical unhandled rejection, shutting down');
                if (!shutdownInProgress) {
                    shutdownInProgress = true;
                    try {
                        await this.shutdown();
                    } catch (shutdownError) {
                        this.logger.error('Error during emergency shutdown:', shutdownError);
                    }
                    process.exit(1);
                }
            } else {
                // éå…³é”®é”™è¯¯ï¼Œè®°å½•ä½†ä¸å…³é—­
                this.logger.warn('Non-critical unhandled rejection, continuing operation');
            }
        });
    }
}

module.exports = VectorManager;

/***/ }),
/* 223 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DBConnection = __webpack_require__(224);
const CollectionManager = __webpack_require__(227);
const QueryBuilder = __webpack_require__(228);
const TencentVectorDB = __webpack_require__(226);
const Logger = __webpack_require__(225);
const { createCollectionName } = __webpack_require__(229);
const RetryHelper = __webpack_require__(230);

class VectorDB {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('VectorDB', config.logLevel);
        this.retryHelper = new RetryHelper(config.retry);

        // è°ƒè¯•ï¼šæ£€æŸ¥é…ç½®ç±»å‹
        this.logger.debug('VectorDBé…ç½®æ£€æŸ¥:', {
            configType: config.type,
            isTencentCloud: config.type === 'tencent_cloud',
            connectionType: config.connection?.type
        });

        // æ ¹æ®æ•°æ®åº“ç±»å‹é€‰æ‹©å®ç°
        if (config.type === 'tencent_cloud') {
            this.logger.info('ä½¿ç”¨è…¾è®¯äº‘å‘é‡æ•°æ®åº“å®ç°');
            // ä¸ºTencentVectorDBå‡†å¤‡æ­£ç¡®çš„é…ç½®æ ¼å¼
            const tencentConfig = {
                ...config.connection,  // å°†connectionä¸‹çš„é…ç½®æå‡åˆ°é¡¶çº§
                logLevel: config.logLevel || 'info',
                database: config.connection.database || config.query?.defaultDatabase,
                ...config  // ä¿ç•™å…¶ä»–é¡¶çº§é…ç½®
            };
            this.implementation = new TencentVectorDB(tencentConfig);
            this.useTencentCloud = true;
        } else {
            // åŸæœ‰çš„å®ç°é€»è¾‘
            this.logger.info('ä½¿ç”¨åŸå§‹æ•°æ®åº“å®ç°');
            this.useTencentCloud = false;
            this._initOriginalImplementation(config);
        }
        
        // è¿æ¥çŠ¶æ€
        this.isConnected = false;
        this.connectionAttempts = 0;
        this.maxConnectionAttempts = config.maxConnectionAttempts || 3;
        
        // æ€§èƒ½ä¼˜åŒ–
        this.batchSize = config.batchSize || 100;
        this.requestTimeout = config.requestTimeout || 30000;
    }

    _initOriginalImplementation(config) {
        // ä¿è¯è¿æ¥é…ç½®å­˜åœ¨ä¸”æœ‰ logLevel
        if (!this.config.connection) {
            this.config.connection = {
                logLevel: 'info',
                host: 'localhost',
                database: 'test_db',
                username: 'test_user',
                apiKey: 'test_key'
            };
        } else {
            if (!this.config.connection.logLevel) this.config.connection.logLevel = 'info';
            if (!this.config.connection.host) this.config.connection.host = 'localhost';
            if (!this.config.connection.database) this.config.connection.database = 'test_db';
            if (!this.config.connection.username) this.config.connection.username = 'test_user';
            if (!this.config.connection.apiKey) this.config.connection.apiKey = 'test_key';
        }
        
        // æ ¸å¿ƒç»„ä»¶
        this.connection = null;
        this.collectionManager = null;
        this.queryBuilder = null;
    }

    async initialize() {
        if (this.useTencentCloud) {
            // ä½¿ç”¨è…¾è®¯äº‘å‘é‡æ•°æ®åº“
            await this.implementation.initialize();
            this.isConnected = true;
            this.logger.info('VectorDB initialized with Tencent Cloud');
            return;
        }

        // åŸæœ‰çš„åˆå§‹åŒ–é€»è¾‘
        try {
            this.logger.info('Initializing VectorDB...');
            
            // 1. åˆå§‹åŒ–è¿æ¥ç®¡ç†å™¨
            this.connection = new DBConnection(this.config.connection);
            await this.connection.initialize();
            
            // 2. åˆå§‹åŒ–é›†åˆç®¡ç†å™¨
            this.collectionManager = new CollectionManager(this.connection, this.config.collections);
            
            // 3. åˆå§‹åŒ–æŸ¥è¯¢æ„å»ºå™¨
            this.queryBuilder = new QueryBuilder(this.config.query);
            
            // 4. æµ‹è¯•è¿æ¥
            await this._testConnection();
            
            this.isConnected = true;
            this.logger.info('VectorDB initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize VectorDB:', error);
            throw error;
        }
    }

    async batchUpsert(comboKey, vectors) {
        if (!this.isConnected) {
            throw new Error('Database not connected');
        }
        
        if (this.useTencentCloud) {
            // ä½¿ç”¨è…¾è®¯äº‘å‘é‡æ•°æ®åº“
            return await this.implementation.batchUpsert(comboKey, vectors);
        }

        // åŸæœ‰çš„é€»è¾‘
        try {
            this.logger.info(`Starting batch upsert for ${comboKey}: ${vectors.length} vectors`);
            
            // 1. ç¡®ä¿ç›®æ ‡é›†åˆå­˜åœ¨
            const collectionName = this._getCollectionName(comboKey);
            await this.collectionManager.ensureCollection(collectionName);
            
            // 2. åˆ†æ‰¹å¤„ç†å¤§é‡æ•°æ®
            const batches = this._splitIntoBatches(vectors, this.batchSize);
            let totalUploaded = 0;
            const uploadResults = [];
            
            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                this.logger.debug(`Uploading batch ${i + 1}/${batches.length}: ${batch.length} vectors`);
                
                try {
                    const batchResult = await this._uploadBatch(collectionName, batch);
                    totalUploaded += batchResult.count;
                    uploadResults.push(batchResult);
                    
                } catch (error) {
                    this.logger.error(`Failed to upload batch ${i + 1}:`, error);
                    
                    // æ ¹æ®é…ç½®å†³å®šæ˜¯å¦ç»§ç»­å¤„ç†å‰©ä½™æ‰¹æ¬¡
                    if (this.config.stopOnBatchError) {
                        throw error;
                    } else {
                        uploadResults.push({ success: false, error: error.message, count: 0 });
                    }
                }
            }
            
            // 3. æ±‡æ€»ç»“æœ
            const result = {
                success: totalUploaded > 0,
                count: totalUploaded,
                totalBatches: batches.length,
                successfulBatches: uploadResults.filter(r => r.success).length,
                failedBatches: uploadResults.filter(r => !r.success).length,
                details: uploadResults
            };
            
            if (result.success) {
                this.logger.info(`Batch upsert completed for ${comboKey}: ${totalUploaded}/${vectors.length} vectors uploaded`);
            } else {
                this.logger.error(`Batch upsert failed for ${comboKey}: no vectors uploaded`);
            }
            
            return result;
            
        } catch (error) {
            this.logger.error(`Error in batch upsert for ${comboKey}:`, error);
            throw error;
        }
    }

    async search(queryVector, topK, comboKey, options = {}) {
        if (!this.isConnected) {
            throw new Error('Database not connected');
        }
        
        if (this.useTencentCloud) {
            // ä½¿ç”¨è…¾è®¯äº‘å‘é‡æ•°æ®åº“
            return await this.implementation.search(queryVector, topK, comboKey, options);
        }

        // åŸæœ‰çš„æœç´¢é€»è¾‘
        try {
            // 1. æ„å»ºæœç´¢æŸ¥è¯¢
            const collectionName = this._getCollectionName(comboKey);
            const searchQuery = this.queryBuilder.buildSearchQuery({
                vector: queryVector,
                topK: topK,
                collection: collectionName,
                ...options
            });
            
            this.logger.debug(`Executing search in collection ${collectionName} with topK=${topK}`);
            
            // 2. æ‰§è¡Œæœç´¢
            const response = await this.retryHelper.executeWithRetry(
                () => this.connection.post('/document/search', searchQuery),
                `Search in collection ${collectionName}`
            );
            
            // 3. å¤„ç†æœç´¢ç»“æœ
            const results = this._processSearchResponse(response);
            
            this.logger.info(`Search completed: found ${results.length} results in collection ${collectionName}`);
            
            return results;
            
        } catch (error) {
            this.logger.error(`Error in vector search:`, error);
            throw error;
        }
    }

    async deleteVectors(comboKey, vectorIds) {
        if (!this.isConnected) {
            throw new Error('Database not connected');
        }
        
        if (this.useTencentCloud) {
            // è…¾è®¯äº‘åˆ é™¤åŠŸèƒ½æš‚ä¸å®ç°
            this.logger.warn('Delete vectors not implemented for Tencent Cloud yet');
            return 0;
        }

        try {
            const collectionName = this._getCollectionName(comboKey);
            
            // åˆ†æ‰¹åˆ é™¤
            const batches = this._splitIntoBatches(vectorIds, this.batchSize);
            let totalDeleted = 0;
            
            for (const batch of batches) {
                const deleteQuery = this.queryBuilder.buildDeleteQuery({
                    collection: collectionName,
                    ids: batch
                });
                
                const response = await this.retryHelper.executeWithRetry(
                    () => this.connection.post('/document/delete', deleteQuery),
                    `Delete vectors from collection ${collectionName}`
                );
                
                totalDeleted += this._getDeletedCount(response);
            }
            
            this.logger.info(`Deleted ${totalDeleted} vectors from collection ${collectionName}`);
            return totalDeleted;
            
        } catch (error) {
            this.logger.error(`Error deleting vectors:`, error);
            throw error;
        }
    }

    // å†…éƒ¨æ–¹æ³•
    async _testConnection() {
        try {
            // å¯¹äºè…¾è®¯äº‘å‘é‡æ•°æ®åº“ï¼Œè·³è¿‡å¥åº·æ£€æŸ¥ï¼ˆè¿æ¥æµ‹è¯•å·²åœ¨DBConnectionä¸­å®Œæˆï¼‰
            if (this.config.connection.type === 'tencent') {
                this.logger.debug('Skipping health check for Tencent VectorDB - connection already tested');
                return;
            }
            
            // æµ‹è¯•åŸºæœ¬è¿æ¥
            const response = await this.connection.get('/health');
            this.logger.debug('Database connection test successful');
            
        } catch (error) {
            throw new Error(`Database connection test failed: ${error.message}`);
        }
    }

    _getCollectionName(comboKey) {
        // ç›´æ¥ä½¿ç”¨ç»„åˆé”®ä½œä¸ºé›†åˆåç§°ï¼ˆå·²åŒ…å«user_id+device_id+workspace_pathï¼‰
        return comboKey;
    }

    /**
     * åˆ›å»ºç¬¦åˆè…¾è®¯äº‘é™åˆ¶çš„é›†åˆåç§°
     * åŸºäºç”¨æˆ·IDã€è®¾å¤‡IDå’Œå·¥ä½œç©ºé—´è·¯å¾„ç”Ÿæˆ
     * 
     * @param {string} user_id - ç”¨æˆ·æ ‡è¯†ç¬¦
     * @param {string} device_id - è®¾å¤‡æ ‡è¯†ç¬¦
     * @param {string} workspace_path - å·¥ä½œç©ºé—´è·¯å¾„
     * @returns {string} é›†åˆåç§°å­—ç¬¦ä¸²
     */
    _createCollectionName(user_id, device_id, workspace_path) {
        return createCollectionName(user_id, device_id, workspace_path);
    }

    _splitIntoBatches(items, batchSize) {
        const batches = [];
        for (let i = 0; i < items.length; i += batchSize) {
            batches.push(items.slice(i, i + batchSize));
        }
        return batches;
    }

    async _uploadBatch(collectionName, vectors) {
        try {
            // æ„å»ºè…¾è®¯äº‘å‘é‡æ•°æ®åº“ä¸Šä¼ è¯·æ±‚
            const upsertQuery = this.queryBuilder.buildUpsertQuery({
                collection: collectionName,
                documents: vectors.map(vector => ({
                    // å¿…éœ€å­—æ®µ
                    id: vector.id,
                    vector: vector.vector,
                    // è…¾è®¯äº‘å‘é‡æ•°æ®åº“æµ‹è¯•è§„èŒƒå­—æ®µ
                    user_id: vector.user_id,
                    device_id: vector.device_id, 
                    workspace_path: vector.workspace_path,
                    file_path: vector.file_path,
                    start_line: vector.start_line,
                    end_line: vector.end_line,
                    code: vector.code,
                    vector_model: vector.vector_model,
                    // å…¼å®¹æ—§æ ¼å¼
                    filePath: vector.filePath,
                    fileName: vector.fileName,
                    offset: vector.offset,
                    timestamp: vector.metadata?.timestamp || new Date().toISOString(),
                    // å…¶ä»–å…ƒæ•°æ®å­—æ®µ
                    ...vector.metadata
                }))
            });
            
            // æ‰§è¡Œä¸Šä¼ 
            const response = await this.connection.post('/document/upsert', upsertQuery);
            
            // éªŒè¯å“åº”
            if (response.code !== 0) {
                throw new Error(`Upload failed: ${response.msg || 'Unknown error'}`);
            }
            
            return {
                success: true,
                count: response.affectedCount || response.count || vectors.length,
                response: response
            };
            
        } catch (error) {
            return {
                success: false,
                count: 0,
                error: error.message
            };
        }
    }

    _processSearchResponse(response) {
        if (response.code !== 0) {
            throw new Error(`Search failed: ${response.msg || 'Unknown error'}`);
        }
        
        if (!response.documents || !Array.isArray(response.documents)) {
            return [];
        }
        
        // è½¬æ¢æœç´¢ç»“æœæ ¼å¼
        return response.documents.map(doc => ({
            id: doc.id,
            score: doc.score,
            filePath: doc.filePath,
            fileName: doc.fileName,
            offset: doc.offset,
            timestamp: doc.timestamp,
            metadata: {
                // æå–å…¶ä»–å…ƒæ•°æ®
                ...doc
            }
        }));
    }

    _getDeletedCount(response) {
        if (response.code !== 0) {
            throw new Error(`Delete failed: ${response.msg || 'Unknown error'}`);
        }
        
        return response.count || 0;
    }

    async close() {
        if (this.useTencentCloud) {
            await this.implementation.close();
        } else if (this.connection) {
            await this.connection.close();
        }
        this.isConnected = false;
        this.logger.info('VectorDB connection closed');
    }
}

module.exports = VectorDB;

/***/ }),
/* 224 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const axios = __webpack_require__(148);
const Logger = __webpack_require__(225);
const TencentVectorDB = __webpack_require__(226);

class DBConnection {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('DBConnection', config.logLevel);
        
        // è¿æ¥é…ç½®
        this.host = config.host;
        this.port = config.port || 80;
        this.database = config.database;
        this.username = config.username;
        this.apiKey = config.apiKey;
        
        // HTTP å®¢æˆ·ç«¯é…ç½®
        this.timeout = config.timeout || 30000;
        this.maxRetries = config.maxRetries || 3;
        
        // è¿æ¥æ± é…ç½®
        this.maxConnections = config.maxConnections || 10;
        this.keepAlive = config.keepAlive !== false;
        
        // HTTP å®¢æˆ·ç«¯å®ä¾‹
        this.httpClient = null;
        
        // è¿æ¥çŠ¶æ€
        this.isInitialized = false;
        this.lastError = null;
    }

    async initialize() {
        try {
            this.logger.info(`Initializing database connection to ${this.host}:${this.port}`);
            
            // éªŒè¯é…ç½®
            this._validateConfig();
            
            // åˆ›å»º HTTP å®¢æˆ·ç«¯
            this._createHttpClient();
            
            // æµ‹è¯•è¿æ¥å¹¶è‡ªåŠ¨åˆ›å»ºæ•°æ®åº“ï¼ˆå¦‚æœéœ€è¦ï¼‰
            await this._testConnectionAndEnsureDatabase();
            
            this.isInitialized = true;
            this.logger.info('Database connection initialized successfully');
            
        } catch (error) {
            this.lastError = error;
            this.logger.error('Failed to initialize database connection:', error);
            throw error;
        }
    }

    async get(path, params = {}) {
        return this._makeRequest('GET', path, null, params);
    }

    async post(path, data, params = {}) {
        return this._makeRequest('POST', path, data, params);
    }

    async put(path, data, params = {}) {
        return this._makeRequest('PUT', path, data, params);
    }

    async delete(path, params = {}) {
        return this._makeRequest('DELETE', path, null, params);
    }

    // å†…éƒ¨æ–¹æ³•
    _validateConfig() {
        const requiredFields = ['host', 'database', 'username', 'apiKey'];
        
        for (const field of requiredFields) {
            if (!this.config[field]) {
                throw new Error(`Missing required database config field: ${field}`);
            }
        }
    }

    _createHttpClient() {
        // æ£€æŸ¥hostæ˜¯å¦å·²ç»åŒ…å«åè®®å‰ç¼€
        let baseURL;
        if (this.host.startsWith('http://') || this.host.startsWith('https://')) {
            // å¦‚æœhostå·²ç»åŒ…å«åè®®ï¼Œç›´æ¥ä½¿ç”¨
            baseURL = this.port && this.port !== 80 && this.port !== 443 
                ? `${this.host}:${this.port}` 
                : this.host;
        } else {
            // å¦‚æœhostä¸åŒ…å«åè®®ï¼Œæ·»åŠ httpå‰ç¼€
            baseURL = `http://${this.host}:${this.port}`;
        }
        
        this.httpClient = axios.create({
            baseURL: baseURL,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': this._getAuthHeader()
            },
            // è¿æ¥æ± é…ç½®
            maxRedirects: 5,
            // ä¿æŒè¿æ¥æ´»è·ƒ
            ...(this.keepAlive && {
                'Connection': 'keep-alive',
                'Keep-Alive': 'timeout=30'
            }),
            // ç¦ç”¨ä»£ç†é¿å…è¿æ¥é—®é¢˜
            proxy: false
        });
        
        // æ·»åŠ è¯·æ±‚æ‹¦æˆªå™¨
        this.httpClient.interceptors.request.use(
            config => {
                this.logger.debug(`Making request: ${config.method?.toUpperCase()} ${config.url}`);
                return config;
            },
            error => {
                this.logger.error('Request interceptor error:', error);
                return Promise.reject(error);
            }
        );
        
        // æ·»åŠ å“åº”æ‹¦æˆªå™¨
        this.httpClient.interceptors.response.use(
            response => {
                this.logger.debug(`Response received: ${response.status} ${response.statusText}`);
                return response.data; // ç›´æ¥è¿”å›æ•°æ®éƒ¨åˆ†
            },
            error => {
                this._handleResponseError(error);
                return Promise.reject(error);
            }
        );
    }

    _getAuthHeader() {
        // æ„å»ºè®¤è¯å¤´
        return `Bearer account=${this.username}&api_key=${this.apiKey}`;
    }

    async _makeRequest(method, path, data = null, params = {}) {
        if (!this.isInitialized) {
            throw new Error('Database connection not initialized');
        }
        
        try {
            const config = {
                method: method,
                url: path,
                params: params
            };
            
            if (data) {
                config.data = data;
            }
            
            const response = await this.httpClient.request(config);
            return response;
            
        } catch (error) {
            this.logger.error(`Request failed: ${method} ${path}`, error);
            throw this._processError(error);
        }
    }

    async _testConnectionAndEnsureDatabase() {
        try {
            // å¯¹äºè…¾è®¯äº‘å‘é‡æ•°æ®åº“ï¼Œå…ˆæµ‹è¯•è¿æ¥å†ç¡®ä¿æ•°æ®åº“å­˜åœ¨
            if (this.config.type === 'tencent') {
                await this._testTencentConnection();
                await this._ensureDatabaseExists();
            } else {
                // å…¶ä»–æ•°æ®åº“ç±»å‹çš„è¿æ¥æµ‹è¯•
                const response = await this.httpClient.get('/database/info');
                
                if (response.code !== 0) {
                    throw new Error(`Connection test failed: ${response.msg}`);
                }
                this.logger.debug('Database connection test passed');
            }
            
        } catch (error) {
            throw new Error(`Database connection test failed: ${error.message}`);
        }
    }

    async _testTencentConnection() {
        try {
            const response = await this.httpClient.get('/collections');
            this.logger.debug('Tencent VectorDB connection test passed');
        } catch (error) {
            // å¦‚æœæ˜¯404é”™è¯¯ï¼Œè®¤ä¸ºè¿æ¥æ˜¯æ­£å¸¸çš„
            if (error.response && error.response.status === 404) {
                this.logger.warn('Connection test endpoint not found, but connection to Tencent VectorDB is working');
                return; // è¿æ¥æµ‹è¯•é€šè¿‡
            }
            throw error;
        }
    }

    async _ensureDatabaseExists() {
        if (!this.database) {
            this.logger.warn('No database name specified, skipping database creation check');
            return;
        }

        try {
            this.logger.info(`Checking if database ${this.database} exists...`);
            
            // åˆ›å»ºè…¾è®¯äº‘å‘é‡æ•°æ®åº“å®¢æˆ·ç«¯å®ä¾‹
            const tencentDB = new TencentVectorDB({
                host: this.host,
                port: this.port,
                username: this.username,
                apiKey: this.apiKey,
                timeout: this.timeout
            });
            
            await tencentDB.initialize();
            
            // å…ˆå°è¯•åˆ—å‡ºæ‰€æœ‰æ•°æ®åº“ï¼Œæ£€æŸ¥ç›®æ ‡æ•°æ®åº“æ˜¯å¦å­˜åœ¨
            let databaseExists = false;
            try {
                const databaseListResult = await tencentDB.listDatabases();
                const databases = databaseListResult.data?.databases || [];
                databaseExists = databases.some(db => db.database === this.database || db.name === this.database);
                
                if (databaseExists) {
                    this.logger.info(`Database ${this.database} exists in the database list`);
                } else {
                    this.logger.info(`Database ${this.database} not found in database list, needs to be created`);
                }
            } catch (error) {
                this.logger.warn(`Unable to list databases, will try direct access: ${error.message}`);
                // å¦‚æœæ— æ³•åˆ—å‡ºæ•°æ®åº“ï¼Œå°±å°è¯•ç›´æ¥è®¿é—®
            }
            
            // å¦‚æœæ•°æ®åº“ä¸å­˜åœ¨ï¼ˆæˆ–è€…æ— æ³•ç¡®å®šï¼‰ï¼Œå°è¯•åˆ›å»º
            if (!databaseExists) {
                try {
                    this.logger.info(`Attempting to create database ${this.database}...`);
                    const createResult = await tencentDB.createDatabase(this.database);
                    
                    if (createResult.success || createResult.message === 'Database already exists') {
                        this.logger.info(`Database ${this.database} created successfully`);
                        databaseExists = true;
                    } else {
                        this.logger.warn(`Database creation result unclear: ${JSON.stringify(createResult)}`);
                    }
                } catch (createError) {
                    if (createError.message.includes('already exist')) {
                        this.logger.info(`Database ${this.database} already exists`);
                        databaseExists = true;
                    } else {
                        this.logger.error(`Failed to create database: ${createError.message}`);
                        // ä¸æŠ›å‡ºé”™è¯¯ï¼Œç»§ç»­å°è¯•éªŒè¯æ•°æ®åº“
                    }
                }
            }
            
            // æœ€åéªŒè¯æ•°æ®åº“æ˜¯å¦å¯è®¿é—®
            try {
                await tencentDB.listCollections(this.database);
                this.logger.info(`Database ${this.database} is accessible`);
            } catch (error) {
                if (error.message.includes('can not find database') || 
                    error.message.includes('not exist')) {
                    throw new Error(`Database ${this.database} still does not exist after creation attempt`);
                } else {
                    // å…¶ä»–é”™è¯¯å¯èƒ½ä¸æ˜¯è‡´å‘½çš„ï¼Œåªè®°å½•è­¦å‘Š
                    this.logger.warn(`Database access test failed, but may be due to other reasons: ${error.message}`);
                }
            }
            
            await tencentDB.close();
            
        } catch (error) {
            this.logger.error(`Error ensuring database exists: ${error.message}`);
            throw error;
        }
    }

    _handleResponseError(error) {
        if (error.response) {
            // æœåŠ¡å™¨è¿”å›é”™è¯¯çŠ¶æ€ç 
            const status = error.response.status;
            const message = error.response.data?.msg || error.response.statusText;
            
            switch (status) {
                case 401:
                    this.logger.error('Authentication failed - check API key');
                    break;
                case 403:
                    this.logger.error('Access forbidden - check permissions');
                    break;
                case 404:
                    this.logger.error('Resource not found');
                    break;
                case 429:
                    this.logger.error('Rate limit exceeded');
                    break;
                case 500:
                    this.logger.error('Database server error');
                    break;
                default:
                    this.logger.error(`HTTP error ${status}: ${message}`);
            }
            
        } else if (error.request) {
            // ç½‘ç»œé”™è¯¯
            this.logger.error('Network error:', error.message);
            
        } else {
            // å…¶ä»–é”™è¯¯
            this.logger.error('Request setup error:', error.message);
        }
    }

    _processError(error) {
        // æ ¹æ®é”™è¯¯ç±»å‹è¿›è¡Œåˆ†ç±»å¤„ç†
        if (error.code === 'ECONNREFUSED') {
            return new Error('Database connection refused - check host and port');
        }
        
        if (error.code === 'ETIMEDOUT') {
            return new Error('Database request timeout');
        }
        
        if (error.response && error.response.status === 401) {
            return new Error('Database authentication failed');
        }
        
        return error;
    }

    async close() {
        if (this.httpClient) {
            // æ¸…ç† HTTP å®¢æˆ·ç«¯
            this.httpClient = null;
        }
        
        this.isInitialized = false;
        this.logger.info('Database connection closed');
    }
}

module.exports = DBConnection;

/***/ }),
/* 225 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);

class Logger {
    constructor(name, level = 'info', config = {}) {
        this.name = name;
        this.level = level;
        this.config = config;

        // ã€ä¿®æ”¹ã€‘æµ‹è¯•ç¯å¢ƒä¸‹å…³é—­æ—¥å¿—
        this.enableConsole = process.env.NODE_ENV !== 'test' && (config.enableConsole !== false);
        this.enableFile = process.env.NODE_ENV !== 'test' && (config.enableFile !== false);
        
        // æ—¥å¿—çº§åˆ«æ˜ å°„
        this.levels = {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3,
            trace: 4
        };
        
        // å½“å‰æ—¥å¿—çº§åˆ«
        this.currentLevel = this.levels[level] || this.levels.info;
        
        // è¾“å‡ºé…ç½®
        this.enableConsole = config.enableConsole !== false;
        this.enableFile = config.enableFile !== false;
        this.logDir = config.logDir || path.join(process.cwd(), 'logs');
        this.maxFileSize = config.maxFileSize || 10 * 1024 * 1024; // 10MB
        this.maxFiles = config.maxFiles || 10;
        
        // æ ¼å¼åŒ–é…ç½®
        this.includeTimestamp = config.includeTimestamp !== false;
        this.includeLevel = config.includeLevel !== false;
        this.includeName = config.includeName !== false;
        this.colorize = config.colorize !== false && process.stdout.isTTY;
        
        // é¢œè‰²é…ç½®
        this.colors = {
            error: '\x1b[31m',   // çº¢è‰²
            warn: '\x1b[33m',    // é»„è‰²
            info: '\x1b[36m',    // é’è‰²
            debug: '\x1b[37m',   // ç™½è‰²
            trace: '\x1b[90m',   // ç°è‰²
            reset: '\x1b[0m'     // é‡ç½®
        };
        
        // æ–‡ä»¶æµç®¡ç†
        this.fileStreams = new Map();
        
        // åˆå§‹åŒ–æ—¥å¿—ç›®å½•
        this._initializeLogDirectory();
    }

    error(message, ...args) {
        this._log('error', message, ...args);
    }

    warn(message, ...args) {
        this._log('warn', message, ...args);
    }

    info(message, ...args) {
        this._log('info', message, ...args);
    }

    debug(message, ...args) {
        this._log('debug', message, ...args);
    }

    trace(message, ...args) {
        this._log('trace', message, ...args);
    }

    // æ ¼å¼åŒ–å¯¹è±¡æ—¥å¿—
    logObject(level, label, obj) {
        const formatted = this._formatObject(obj);
        this._log(level, `${label}:\n${formatted}`);
    }

    // æ€§èƒ½æ—¥å¿—
    logPerformance(operation, duration, metadata = {}) {
        const perfLog = {
            operation,
            duration: `${duration}ms`,
            timestamp: new Date().toISOString(),
            ...metadata
        };
        
        this.info(`Performance: ${operation} completed in ${duration}ms`, perfLog);
    }

    // é”™è¯¯æ—¥å¿—ï¼ˆå¸¦å †æ ˆï¼‰
    logError(error, context = '') {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
        };
        
        this.error(`Error${context ? ` in ${context}` : ''}:`, errorInfo);
    }

    // å†…éƒ¨æ–¹æ³•
    _log(level, message, ...args) {
        if (this.levels[level] > this.currentLevel) {
            return; // è·³è¿‡ä½äºå½“å‰çº§åˆ«çš„æ—¥å¿—
        }
        
        const logEntry = this._formatLogEntry(level, message, args);
        
        // æ§åˆ¶å°è¾“å‡º
        if (this.enableConsole) {
            this._writeToConsole(level, logEntry);
        }
        
        // æ–‡ä»¶è¾“å‡º
        if (this.enableFile) {
            this._writeToFile(level, logEntry);
        }
    }

    _formatLogEntry(level, message, args) {
        let formattedMessage = message;
        
        // å¤„ç†å‚æ•°
        if (args.length > 0) {
            const additionalInfo = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            formattedMessage += ` ${additionalInfo}`;
        }
        
        // æ„å»ºæ—¥å¿—æ¡ç›®
        const parts = [];
        
        if (this.includeTimestamp) {
            parts.push(new Date().toISOString());
        }
        
        if (this.includeLevel) {
            parts.push(`[${level.toUpperCase()}]`);
        }
        
        if (this.includeName) {
            parts.push(`[${this.name}]`);
        }
        
        parts.push(formattedMessage);
        
        return parts.join(' ');
    }

    _writeToConsole(level, logEntry) {
        const colorized = this.colorize ? 
            `${this.colors[level]}${logEntry}${this.colors.reset}` : 
            logEntry;
        
        if (level === 'error') {
            console.error(colorized);
        } else if (level === 'warn') {
            console.warn(colorized);
        } else {
            console.log(colorized);
        }
    }

    _writeToFile(level, logEntry) {
        try {
            const logFileName = this._getLogFileName(level);
            const logFilePath = path.join(this.logDir, logFileName);
            
            // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼Œå¦‚æœéœ€è¦åˆ™è½®è½¬
            this._rotateLogFileIfNeeded(logFilePath);
            
            // å†™å…¥æ—¥å¿—
            const logLine = logEntry + '\n';
            fs.appendFileSync(logFilePath, logLine, 'utf8');
            
        } catch (error) {
            console.error(`Failed to write log to file: ${error.message}`);
        }
    }

    _getLogFileName(level) {
        const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        return `${this.name}-${level}-${date}.log`;
    }

    _rotateLogFileIfNeeded(logFilePath) {
        try {
            if (!fs.existsSync(logFilePath)) {
                return;
            }
            
            const stats = fs.statSync(logFilePath);
            if (stats.size < this.maxFileSize) {
                return;
            }
            
            // ç”Ÿæˆå¤‡ä»½æ–‡ä»¶å
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupPath = logFilePath.replace('.log', `.${timestamp}.log`);
            
            // ç§»åŠ¨å½“å‰æ–‡ä»¶åˆ°å¤‡ä»½
            fs.moveSync(logFilePath, backupPath);
            
            // æ¸…ç†æ—§çš„å¤‡ä»½æ–‡ä»¶
            this._cleanupOldLogFiles(path.dirname(logFilePath));
            
        } catch (error) {
            console.error(`Failed to rotate log file: ${error.message}`);
        }
    }

    _cleanupOldLogFiles(logDir) {
        try {
            const files = fs.readdirSync(logDir)
                .filter(file => file.includes(this.name) && file.endsWith('.log'))
                .map(file => ({
                    name: file,
                    path: path.join(logDir, file),
                    stats: fs.statSync(path.join(logDir, file))
                }))
                .sort((a, b) => b.stats.mtime - a.stats.mtime);
            
            // åˆ é™¤è¶…è¿‡æœ€å¤§æ–‡ä»¶æ•°çš„æ—§æ–‡ä»¶
            const filesToDelete = files.slice(this.maxFiles);
            for (const file of filesToDelete) {
                fs.unlinkSync(file.path);
            }
            
        } catch (error) {
            console.error(`Failed to cleanup old log files: ${error.message}`);
        }
    }

    _formatObject(obj) {
        try {
            return JSON.stringify(obj, null, 2);
        } catch (error) {
            return `[Object cannot be serialized: ${error.message}]`;
        }
    }

    _initializeLogDirectory() {
        if (this.enableFile) {
            try {
                fs.ensureDirSync(this.logDir);
            } catch (error) {
                console.error(`Failed to create log directory: ${error.message}`);
                this.enableFile = false;
            }
        }
    }

    // å·¥å…·æ–¹æ³•
    setLevel(level) {
        if (this.levels.hasOwnProperty(level)) {
            this.level = level;
            this.currentLevel = this.levels[level];
        }
    }

    createChild(childName) {
        const fullName = `${this.name}:${childName}`;
        return new Logger(fullName, this.level, this.config);
    }

    close() {
        // å…³é—­æ–‡ä»¶æµ
        for (const stream of this.fileStreams.values()) {
            if (stream && typeof stream.close === 'function') {
                stream.close();
            }
        }
        this.fileStreams.clear();
    }
}

module.exports = Logger;

/***/ }),
/* 226 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const axios = __webpack_require__(148);
const crypto = __webpack_require__(8);
const Logger = __webpack_require__(225);

class TencentVectorDB {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('TencentVectorDB', config.logLevel);
        
        // æ™ºèƒ½å¤„ç†host URL - æ£€æŸ¥æ˜¯å¦å·²åŒ…å«åè®®
        if (config.host.startsWith('http://') || config.host.startsWith('https://')) {
            // å¦‚æœhostå·²ç»åŒ…å«åè®®ï¼Œç›´æ¥ä½¿ç”¨å¹¶æ·»åŠ ç«¯å£
            this.baseURL = config.port && config.port !== 80 && config.port !== 443 
                ? `${config.host}:${config.port}` 
                : config.host;
        } else {
            // å¦‚æœhostä¸åŒ…å«åè®®ï¼Œæ·»åŠ åè®®å‰ç¼€
            const protocol = config.useHttps ? 'https' : 'http';
            this.baseURL = `${protocol}://${config.host}:${config.port}`;
        }
        
        this.isInitialized = false;
    }

    async initialize() {
        try {
            this.logger.info('åˆå§‹åŒ–è…¾è®¯äº‘å‘é‡æ•°æ®åº“...');
            
            // æµ‹è¯•æ•°æ®åº“è¿æ¥ - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
            await this.testConnection();
            
            this.isInitialized = true;
            this.logger.info('è…¾è®¯äº‘å‘é‡æ•°æ®åº“åˆå§‹åŒ–æˆåŠŸ');
            
        } catch (error) {
            this.logger.error('è…¾è®¯äº‘å‘é‡æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥:', error);
            throw error;
        }
    }

    async testConnection() {
        try {
            // ä½¿ç”¨å®˜æ–¹APIï¼šæŸ¥è¯¢æ‰€æœ‰æ•°æ®åº“æ¥æµ‹è¯•è¿æ¥
            const response = await this.listDatabases();
            this.logger.debug('æ•°æ®åº“è¿æ¥æµ‹è¯•æˆåŠŸ');
            return response;
        } catch (error) {
            this.logger.debug('è¿æ¥æµ‹è¯•:', error.message);
            // å³ä½¿APIè°ƒç”¨å¤±è´¥ï¼Œåªè¦ä¸æ˜¯ç½‘ç»œé”™è¯¯å°±è®¤ä¸ºè¿æ¥æ­£å¸¸
            if (!error.message.includes('socket hang up') && !error.message.includes('ECONNRESET')) {
                return true;
            }
            throw error;
        }
    }

    // TC1: åˆ›å»ºDatabase - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async createDatabase(databaseName) {
        try {
            this.logger.info(`åˆ›å»ºæ•°æ®åº“: ${databaseName}`);
            
            const response = await this.makeRequest('POST', '/database/create', {
                database: databaseName,
                description: `Database created for testing - ${databaseName}`
            });
            
            this.logger.info(`æ•°æ®åº“ ${databaseName} åˆ›å»ºæˆåŠŸ`);
            return response;
        } catch (error) {
            // å¦‚æœæ˜¯æ•°æ®åº“å·²å­˜åœ¨ï¼Œé™çº§ä¸ºè­¦å‘Š
            if (error.message.includes('already exist')) {
                this.logger.warn(`æ•°æ®åº“ ${databaseName} å·²å­˜åœ¨`);
                return { success: true, message: 'Database already exists' };
            }
            this.logger.error(`åˆ›å»ºæ•°æ®åº“å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC2: åˆ é™¤Database - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async dropDatabase(databaseName) {
        try {
            this.logger.info(`åˆ é™¤æ•°æ®åº“: ${databaseName}`);
            
            const response = await this.makeRequest('POST', '/database/drop', {
                database: databaseName
            });
            
            this.logger.info(`æ•°æ®åº“ ${databaseName} åˆ é™¤æˆåŠŸ`);
            return response;
        } catch (error) {
            this.logger.error(`åˆ é™¤æ•°æ®åº“å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC3: åˆ—å‡ºæ‰€æœ‰Database - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼ï¼Œæ ¹æ®æ–‡æ¡£åº”è¯¥æ˜¯POSTè¯·æ±‚
    async listDatabases() {
        try {
            this.logger.info('è·å–æ•°æ®åº“åˆ—è¡¨');
            
            // æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼Œ/database/list æ˜¯ POST è¯·æ±‚ï¼Œä¸éœ€è¦è¯·æ±‚ä½“
            const response = await this.makeRequest('POST', '/database/list');
            
            this.logger.info(`è·å–åˆ° ${response.data?.databases ? response.data.databases.length : 0} ä¸ªæ•°æ®åº“`);
            return response;
        } catch (error) {
            this.logger.error(`è·å–æ•°æ®åº“åˆ—è¡¨å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC4: åˆ›å»ºCollection - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼ï¼Œå®Œæ•´å‚æ•°
    async createCollection(databaseName, collectionName, params = {}) {
        try {
            this.logger.info(`åœ¨æ•°æ®åº“ ${databaseName} ä¸­åˆ›å»ºé›†åˆ: ${collectionName}`);
            
            // æ ¹æ®è…¾è®¯äº‘APIè°ƒè¯•ç»“æœï¼Œä¿®æ­£é»˜è®¤å‚æ•°
            const collectionData = {
                database: databaseName,
                collection: collectionName,
                replicaNum: params.replicaNum !== undefined ? params.replicaNum : 0,  // è…¾è®¯äº‘è¦æ±‚å¿…é¡»æ˜¯0
                shardNum: params.shardNum || 1,
                description: params.description || `Collection created by Node.js client - ${collectionName}`,
                indexes: params.indexes || [
                    // é»˜è®¤ä¸»é”®ç´¢å¼•
                    {
                        fieldName: "id",
                        fieldType: "string",
                        indexType: "primaryKey"
                    },
                    // é»˜è®¤å‘é‡ç´¢å¼• - ä¿®æ­£ç»´åº¦ä¸º768
                    {
                        fieldName: "vector",
                        fieldType: "vector",
                        indexType: "HNSW",
                        dimension: 768,  // ä¿®æ­£ä¸º768ç»´åº¦
                        metricType: "COSINE",
                        params: {
                            M: 16,
                            efConstruction: 200
                        }
                    }
                ]
            };

            const result = await this.makeRequest('POST', '/collection/create', collectionData);
            
            if (result.success) {
                this.logger.info(`é›†åˆ ${collectionName} åˆ›å»ºæˆåŠŸ`);
            }
            
            return result;
            
        } catch (error) {
            this.logger.error(`åˆ›å»ºé›†åˆå¤±è´¥: ${error.message}`);
            return {
                success: false,
                status: 500,
                message: 'é›†åˆåˆ›å»ºå¤±è´¥',
                error: error.message
            };
        }
    }

    // TC5: åˆ é™¤Collection - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async dropCollection(databaseName, collectionName) {
        try {
            this.logger.info(`åˆ é™¤é›†åˆ: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/collection/drop', {
                database: databaseName,
                collection: collectionName
            });
            
            // æ£€æŸ¥å“åº”æ˜¯å¦æˆåŠŸ
            if (response.success) {
            this.logger.info(`é›†åˆ ${collectionName} åˆ é™¤æˆåŠŸ`);
            return response;
            } else {
                // æ£€æŸ¥æ˜¯å¦æ˜¯Collectionä¸å­˜åœ¨çš„é”™è¯¯
                if (response.data && response.data.code === 15302) {
                    this.logger.info(`é›†åˆ ${collectionName} ä¸å­˜åœ¨ï¼Œæ— éœ€åˆ é™¤`);
                    // Collectionä¸å­˜åœ¨çš„æƒ…å†µï¼Œè¿”å›ç‰¹æ®Šæ ‡è¯†
                    return {
                        success: true,
                        status: 200,
                        notExist: true, // æ·»åŠ æ ‡è¯†è¡¨ç¤ºcollectionä¸å­˜åœ¨
                        data: {
                            code: 15302,
                            message: `Collection ${collectionName} does not exist`,
                            affectedCount: 0
                        },
                        message: `é›†åˆ ${collectionName} ä¸å­˜åœ¨`
                    };
                } else {
                    this.logger.error(`åˆ é™¤é›†åˆå¤±è´¥: ${response.message || 'Unknown error'}`);
                    const error = new Error(response.message || 'Delete collection failed');
                    error.response = response;
                    throw error;
                }
            }
        } catch (error) {
            // å¦‚æœæ˜¯æˆ‘ä»¬ä¸»åŠ¨æŠ›å‡ºçš„é”™è¯¯ï¼Œç›´æ¥ä¼ é€’
            if (error.code === 15302) {
                throw error;
            }
            this.logger.error(`åˆ é™¤é›†åˆå¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC6: æŸ¥è¯¢Collectionè¯¦æƒ… - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async describeCollection(databaseName, collectionName) {
        try {
            this.logger.info(`æŸ¥è¯¢é›†åˆè¯¦æƒ…: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/collection/describe', {
                database: databaseName,
                collection: collectionName
            });
            
            if (response.success) {
                this.logger.info(`è·å–é›†åˆ ${collectionName} è¯¦æƒ…æˆåŠŸ`);
            } else {
                this.logger.warn(`è·å–é›†åˆ ${collectionName} è¯¦æƒ…å¤±è´¥: ${response.message}`);
            }
            return response;
        } catch (error) {
            this.logger.error(`æŸ¥è¯¢é›†åˆè¯¦æƒ…å¤±è´¥: ${error.message}`);
            // è¿”å›å¤±è´¥å“åº”è€Œä¸æ˜¯æŠ›å‡ºå¼‚å¸¸
            return {
                success: false,
                status: 500,
                data: null,
                message: `æŸ¥è¯¢é›†åˆè¯¦æƒ…å¤±è´¥: ${error.message}`,
                error: error.message
            };
        }
    }

    // TC7: åˆ—å‡ºæ‰€æœ‰Collection - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async listCollections(databaseName) {
        try {
            this.logger.info(`è·å–æ•°æ®åº“ ${databaseName} çš„é›†åˆåˆ—è¡¨`);
            
            const response = await this.makeRequest('POST', '/collection/list', {
                database: databaseName
            });
            
            this.logger.info(`è·å–åˆ° ${response.data?.collections ? response.data.collections.length : 0} ä¸ªé›†åˆ`);
            return response;
        } catch (error) {
            this.logger.error(`è·å–é›†åˆåˆ—è¡¨å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC8: å‘é‡æ•°æ®å†™å…¥ - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async upsertDocuments(databaseName, collectionName, documents) {
        try {
            this.logger.info(`å‘é›†åˆ ${databaseName}.${collectionName} å†™å…¥ ${documents.length} æ¡æ•°æ®`);
            
            const response = await this.makeRequest('POST', '/document/upsert', {
                database: databaseName,
                collection: collectionName,
                documents: documents,
                buildIndex: true  // æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼Œé»˜è®¤ä¸ºtrue
            });
            
            this.logger.info(`æ•°æ®å†™å…¥æˆåŠŸ`);
            return response;
        } catch (error) {
            this.logger.error(`æ•°æ®å†™å…¥å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC9: å‘é‡ç›¸ä¼¼åº¦æ£€ç´¢ - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async searchVectors(databaseName, collectionName, vectors, params = {}) {
        try {
            this.logger.info(`æ‰§è¡Œå‘é‡æ£€ç´¢: ${databaseName}.${collectionName}`);
            
            // ç¡®ä¿vectorsæ˜¯æ­£ç¡®çš„æ•°ç»„æ ¼å¼ - è…¾è®¯äº‘éœ€è¦äºŒç»´æ•°ç»„
            let vectorArray;
            if (Array.isArray(vectors)) {
                // å¦‚æœæ˜¯æ•°ç»„ï¼Œæ£€æŸ¥ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¦ä¹Ÿæ˜¯æ•°ç»„
                if (vectors.length > 0 && Array.isArray(vectors[0])) {
                    vectorArray = vectors; // å·²ç»æ˜¯äºŒç»´æ•°ç»„
                } else {
                    vectorArray = [vectors]; // è½¬æ¢ä¸ºäºŒç»´æ•°ç»„
                }
            } else {
                vectorArray = [vectors]; // å•ä¸ªå‘é‡åŒ…è£…ä¸ºäºŒç»´æ•°ç»„
            }

            this.logger.debug(`å‘é‡æ•°ç»„æ ¼å¼æ£€æŸ¥:`, {
                originalType: Array.isArray(vectors) ? 'array' : typeof vectors,
                originalLength: Array.isArray(vectors) ? vectors.length : 'N/A',
                processedLength: vectorArray.length,
                firstElementType: vectorArray.length > 0 ? (Array.isArray(vectorArray[0]) ? 'array' : typeof vectorArray[0]) : 'N/A',
                firstElementLength: vectorArray.length > 0 && Array.isArray(vectorArray[0]) ? vectorArray[0].length : 'N/A'
            });
            
            // æ ¹æ®å®˜æ–¹APIæ–‡æ¡£æ ¼å¼æ„å»ºè¯·æ±‚ä½“
            const requestBody = {
                database: databaseName,
                collection: collectionName,
                search: {
                    vectors: vectorArray,
                    params: params.searchParams || {
                        ef: 200  // é»˜è®¤efå‚æ•°
                    },
                    limit: params.limit || 10,
                    retrieveVector: params.retrieveVector !== undefined ? params.retrieveVector : false  // ä¿®æ­£ä»paramsè·å–å‚æ•°
                }
            };

            // å¤„ç†è¿‡æ»¤å™¨ - è½¬æ¢ä¸ºè…¾è®¯äº‘æ ¼å¼çš„å­—ç¬¦ä¸²
            if (params.filter) {
                requestBody.search.filter = this._convertFilterToTencentFormat(params.filter);
            }

            // å¤„ç†è¾“å‡ºå­—æ®µ
            // if (params.outputFields && params.outputFields.length > 0) {
            //     requestBody.search.outputFields = params.outputFields;
            // }

            // å¦‚æœæœ‰æ··åˆæ£€ç´¢å‚æ•°
            if (params.hybridSearch) {
                requestBody.search.hybridSearch = params.hybridSearch;
            }
            this.logger.info(`é‡æ£€ç´¢è¯·æ±‚ä½“:`, JSON.stringify(requestBody, null, 2));
            const response = await this.makeRequest('POST', '/document/search', requestBody);
            
            this.logger.info(`å‘é‡æ£€ç´¢å®Œæˆï¼Œè¿”å› ${response.data?.results ? response.data.results.length : 0} æ¡ç»“æœ`);
            return response;
        } catch (error) {
            this.logger.error(`å‘é‡æ£€ç´¢å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // æ–°çš„ä»£ç å‘é‡å­˜å‚¨æ¥å£ - é€‚é… /api/v1/codebase/upsert æ¥å£
    async upsertCodebase(requestId, database, collection, documents, buildIndex = true) {
        try {
            this.logger.info(`ä»£ç å‘é‡å­˜å‚¨: ${documents.length} ä¸ªæ–‡æ¡£åˆ° ${database}.${collection}`);
            
            // æ„å»ºè¯·æ±‚æ•°æ®ï¼Œç¬¦åˆæ–°æ¥å£è§„èŒƒï¼Œæ”¯æŒå‹ç¼©å‘é‡
            const requestData = {
                requestId: requestId,
                database: database,
                collection: collection,
                documents: documents.map(doc => ({
                    snippet_id: doc.snippet_id,
                    user_id: doc.user_id,
                    device_id: doc.device_id,
                    workspace_path: doc.workspace_path,
                    file_path: doc.file_path,
                    start_line: doc.start_line,
                    end_line: doc.end_line,
                    code: doc.code,
                    vector: doc.isCompressed ? null : doc.vector,
                    compressedVector: doc.isCompressed ? doc.compressedVector : null,
                    isCompressed: doc.isCompressed || false,
                    vector_model: doc.vector_model || "CoCoSoDa-v1.0"
                })),
                buildIndex: buildIndex
            };

            // å‘é€åˆ°æ–°çš„ä»£ç†æ¥å£
            const response = await this.makeCodebaseRequest('POST', '/api/v1/codebase/upsert', requestData);
            
            if (response.status === 'success') {
                this.logger.info(`ä»£ç å‘é‡å­˜å‚¨æˆåŠŸ: å½±å“ ${response.affectedRows} è¡Œ`);
                return {
                    success: true,
                    affectedRows: response.affectedRows,
                    requestId: response.requestId,
                    timestamp: response.timestamp
                };
            } else {
                this.logger.error(`ä»£ç å‘é‡å­˜å‚¨å¤±è´¥: ${response.error}`);
                throw new Error(response.error || 'Upsert failed');
            }
            
        } catch (error) {
            this.logger.error(`ä»£ç å‘é‡å­˜å‚¨å¼‚å¸¸: ${error.message}`);
            throw error;
        }
    }

    // æ–°çš„HTTPè¯·æ±‚æ–¹æ³•ï¼Œä¸“é—¨ç”¨äºä»£ç åº“æ¥å£
    async makeCodebaseRequest(method, endpoint, data = null) {
        const url = (__webpack_require__(154).URL);
        const https = __webpack_require__(153);
        const http = __webpack_require__(152);
        
        try {
            // ä½¿ç”¨ä»£ç åº“APIçš„åŸºç¡€URLï¼ˆå¯èƒ½ä¸å‘é‡æ•°æ®åº“ä¸åŒï¼‰
            const codebaseBaseURL = this.config.codebaseApiUrl || this.baseURL;
            const requestUrl = new URL(endpoint, codebaseBaseURL);
            const isHttps = requestUrl.protocol === 'https:';
            
            const options = {
                hostname: requestUrl.hostname,
                port: requestUrl.port || (isHttps ? 443 : 80),
                path: requestUrl.pathname + requestUrl.search,
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.config.apiKey}`,
                    'User-Agent': 'CodeChunker-VectorDB/1.0.0'
                },
                timeout: this.config.timeout || 30000
            };

            if (data) {
                const postData = JSON.stringify(data);
                options.headers['Content-Length'] = Buffer.byteLength(postData);
            }

            return new Promise((resolve, reject) => {
                const req = (isHttps ? https : http).request(options, (res) => {
                    let responseData = '';
                    
                    res.on('data', (chunk) => {
                        responseData += chunk;
                    });
                    
                    res.on('end', () => {
                        try {
                            // æ£€æŸ¥å“åº”æ•°æ®æ˜¯å¦ä¸ºç©ºæˆ–ä¸å®Œæ•´
                            if (!responseData || responseData.trim().length === 0) {
                                reject(new Error('Empty response from server'));
                                return;
                            }
                            
                            // æ£€æŸ¥å“åº”æ˜¯å¦çœ‹èµ·æ¥åƒJSON
                            if (!responseData.trim().startsWith('{') && !responseData.trim().startsWith('[')) {
                                this.logger.error(`Non-JSON response received: ${responseData.substring(0, 200)}...`);
                                reject(new Error(`Invalid response format: expected JSON, got: ${responseData.substring(0, 100)}...`));
                                return;
                            }
                            
                            const parsed = JSON.parse(responseData);
                            
                            if (res.statusCode >= 200 && res.statusCode < 300) {
                                resolve(parsed);
                            } else {
                                const error = new Error(parsed.error || `HTTP ${res.statusCode}`);
                                error.statusCode = res.statusCode;
                                error.response = parsed;
                                error.errorCode = parsed.errorCode;
                                reject(error);
                            }
                        } catch (error) {
                            this.logger.error(`JSON parse error. Response length: ${responseData.length}, Content: ${responseData.substring(0, 200)}...`);
                            reject(new Error(`Failed to parse response: ${error.message}. Response was: ${responseData.substring(0, 200)}...`));
                        }
                    });
                });

                req.on('error', (error) => {
                    reject(new Error(`Request failed: ${error.message}`));
                });

                req.on('timeout', () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                });

                if (data) {
                    req.write(JSON.stringify(data));
                }
                
                req.end();
            });
            
        } catch (error) {
            this.logger.error(`ä»£ç åº“è¯·æ±‚å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // ä¿®æ”¹ç°æœ‰çš„batchUpsertæ–¹æ³•ä»¥ä½¿ç”¨æ–°æ¥å£
    async batchUpsert(comboKey, vectors) {
        try {
            this.logger.info(`å¼€å§‹æ‰¹é‡å‘é‡å­˜å‚¨: ${comboKey} - ${vectors.length} ä¸ªå‘é‡`);

            // éªŒè¯å’Œè¿‡æ»¤å‘é‡æ•°æ®
            const validVectors = this._validateAndFilterVectors(vectors);
            if (validVectors.length === 0) {
                this.logger.warn('æ²¡æœ‰æœ‰æ•ˆçš„å‘é‡æ•°æ®éœ€è¦å­˜å‚¨');
                return {
                    success: true,
                    count: 0,
                    message: 'æ²¡æœ‰æœ‰æ•ˆæ•°æ®'
                };
            }

            // è§£æcomboKeyè·å–ç”¨æˆ·ä¿¡æ¯
            const [userId, deviceId, workspaceHash] = comboKey.split('_');
            const workspacePath = this._extractWorkspacePathFromHash(workspaceHash) || '/unknown/workspace';
            
            // å‡†å¤‡æ•°æ®åº“å’Œé›†åˆåç§°
            const databaseName = this.config.database || 'codebase_db';
            // âœ… ä¿®å¤ï¼šä½¿ç”¨æ—¶é—´æˆ³ç”Ÿæˆæ–°çš„collectionåç§°ï¼Œé¿å…æ—§collectionçš„socket hang upé—®é¢˜
            const timestamp = Date.now();
            const collectionName = `code_vectors_${timestamp}`;
            
            // è½¬æ¢ä¸ºæ–°æ¥å£æ ¼å¼çš„æ–‡æ¡£ï¼Œæ”¯æŒå‹ç¼©å‘é‡
            const documents = validVectors.map((vector, index) => ({
                snippet_id: vector.id || `${comboKey}_${index}`,
                user_id: userId,
                device_id: deviceId,
                workspace_path: workspacePath,
                file_path: vector.filePath || 'unknown',
                start_line: vector.startLine || 1,
                end_line: vector.endLine || 1,
                code: vector.content || '',
                vector: vector.isCompressed ? null : vector.vector,
                compressedVector: vector.isCompressed ? vector.compressedVector : null,
                isCompressed: vector.isCompressed || false,
                vector_model: vector.vectorModel || "CoCoSoDa-v1.0"
            }));

            // ç”Ÿæˆè¯·æ±‚ID
            const requestId = `req-upsert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

            // ä½¿ç”¨æ–°çš„ä»£ç åº“æ¥å£
            const result = await this.upsertCodebase(requestId, databaseName, collectionName, documents, true);
            
            this.logger.info(`æ‰¹é‡å‘é‡å­˜å‚¨å®Œæˆ: ${result.affectedRows} è¡Œæ•°æ®`);
            
            return {
                success: true,
                count: result.affectedRows,
                requestId: result.requestId,
                details: result
            };

        } catch (error) {
            this.logger.error(`æ‰¹é‡å‘é‡å­˜å‚¨å¤±è´¥: ${error.message}`);
            
            // å¦‚æœæ–°æ¥å£å¤±è´¥ï¼Œå¯ä»¥å°è¯•å›é€€åˆ°åŸæ¥å£ï¼ˆå¯é€‰ï¼‰
            if (error.message.includes('404') || error.message.includes('endpoint')) {
                this.logger.warn('æ–°æ¥å£ä¸å¯ç”¨ï¼Œå°è¯•ä½¿ç”¨åŸæ¥å£...');
                return await this._fallbackBatchUpsert(comboKey, vectors);
            }
            
            throw error;
        }
    }

    // å›é€€æ–¹æ³•ï¼šä½¿ç”¨åŸæœ‰çš„è…¾è®¯äº‘æ¥å£
    async _fallbackBatchUpsert(comboKey, vectors) {
        this.logger.info('ä½¿ç”¨åŸæœ‰è…¾è®¯äº‘æ¥å£è¿›è¡Œå‘é‡å­˜å‚¨');
        
        try {
            // éªŒè¯å’Œè¿‡æ»¤å‘é‡æ•°æ®
            const validVectors = this._validateAndFilterVectors(vectors);
            if (validVectors.length === 0) {
                return {
                    success: true,
                    count: 0,
                    message: 'æ²¡æœ‰æœ‰æ•ˆæ•°æ®'
                };
            }

            // ç”Ÿæˆé›†åˆåç§°
            const crypto = __webpack_require__(8);
            const workspaceHash = crypto.createHash('sha256').update(comboKey).digest('hex').substring(0, 16);
            const collectionName = `collection_${comboKey}`;
            const databaseName = this.config.database || 'vectordb-test';

            // ç¡®ä¿é›†åˆå­˜åœ¨
            await this._ensureCollectionExists(databaseName, collectionName, 768);

            // è½¬æ¢ä¸ºè…¾è®¯äº‘æ ¼å¼
            const documents = validVectors.map((vector, index) => ({
                id: vector.id || `${comboKey}_${index}`,
                vector: vector.vector,
                user_id: comboKey.split('_')[0] || 'unknown',
                device_id: comboKey.split('_')[1] || 'unknown',
                workspace_path: vector.workspacePath || 'unknown',
                file_path: vector.filePath || 'unknown',
                start_line: vector.startLine || 1,
                end_line: vector.endLine || 1,
                code: vector.content || '',
                vector_model: vector.vectorModel || 'default'
            }));

            // åˆ†æ‰¹ä¸Šä¼ 
            const batchSize = this.config.batchSize || 100;
            const batches = this._splitIntoBatches(documents, batchSize);
            let totalUploaded = 0;

            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                this.logger.debug(`ä¸Šä¼ æ‰¹æ¬¡ ${i + 1}/${batches.length}: ${batch.length} ä¸ªå‘é‡`);
                
                const batchResult = await this._uploadBatchWithRetry(databaseName, collectionName, batch);
                totalUploaded += batchResult.count || 0;
            }

            this.logger.info(`å›é€€æ¥å£æ‰¹é‡å­˜å‚¨å®Œæˆ: ${totalUploaded} ä¸ªå‘é‡`);
            
            return {
                success: true,
                count: totalUploaded,
                fallback: true
            };

        } catch (error) {
            this.logger.error(`å›é€€æ¥å£ä¹Ÿå¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // è¾…åŠ©æ–¹æ³•ï¼šä»å“ˆå¸Œä¸­æå–å·¥ä½œåŒºè·¯å¾„ï¼ˆç®€åŒ–å®ç°ï¼‰
    _extractWorkspacePathFromHash(workspaceHash) {
        // è¿™é‡Œå¯ä»¥å®ç°æ›´å¤æ‚çš„é€»è¾‘æ¥æ¢å¤åŸå§‹è·¯å¾„
        // ç›®å‰è¿”å›ä¸€ä¸ªé€šç”¨è·¯å¾„
        return `/workspace/${workspaceHash}`;
    }

    // è¾…åŠ©æ–¹æ³•ï¼šéªŒè¯å’Œè¿‡æ»¤å‘é‡æ•°æ®
    _validateAndFilterVectors(vectors) {
        const validVectors = [];
        
        // âœ… ä¿®å¤ï¼šé‡æ–°è®¡ç®—åˆç†çš„é™åˆ¶
        // å‘é‡ç»´åº¦768 * 8å­—èŠ‚(åŒç²¾åº¦) â‰ˆ 6KB 
        // åŠ ä¸Šå…¶ä»–å­—æ®µï¼Œæ€»æ–‡æ¡£å¤§å°åº”è¯¥æ§åˆ¶åœ¨9KBä»¥ä¸‹
        const maxCodeSize = 2 * 1024; // âœ… ä»£ç å†…å®¹é™åˆ¶é™åˆ°2KB
        const vectorSizeEstimate = 768 * 8; // âœ… 768ç»´å‘é‡çš„ä¼°ç®—å¤§å°
        
        for (let i = 0; i < vectors.length; i++) {
            const vector = vectors[i];
            
            // åŸºæœ¬å­—æ®µæ£€æŸ¥
            if (!vector.id || !vector.vector || !Array.isArray(vector.vector)) {
                this.logger.warn(`å‘é‡ ${i} ç¼ºå°‘å¿…è¦å­—æ®µ (id æˆ– vector)ï¼Œè·³è¿‡`);
                continue;
            }
            
            // âœ… ä¿®å¤ï¼šå…ˆå¤„ç†ä»£ç å†…å®¹ï¼Œç¡®ä¿ä¸ä¼šè¿‡å¤§
            let codeContent = vector.code || '';
            if (codeContent.length > maxCodeSize) {
                // æ™ºèƒ½æˆªæ–­ï¼šä¿ç•™å¼€å¤´å’Œç»“å°¾
                const truncateSize = maxCodeSize - 50; // ä¸ºæ ‡è®°ä¿ç•™ç©ºé—´
                const halfSize = Math.floor(truncateSize / 2);
                codeContent = codeContent.substring(0, halfSize) + 
                             '\n\n... [å†…å®¹æˆªæ–­] ...\n\n' + 
                             codeContent.substring(codeContent.length - halfSize);
                this.logger.debug(`å‘é‡ ${vector.id} ä»£ç å†…å®¹æˆªæ–­: ${vector.code.length} -> ${codeContent.length} å­—ç¬¦`);
            }
            
            // âœ… ä¿®å¤ï¼šæ›´å‡†ç¡®çš„æ–‡æ¡£å¤§å°ä¼°ç®—ï¼ˆä¸åŒ…å«å‘é‡æ•°æ®ï¼‰
            const metadataSize = JSON.stringify({
                id: vector.id,
                user_id: vector.user_id || 'unknown',
                device_id: vector.device_id || 'unknown',
                workspace_path: vector.workspace_path || 'unknown',
                file_path: vector.file_path || 'unknown',
                code: codeContent,
                start_line: vector.start_line || 0,
                end_line: vector.end_line || 0,
                vector_model: vector.vector_model || 'unknown'
            }).length;
            
            // âœ… æ–‡æ¡£æ€»å¤§å° = å…ƒæ•°æ® + å‘é‡æ•°æ®
            const estimatedTotalSize = metadataSize + vectorSizeEstimate;
            const maxDocSize = 9 * 1024; // âœ… è…¾è®¯äº‘é™åˆ¶æ˜¯10KBï¼Œç•™1KBä½™é‡
            
            if (estimatedTotalSize > maxDocSize) {
                this.logger.warn(`å‘é‡ ${vector.id} æ–‡æ¡£ä»ç„¶è¿‡å¤§ (${estimatedTotalSize} > ${maxDocSize})ï¼Œè·³è¿‡å¤„ç†`);
                continue;
            }
            
            // ç¡®ä¿å¿…è¦å­—æ®µå­˜åœ¨
            const validVector = {
                id: vector.id,
                vector: vector.vector,
                user_id: vector.user_id || 'unknown',
                device_id: vector.device_id || 'unknown',
                workspace_path: vector.workspace_path || 'unknown',
                file_path: vector.file_path || 'unknown',
                code: codeContent, // âœ… ä½¿ç”¨å¤„ç†åçš„ä»£ç å†…å®¹
                start_line: vector.start_line || 0,
                end_line: vector.end_line || 0,
                vector_model: vector.vector_model || 'unknown'
            };
            
            validVectors.push(validVector);
        }
        
        this.logger.info(`å‘é‡éªŒè¯å®Œæˆ: ${validVectors.length}/${vectors.length} ä¸ªå‘é‡æœ‰æ•ˆ`);
        return validVectors;
    }

    // è¾…åŠ©æ–¹æ³•ï¼šå¸¦é‡è¯•çš„æ‰¹é‡ä¸Šä¼ 
    async _uploadBatchWithRetry(databaseName, collectionName, batch, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const result = await this.upsertDocuments(databaseName, collectionName, batch);
                
                if (result.success) {
                    return result;
                } else {
                    lastError = new Error(result.message || 'ä¸Šä¼ å¤±è´¥');
                    
                    // å¦‚æœæ˜¯ç´¢å¼•æœªå‡†å¤‡é”™è¯¯ï¼Œç­‰å¾…ä¸€ä¸‹å†é‡è¯•
                    if (result.message && result.message.includes('current index is not ready')) {
                        this.logger.warn(`ç´¢å¼•æœªå‡†å¤‡å°±ç»ªï¼Œç­‰å¾…${attempt * 2}ç§’åé‡è¯• (${attempt}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                        continue;
                    } else {
                        throw lastError;
                    }
                }
                
            } catch (error) {
                lastError = error;
                
                // å¯¹äº400é”™è¯¯ï¼ˆå®¢æˆ·ç«¯é”™è¯¯ï¼‰ï¼Œä¸è¦é‡è¯•
                if (error.response && error.response.status === 400) {
                    this.logger.error(`å®¢æˆ·ç«¯é”™è¯¯ï¼Œä¸é‡è¯•: ${error.response.data ? JSON.stringify(error.response.data) : error.message}`);
                    throw error;
                }
                
                if (attempt < maxRetries) {
                    this.logger.warn(`æ‰¹é‡ä¸Šä¼ å¤±è´¥ï¼Œ${attempt * 2}ç§’åé‡è¯• (${attempt}/${maxRetries}): ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                } else {
                    this.logger.error(`æ‰¹é‡ä¸Šä¼ æœ€ç»ˆå¤±è´¥ï¼Œå·²é‡è¯•${maxRetries}æ¬¡: ${error.message}`);
                    throw error;
                }
            }
        }
        
        throw lastError;
    }

    // è¾…åŠ©æ–¹æ³•ï¼šç¡®ä¿é›†åˆå­˜åœ¨
    async _ensureCollectionExists(databaseName, collectionName, vectorDimension = 768) {
        try {
            // æ£€æŸ¥é›†åˆæ˜¯å¦å­˜åœ¨
            const describeResult = await this.describeCollection(databaseName, collectionName);
            
            if (describeResult.success) {
                this.logger.info(`é›†åˆ ${collectionName} å·²å­˜åœ¨ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦é‡æ–°åˆ›å»º...`);
                
                // æ£€æŸ¥ç°æœ‰é›†åˆçš„ç»´åº¦é…ç½®
                const existingDimension = describeResult.data?.collection?.indexes?.find(
                    index => index.fieldName === 'vector'
                )?.dimension;
                
                if (existingDimension && existingDimension !== vectorDimension) {
                    this.logger.info(`é›†åˆç»´åº¦ä¸åŒ¹é… (ç°æœ‰: ${existingDimension}, éœ€è¦: ${vectorDimension})ï¼Œé‡æ–°åˆ›å»ºé›†åˆ...`);
                    
                    // åˆ é™¤ç°æœ‰é›†åˆ
                    await this.dropCollection(databaseName, collectionName);
                    
                    // åˆ›å»ºæ–°é›†åˆ
                    await this._createCollectionWithFields(databaseName, collectionName, vectorDimension);
                } else {
                    this.logger.debug(`é›†åˆ ${collectionName} é…ç½®æ­£ç¡®ï¼Œè·³è¿‡é‡æ–°åˆ›å»º`);
                }
            } else {
                // æ£€æŸ¥æ˜¯å¦æ˜¯"é›†åˆä¸å­˜åœ¨"çš„é”™è¯¯
                if (describeResult.data && describeResult.data.code === 15302) {
                    this.logger.info(`é›†åˆ ${collectionName} ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`);
                    await this._createCollectionWithFields(databaseName, collectionName, vectorDimension);
                } else {
                    // å…¶ä»–é”™è¯¯ï¼ŒæŠ›å‡ºå¼‚å¸¸
                    throw new Error(`æŸ¥è¯¢é›†åˆè¯¦æƒ…å¤±è´¥: ${describeResult.message || 'æœªçŸ¥é”™è¯¯'}`);
                }
            }
            
        } catch (error) {
            // å¯¹äºå·²çŸ¥çš„"é›†åˆä¸å­˜åœ¨"é”™è¯¯ï¼Œåˆ›å»ºé›†åˆ
            if (error.message.includes('not exist') || error.message.includes('Not Found') || 
                (error.response && error.response.data && error.response.data.msg && 
                 error.response.data.msg.includes('not exist'))) {
                this.logger.info(`é›†åˆ ${collectionName} ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`);
                await this._createCollectionWithFields(databaseName, collectionName, vectorDimension);
            } else {
                throw error;
            }
        }
    }

    // è¾…åŠ©æ–¹æ³•ï¼šåˆ›å»ºå¸¦æœ‰å®Œæ•´å­—æ®µå®šä¹‰çš„é›†åˆ
    async _createCollectionWithFields(databaseName, collectionName, vectorDimension) {
        const collectionParams = {
            description: `Auto-created collection for ${collectionName}`,
            indexes: [
                {
                    fieldName: "id",
                    fieldType: "string",
                    indexType: "primaryKey"
                },
                {
                    fieldName: "vector",
                    fieldType: "vector",
                    indexType: "HNSW",
                    dimension: vectorDimension,
                    metricType: "COSINE",
                    params: {
                        M: 16,
                        efConstruction: 200
                    }
                },
                // æ·»åŠ æµ‹è¯•æ•°æ®çš„å­—æ®µ
                {
                    fieldName: "user_id",
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "device_id", 
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "workspace_path",
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "file_path",
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "code",
                    fieldType: "string",
                    indexType: "filter"
                },
                // æ·»åŠ æ›´å¤šå¯èƒ½éœ€è¦çš„å­—æ®µ
                {
                    fieldName: "start_line",
                    fieldType: "uint64",
                    indexType: "filter"
                },
                {
                    fieldName: "end_line",
                    fieldType: "uint64",
                    indexType: "filter"
                },
                {
                    fieldName: "vector_model",
                    fieldType: "string",
                    indexType: "filter"
                }
            ]
        };
        
        const createResult = await this.createCollection(databaseName, collectionName, collectionParams);
        if (createResult.success) {
            this.logger.info(`é›†åˆ ${collectionName} åˆ›å»ºæˆåŠŸï¼Œç»´åº¦: ${vectorDimension}`);
            
            // ç­‰å¾…ç´¢å¼•æ„å»ºå®Œæˆ
            await this._waitForIndexReady(databaseName, collectionName);
        } else {
            throw new Error(`åˆ›å»ºé›†åˆå¤±è´¥: ${createResult.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    }

    // è¾…åŠ©æ–¹æ³•ï¼šç­‰å¾…ç´¢å¼•å‡†å¤‡å°±ç»ª
    async _waitForIndexReady(databaseName, collectionName, maxWaitTime = 60000) {
        this.logger.info(`ç­‰å¾…é›†åˆ ${collectionName} çš„ç´¢å¼•æ„å»ºå®Œæˆ...`);
        
        const startTime = Date.now();
        let retryCount = 0;
        const maxRetries = Math.floor(maxWaitTime / 2000); // æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡
        
        while (retryCount < maxRetries) {
            try {
                // å°è¯•æ’å…¥ä¸€ä¸ªæµ‹è¯•æ–‡æ¡£æ¥æ£€æŸ¥ç´¢å¼•æ˜¯å¦å°±ç»ª
                const testDoc = {
                    id: `test_${Date.now()}`,
                    vector: new Array(768).fill(0.1),
                    user_id: 'test',
                    device_id: 'test',
                    workspace_path: 'test',
                    file_path: 'test',
                    code: 'test',
                    start_line: 1,
                    end_line: 1,
                    vector_model: 'test'
                };
                
                const result = await this.upsertDocuments(databaseName, collectionName, [testDoc]);
                
                if (result.success) {
                    // ç´¢å¼•å°±ç»ªï¼Œåˆ é™¤æµ‹è¯•æ–‡æ¡£
                    await this.deleteDocuments(databaseName, collectionName, `id="${testDoc.id}"`);
                    this.logger.info(`é›†åˆ ${collectionName} ç´¢å¼•æ„å»ºå®Œæˆï¼Œè€—æ—¶ ${Date.now() - startTime}ms`);
                    return;
                }
                
            } catch (error) {
                if (error.message && error.message.includes('current index is not ready')) {
                    // ç´¢å¼•è¿˜æœªå‡†å¤‡å¥½ï¼Œç»§ç»­ç­‰å¾…
                    retryCount++;
                    this.logger.debug(`ç´¢å¼•å°šæœªå‡†å¤‡å°±ç»ªï¼Œç­‰å¾…ä¸­... (${retryCount}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    continue;
                } else {
                    // å…¶ä»–é”™è¯¯ï¼Œå¯èƒ½ç´¢å¼•å·²ç»å‡†å¤‡å¥½äº†
                    this.logger.info(`ç´¢å¼•çŠ¶æ€æ£€æŸ¥å®Œæˆ (å¯èƒ½å·²å°±ç»ª): ${error.message}`);
                    return;
                }
            }
        }
        
        // è¶…æ—¶ä½†ä¸æŠ›å‡ºé”™è¯¯ï¼Œè®©åç»­æ“ä½œè‡ªè¡Œå¤„ç†
        this.logger.warn(`ç­‰å¾…ç´¢å¼•å°±ç»ªè¶…æ—¶ (${maxWaitTime}ms)ï¼Œå°†ç»§ç»­å°è¯•ä¸Šä¼ æ•°æ®`);
    }

    // è¾…åŠ©æ–¹æ³•ï¼šåˆ†æ‰¹å¤„ç†
    _splitIntoBatches(items, batchSize) {
        const batches = [];
        for (let i = 0; i < items.length; i += batchSize) {
            batches.push(items.slice(i, i + batchSize));
        }
        return batches;
    }

    async search(queryVector, topK, comboKey, options = {}) {
        try {
            const collectionName = `collection_${comboKey}`;
            const databaseName = this.config.database || 'vectordb-test';
            
            this.logger.info(`æ‰§è¡Œæœç´¢: ${databaseName}.${collectionName}, topK=${topK}`);
            this.logger.debug(`æŸ¥è¯¢å‘é‡é•¿åº¦: ${queryVector.length}`);
            this.logger.debug(`æœç´¢é€‰é¡¹:`, JSON.stringify(options, null, 2));
            
            // ä¿®æ­£è¾“å‡ºå­—æ®µé…ç½®ï¼Œé¿å…ä½¿ç”¨'*'
            const defaultOutputFields = ['id', 'user_id', 'device_id', 'workspace_path', 'file_path', 'code', 'start_line', 'end_line', 'vector_model'];
            
            const params = {
                limit: topK,
                filter: options.filter,
                outputFields: options.outputFields || defaultOutputFields,
                retrieveVector: false  // é»˜è®¤ä¸è¿”å›å‘é‡ä»¥æé«˜æ€§èƒ½
            };
            
            this.logger.debug(`æœç´¢å‚æ•°:`, JSON.stringify(params, null, 2));
            
            const response = await this.searchVectors(databaseName, collectionName, queryVector, params);
            
            this.logger.debug(`æœç´¢å“åº”:`, JSON.stringify(response, null, 2));
            
            // è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼
            if (response.success && response.data) {
                // æ£€æŸ¥ä¸åŒå¯èƒ½çš„å“åº”æ ¼å¼
                let documents = response.data.documents || response.data.results || response.data;
                
                if (Array.isArray(documents)) {
                    this.logger.info(`æ‰¾åˆ° ${documents.length} ä¸ªæœç´¢ç»“æœ`);
                    return documents.map(doc => ({
                        id: doc.id,
                        score: doc.score || 0,
                        user_id: doc.user_id,
                        device_id: doc.device_id,
                        workspace_path: doc.workspace_path,
                        file_path: doc.file_path,
                        start_line: doc.start_line,
                        end_line: doc.end_line,
                        code: doc.code,
                        vector_model: doc.vector_model,
                        // å…¼å®¹å­—æ®µ
                        filePath: doc.filePath,
                        fileName: doc.fileName,
                        offset: doc.offset,
                        timestamp: doc.timestamp,
                        metadata: doc
                    }));
                } else {
                    this.logger.warn(`æ„å¤–çš„å“åº”æ ¼å¼ï¼Œdocumentsä¸æ˜¯æ•°ç»„:`, typeof documents);
                }
            } else {
                // æ£€æŸ¥å¸¸è§çš„é”™è¯¯ä»£ç ï¼Œæä¾›æ›´å‹å¥½çš„å¤„ç†
                if (response.data && response.data.code) {
                    const errorCode = response.data.code;
                    const errorMsg = response.data.msg || 'æœªçŸ¥é”™è¯¯';
                    
                    switch (errorCode) {
                        case 15171:
                            this.logger.warn(`å‘é‡ç»´åº¦ä¸åŒ¹é…: ${errorMsg} - è¯·æ£€æŸ¥å‘é‡ç»´åº¦æ˜¯å¦ä¸é›†åˆå®šä¹‰ä¸€è‡´`);
                            break;
                        case 14000:
                            this.logger.warn(`å­—æ®µä¸å­˜åœ¨é”™è¯¯: ${errorMsg} - è¯·æ£€æŸ¥outputFieldsä¸­æŒ‡å®šçš„å­—æ®µæ˜¯å¦åœ¨é›†åˆä¸­å®šä¹‰`);
                            break;
                        default:
                            this.logger.warn(`æœç´¢å“åº”åŒ…å«é”™è¯¯ (${errorCode}): ${errorMsg}`);
                    }
                } else {
                    this.logger.warn(`æœç´¢å“åº”ä¸åŒ…å«æˆåŠŸæ•°æ®:`, JSON.stringify(response, null, 2));
                }
            }
            
            return [];
            
        } catch (error) {
            this.logger.error(`æœç´¢å¤±è´¥ï¼Œå®Œæ•´é”™è¯¯ä¿¡æ¯:`, {
                message: error.message,
                stack: error.stack,
                code: error.code,
                response: error.response?.data,
                status: error.response?.status
            });
            throw new Error(`å‘é‡æœç´¢å¤±è´¥: ${error.message || 'æœªçŸ¥é”™è¯¯'}`);
        }
    }

    // TC10: ç²¾ç¡®æŸ¥è¯¢ - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async queryDocuments(databaseName, collectionName, filter, params = {}) {
        try {
            this.logger.info(`æ‰§è¡Œç²¾ç¡®æŸ¥è¯¢: ${databaseName}.${collectionName}`);
            
            const requestBody = {
                database: databaseName,
                collection: collectionName,
                filter: filter,
                limit: params.limit || 10,
                offset: params.offset || 0,
                outputFields: params.outputFields || []  // æŒ‡å®šè¿”å›çš„å­—æ®µ
            };

            // å¦‚æœæŒ‡å®šäº†ç‰¹å®šå­—æ®µ
            if (params.retrieveVector !== undefined) {
                requestBody.retrieveVector = params.retrieveVector;
            }
            
            const response = await this.makeRequest('POST', '/document/query', requestBody);
            
            this.logger.info(`ç²¾ç¡®æŸ¥è¯¢å®Œæˆï¼Œè¿”å› ${response.data?.documents ? response.data.documents.length : 0} æ¡ç»“æœ`);
            return response;
        } catch (error) {
            this.logger.error(`ç²¾ç¡®æŸ¥è¯¢å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC11: åˆ é™¤æ•°æ® - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async deleteDocuments(databaseName, collectionName, filter) {
        try {
            this.logger.info(`åˆ é™¤æ–‡æ¡£: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/document/delete', {
                database: databaseName,
                collection: collectionName,
                filter: filter
            });
            
            this.logger.info(`æ–‡æ¡£åˆ é™¤æˆåŠŸ`);
            return response;
        } catch (error) {
            this.logger.error(`åˆ é™¤æ–‡æ¡£å¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // TC12: æ¸…ç©ºCollection - ä½¿ç”¨å®˜æ–¹APIæ ¼å¼
    async truncateCollection(databaseName, collectionName) {
        try {
            this.logger.info(`æ¸…ç©ºé›†åˆ: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/collection/truncate', {
                database: databaseName,
                collection: collectionName
            });
            
            this.logger.info(`é›†åˆæ¸…ç©ºæˆåŠŸ`);
            return response;
        } catch (error) {
            this.logger.error(`æ¸…ç©ºé›†åˆå¤±è´¥: ${error.message}`);
            throw error;
        }
    }

    // å°†å¯¹è±¡æ ¼å¼çš„è¿‡æ»¤å™¨è½¬æ¢ä¸ºè…¾è®¯äº‘APIçš„å­—ç¬¦ä¸²æ ¼å¼
    _convertFilterToTencentFormat(filter) {
        if (!filter || typeof filter === 'string') {
            return filter; // å¦‚æœå·²ç»æ˜¯å­—ç¬¦ä¸²æ ¼å¼ï¼Œç›´æ¥è¿”å›
        }
        
        const conditions = [];
        
        for (const [field, value] of Object.entries(filter)) {
            if (Array.isArray(value)) {
                // æ•°ç»„æ ¼å¼è½¬æ¢ä¸º in æ“ä½œ - ä½¿ç”¨è…¾è®¯äº‘æ ¼å¼
                const valueStr = value.map(v => `"${v}"`).join(',');
                conditions.push(`${field} in (${valueStr})`);
            } else if (typeof value === 'object' && value !== null) {
                // èŒƒå›´æŸ¥è¯¢ç­‰å¤æ‚æ¡ä»¶
                if (value.$in) {
                    const valueStr = value.$in.map(v => `"${v}"`).join(',');
                    conditions.push(`${field} in (${valueStr})`);
                } else if (value.$eq) {
                    conditions.push(`${field}="${value.$eq}"`);  // ç§»é™¤ç©ºæ ¼
                } else if (value.$gt) {
                    conditions.push(`${field}>${value.$gt}`);   // ç§»é™¤ç©ºæ ¼
                } else if (value.$lt) {
                    conditions.push(`${field}<${value.$lt}`);   // ç§»é™¤ç©ºæ ¼
                }
            } else {
                // ç®€å•ç­‰å€¼æ¡ä»¶ - ç§»é™¤ç­‰å·ä¸¤è¾¹çš„ç©ºæ ¼ï¼Œä½¿ç”¨è…¾è®¯äº‘æ ‡å‡†æ ¼å¼
                conditions.push(`${field}="${value}"`);
            }
        }
        
        // ä½¿ç”¨è…¾è®¯äº‘æ ¼å¼çš„è¿æ¥ç¬¦
        return conditions.length > 0 ? conditions.join(' and ') : '';  // ä½¿ç”¨å°å†™ 'and'
    }

    // å‘é€HTTPè¯·æ±‚çš„é€šç”¨æ–¹æ³• - æ ¹æ®å®˜æ–¹æ–‡æ¡£ä¿®æ­£è®¤è¯æ–¹å¼
    async makeRequest(method, endpoint, data = null) {
        const maxRetries = 3;
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const url = `${this.baseURL}${endpoint}`;
                
                // æ ¹æ®å®˜æ–¹æ–‡æ¡£ï¼šä½¿ç”¨ Authorization Bearer å¤´éƒ¨è®¤è¯
                const authToken = `account=${this.config.username}&api_key=${this.config.apiKey}`;
                
                // æ ‡å‡†HTTPè¯·æ±‚å¤´ + å®˜æ–¹è®¤è¯å¤´éƒ¨
                const headers = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${authToken}`,
                    'User-Agent': 'TencentVectorDB-NodeJS-Client/1.0.0',
                    'Connection': 'keep-alive'  // ä¿æŒè¿æ¥
                };

                this.logger.debug(`å‘é€è¯·æ±‚ (å°è¯• ${attempt}/${maxRetries}): ${method} ${url}`);
                if (data) {
                    this.logger.debug(`è¯·æ±‚æ•°æ®:`, JSON.stringify(data, null, 2));
                }

                const axiosConfig = {
                    method,
                    url,
                    headers,
                    timeout: this.config.timeout || 60000, // å¢åŠ åˆ°60ç§’
                    validateStatus: (status) => {
                        // æ¥å—2xxçŠ¶æ€ç 
                        return status >= 200 && status < 300;
                    },
                    // æ·»åŠ é‡è¯•é…ç½®
                    retry: {
                        retries: 0, // axioså±‚é¢ä¸é‡è¯•ï¼Œæˆ‘ä»¬æ‰‹åŠ¨æ§åˆ¶
                        retryDelay: (retryCount) => {
                            return Math.pow(2, retryCount) * 1000; // æŒ‡æ•°é€€é¿
                        },
                        retryCondition: (error) => {
                            // ç½‘ç»œé”™è¯¯æ‰é‡è¯•
                            return error.code === 'ECONNRESET' || 
                                   error.code === 'ETIMEDOUT' || 
                                   error.code === 'ECONNABORTED';
                        }
                    },
                    // æ·»åŠ HTTP Agenté…ç½®
                    httpAgent: new ((__webpack_require__(152).Agent))({
                        keepAlive: true,
                        keepAliveMsecs: 30000,
                        maxSockets: 5,
                        timeout: 30000
                    })
                };

                // åªæœ‰åœ¨æœ‰æ•°æ®æ—¶æ‰æ·»åŠ dataå­—æ®µ
                if (data && method !== 'GET') {
                    axiosConfig.data = data;
                }

                const response = await axios(axiosConfig);

                this.logger.debug(`å“åº”çŠ¶æ€: ${response.status}`);
                this.logger.debug(`å“åº”æ•°æ®:`, JSON.stringify(response.data, null, 2));

                return {
                    success: true,
                    status: response.status,
                    data: response.data,
                    headers: response.headers,
                    message: this.getStatusMessage(response.status)
                };

            } catch (error) {
                lastError = error;
                
                if (error.response) {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¸¸è§çš„ä¸šåŠ¡é”™è¯¯ï¼Œé™çº§ä¸ºè­¦å‘Š
                    const isBusinessError = error.response.data && (
                        error.response.data.msg?.includes('already exist') ||
                        error.response.data.msg?.includes('current index is not ready') ||
                        error.response.data.code === 15201 || // æ•°æ®åº“å·²å­˜åœ¨
                        error.response.data.code === 13100    // ç´¢å¼•æœªå‡†å¤‡å¥½
                    );
                    
                    if (isBusinessError) {
                        this.logger.warn(`ä¸šåŠ¡è­¦å‘Š (${error.response.status}): ${error.response.data.msg || error.message}`);
                        return {
                            success: false,
                            status: error.response.status,
                            data: error.response.data,
                            headers: error.response.headers,
                            message: this.getStatusMessage(error.response.status),
                            error: error.message
                        };
                    } else {
                        this.logger.error(`è¯·æ±‚å¤±è´¥ (å°è¯• ${attempt}/${maxRetries}): ${error.message}`);
                        this.logger.error(`å“åº”çŠ¶æ€: ${error.response.status}`);
                        this.logger.error(`å“åº”æ•°æ®:`, error.response.data);
                    }
                    
                    // å¯¹äºHTTPé”™è¯¯ï¼Œä¸é‡è¯•
                    return {
                        success: false,
                        status: error.response.status,
                        data: error.response.data,
                        headers: error.response.headers,
                        message: this.getStatusMessage(error.response.status),
                        error: error.message
                    };
                } else if (error.request) {
                    // ç½‘ç»œé”™è¯¯ï¼Œå¯ä»¥é‡è¯•
                    const isRetryableError = error.code === 'ECONNRESET' || 
                                           error.code === 'ETIMEDOUT' || 
                                           error.code === 'ECONNABORTED' ||
                                           error.message.includes('timeout');
                    
                    if (isRetryableError && attempt < maxRetries) {
                        const delay = Math.pow(2, attempt - 1) * 1000; // æŒ‡æ•°é€€é¿: 1s, 2s, 4s
                        this.logger.warn(`ç½‘ç»œé”™è¯¯ï¼Œ${delay}msåé‡è¯• (${attempt}/${maxRetries}): ${error.message}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // é‡è¯•
                    }
                    
                    this.logger.error(`ç½‘ç»œé”™è¯¯ (å°è¯• ${attempt}/${maxRetries}):`, error.message);
                } else {
                    this.logger.error(`è¯·æ±‚è®¾ç½®é”™è¯¯ (å°è¯• ${attempt}/${maxRetries}):`, error.message);
                }
                
                // å¦‚æœæ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œè¿”å›é”™è¯¯
                if (attempt === maxRetries) {
                    break;
                }
            }
        }
        
        // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
        return {
            success: false,
            status: 0,
            data: null,
            message: `ç½‘ç»œé”™è¯¯ (å·²é‡è¯•${maxRetries}æ¬¡): ${lastError?.message || 'Unknown error'}`,
            error: lastError?.message || 'Unknown error'
        };
    }

    // è·å–çŠ¶æ€ç å¯¹åº”çš„æ¶ˆæ¯
    getStatusMessage(status) {
        const statusMessages = {
            200: 'Success',
            201: 'Created',
            400: 'Bad Request - è¯·æ±‚å‚æ•°é”™è¯¯',
            401: 'Unauthorized - è®¤è¯å¤±è´¥',
            403: 'Forbidden - æƒé™ä¸è¶³',
            404: 'Not Found - èµ„æºä¸å­˜åœ¨',
            405: 'Method Not Allowed - è¯·æ±‚æ–¹æ³•ä¸å…è®¸',
            409: 'Conflict - èµ„æºå†²çª',
            422: 'Unprocessable Entity - è¯·æ±‚æ ¼å¼é”™è¯¯',
            429: 'Too Many Requests - è¯·æ±‚è¿‡äºé¢‘ç¹',
            500: 'Internal Server Error - æœåŠ¡å™¨å†…éƒ¨é”™è¯¯',
            502: 'Bad Gateway - ç½‘å…³é”™è¯¯',
            503: 'Service Unavailable - æœåŠ¡ä¸å¯ç”¨',
            504: 'Gateway Timeout - ç½‘å…³è¶…æ—¶'
        };
        
        return statusMessages[status] || `HTTP ${status}`;
    }

    async close() {
        try {
            this.logger.info('å…³é—­è…¾è®¯äº‘å‘é‡æ•°æ®åº“è¿æ¥');
            this.isInitialized = false;
        } catch (error) {
            this.logger.error('å…³é—­è¿æ¥æ—¶å‡ºé”™:', error);
        }
    }
}

module.exports = TencentVectorDB; 

/***/ }),
/* 227 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Logger = __webpack_require__(225);

class CollectionManager {
    constructor(connection, config) {
        this.connection = connection;
        this.config = config;
        this.logger = new Logger('CollectionManager', config.logLevel);
        
        // é›†åˆç¼“å­˜ï¼šcollectionName -> collection info
        this.collectionCache = new Map();
        
        // é»˜è®¤é›†åˆé…ç½®
        this.defaultConfig = {
            vectorDimension: config.vectorDimension || 768,
            metricType: config.metricType || 'COSINE',
            indexType: config.indexType || 'HNSW',
            ...config.defaultCollection
        };
    }

    async ensureCollection(collectionName) {
        try {
            // æ£€æŸ¥ç¼“å­˜
            if (this.collectionCache.has(collectionName)) {
                const cachedInfo = this.collectionCache.get(collectionName);
                if (Date.now() - cachedInfo.lastChecked < 300000) { // 5åˆ†é’Ÿç¼“å­˜
                    return cachedInfo;
                }
            }
            
            // æ£€æŸ¥é›†åˆæ˜¯å¦å­˜åœ¨
            const exists = await this._checkCollectionExists(collectionName);
            
            if (!exists) {
                this.logger.info(`Collection ${collectionName} does not exist, creating...`);
                await this._createCollection(collectionName);
            }
            
            // è·å–é›†åˆä¿¡æ¯
            const collectionInfo = await this._getCollectionInfo(collectionName);
            
            // æ›´æ–°ç¼“å­˜
            this.collectionCache.set(collectionName, {
                ...collectionInfo,
                lastChecked: Date.now()
            });
            
            return collectionInfo;
            
        } catch (error) {
            this.logger.error(`Error ensuring collection ${collectionName}:`, error);
            throw error;
        }
    }

    async createCollection(collectionName, customConfig = {}) {
        try {
            const collectionConfig = {
                ...this.defaultConfig,
                ...customConfig
            };
            
            this.logger.info(`Creating collection ${collectionName} with config:`, collectionConfig);
            
            const createQuery = {
                database: this.connection.database,
                collection: collectionName,
                description: collectionConfig.description || `Collection for ${collectionName}`,
                // è…¾è®¯äº‘å‘é‡æ•°æ®åº“å¿…éœ€å‚æ•°
                shardNum: collectionConfig.shardNum || 1,
                replicaNum: collectionConfig.replicaNum || 0,
                // è…¾è®¯äº‘å‘é‡æ•°æ®åº“ç´¢å¼•å®šä¹‰
                indexes: [
                    // ä¸»é”®ç´¢å¼•
                    {
                        fieldName: "id",
                        fieldType: "string",
                        indexType: "primaryKey"
                    },
                    // å‘é‡ç´¢å¼•
                    {
                        fieldName: "vector",
                        fieldType: "vector",
                        indexType: collectionConfig.indexType || "HNSW",
                        dimension: collectionConfig.vectorDimension || 768,
                        metricType: collectionConfig.metricType || "COSINE",
                        params: collectionConfig.indexParam || {
                            M: 16,
                            efConstruction: 200
                        }
                    },
                    // å…ƒæ•°æ®å­—æ®µç´¢å¼• - ç¬¦åˆè…¾è®¯äº‘å‘é‡æ•°æ®åº“æµ‹è¯•è§„èŒƒ
                    {
                        fieldName: "user_id",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "device_id", 
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "workspace_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "file_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "start_line",
                        fieldType: "uint64",
                        indexType: "filter"
                    },
                    {
                        fieldName: "end_line",
                        fieldType: "uint64", 
                        indexType: "filter"
                    },
                    {
                        fieldName: "code",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "vector_model",
                        fieldType: "string",
                        indexType: "filter"
                    }
                ]
            };
            
            const response = await this.connection.post('/collection/create', createQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to create collection: ${response.msg}`);
            }
            
            // æ¸…é™¤ç¼“å­˜ä»¥å¼ºåˆ¶é‡æ–°è·å–
            this.collectionCache.delete(collectionName);
            
            this.logger.info(`Collection ${collectionName} created successfully`);
            
            return response;
            
        } catch (error) {
            this.logger.error(`Error creating collection ${collectionName}:`, error);
            throw error;
        }
    }

    async deleteCollection(collectionName) {
        try {
            this.logger.info(`Deleting collection ${collectionName}`);
            
            const deleteQuery = {
                database: this.connection.database,
                collection: collectionName
            };
            
            const response = await this.connection.post('/collection/drop', deleteQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to delete collection: ${response.msg}`);
            }
            
            // æ¸…é™¤ç¼“å­˜
            this.collectionCache.delete(collectionName);
            
            this.logger.info(`Collection ${collectionName} deleted successfully`);
            
            return response;
            
        } catch (error) {
            this.logger.error(`Error deleting collection ${collectionName}:`, error);
            throw error;
        }
    }

    async listCollections() {
        try {
            const listQuery = {
                database: this.connection.database
            };
            
            const response = await this.connection.post('/collection/list', listQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to list collections: ${response.msg}`);
            }
            
            return response.collections || [];
            
        } catch (error) {
            this.logger.error('Error listing collections:', error);
            throw error;
        }
    }

    async getCollectionStats(collectionName) {
        try {
            const statsQuery = {
                database: this.connection.database,
                collection: collectionName
            };
            
            const response = await this.connection.post('/collection/describe', statsQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to get collection stats: ${response.msg}`);
            }
            
            return {
                documentCount: response.documentCount || 0,
                size: response.size || 0,
                dimension: response.dimension,
                metricType: response.metricType,
                indexType: response.indexType,
                ...response
            };
            
        } catch (error) {
            this.logger.error(`Error getting stats for collection ${collectionName}:`, error);
            throw error;
        }
    }

    // å†…éƒ¨æ–¹æ³•
    async _checkCollectionExists(collectionName) {
        try {
            const collections = await this.listCollections();
            return collections.some(col => col.collection === collectionName);
            
        } catch (error) {
            // å¦‚æœåˆ—è¡¨æ“ä½œå¤±è´¥ï¼Œå°è¯•ç›´æ¥æè¿°é›†åˆ
            try {
                await this._getCollectionInfo(collectionName);
                return true;
            } catch (describeError) {
                return false;
            }
        }
    }

    async _createCollection(collectionName) {
        return this.createCollection(collectionName);
    }

    async _getCollectionInfo(collectionName) {
        try {
            const describeQuery = {
                database: this.connection.database,
                collection: collectionName
            };
            
            const response = await this.connection.post('/collection/describe', describeQuery);
            
            if (response.code !== 0) {
                throw new Error(`Collection ${collectionName} not found`);
            }
            
            return {
                name: collectionName,
                dimension: response.dimension,
                metricType: response.metricType,
                indexType: response.indexType,
                documentCount: response.documentCount || 0,
                size: response.size || 0,
                status: response.status
            };
            
        } catch (error) {
            throw error;
        }
    }

    clearCache() {
        this.collectionCache.clear();
        this.logger.debug('Collection cache cleared');
    }
}

module.exports = CollectionManager;

/***/ }),
/* 228 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Logger = __webpack_require__(225);

class QueryBuilder {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('QueryBuilder', config.logLevel);
        
        // é»˜è®¤æŸ¥è¯¢å‚æ•°
        this.defaultParams = {
            topK: config.defaultTopK || 10,
            minScore: config.defaultMinScore || 0.7,
            maxResults: config.defaultMaxResults || 100,
            timeout: config.defaultTimeout || 5000
        };
    }

    buildSearchQuery(params) {
        try {
            const {
                collection,
                vector,
                topK = this.defaultParams.topK,
                minScore = this.defaultParams.minScore,
                filter = {},
                outputFields = ['*'],
                timeout = this.defaultParams.timeout
            } = params;

            // éªŒè¯å¿…è¦å‚æ•°
            if (!collection) {
                throw new Error('Collection name is required');
            }
            if (!vector || !Array.isArray(vector)) {
                throw new Error('Valid vector is required');
            }

            // æ„å»ºè…¾è®¯äº‘å‘é‡æ•°æ®åº“æœç´¢æŸ¥è¯¢
            const query = {
                database: this.config.database || this.config.defaultDatabase,
                collection: collection,
                vectors: [vector],  // è…¾è®¯äº‘APIéœ€è¦å‘é‡æ•°ç»„æ ¼å¼
                limit: Math.min(topK, this.defaultParams.maxResults),
                filter: this._buildTencentFilter(filter),
                outputFields: outputFields.length === 1 && outputFields[0] === '*' ? undefined : outputFields
            };

            this.logger.debug('Built search query:', query);
            return query;

        } catch (error) {
            this.logger.error('Error building search query:', error);
            throw error;
        }
    }

    buildUpsertQuery(params) {
        try {
            const {
                collection,
                documents,
                timeout = this.defaultParams.timeout
            } = params;

            // éªŒè¯å¿…è¦å‚æ•°
            if (!collection) {
                throw new Error('Collection name is required');
            }
            if (!documents || !Array.isArray(documents) || documents.length === 0) {
                throw new Error('Valid documents array is required');
            }

            // æ„å»ºè…¾è®¯äº‘å‘é‡æ•°æ®åº“APIæ ¼å¼çš„æŸ¥è¯¢
            const query = {
                database: this.config.database || this.config.defaultDatabase,
                collection: collection,
                documents: documents.map(doc => ({
                    // ä¸»é”®
                    id: doc.id,
                    // å‘é‡æ•°æ®
                    vector: doc.vector,
                    // è…¾è®¯äº‘å‘é‡æ•°æ®åº“æµ‹è¯•è§„èŒƒå­—æ®µ
                    user_id: doc.user_id,
                    device_id: doc.device_id,
                    workspace_path: doc.workspace_path,
                    file_path: doc.file_path,
                    start_line: doc.start_line,
                    end_line: doc.end_line,
                    code: doc.code,
                    vector_model: doc.vector_model,
                    // å…¼å®¹å­—æ®µ
                    filePath: doc.filePath,
                    fileName: doc.fileName,
                    offset: doc.offset,
                    timestamp: doc.timestamp,
                    // å…¶ä»–å­—æ®µ
                    ...this._buildMetadata(doc)
                })),
                buildIndex: true  // æ ¹æ®APIæ–‡æ¡£ï¼Œé»˜è®¤ä¸ºtrue
            };

            this.logger.debug('Built upsert query:', query);
            return query;

        } catch (error) {
            this.logger.error('Error building upsert query:', error);
            throw error;
        }
    }

    buildDeleteQuery(params) {
        try {
            const {
                collection,
                ids,
                filter = {},
                timeout = this.defaultParams.timeout
            } = params;

            // éªŒè¯å¿…è¦å‚æ•°
            if (!collection) {
                throw new Error('Collection name is required');
            }
            if ((!ids || !Array.isArray(ids) || ids.length === 0) && 
                Object.keys(filter).length === 0) {
                throw new Error('Either ids array or filter is required');
            }

            // æ„å»ºæŸ¥è¯¢
            const query = {
                database: this.config.database,
                collection: collection,
                ids: ids,
                filter: this._buildFilter(filter),
                timeout: timeout
            };

            this.logger.debug('Built delete query:', query);
            return query;

        } catch (error) {
            this.logger.error('Error building delete query:', error);
            throw error;
        }
    }

    // å†…éƒ¨æ–¹æ³•
    _buildFilter(filter) {
        if (!filter || Object.keys(filter).length === 0) {
            return {};
        }

        const conditions = [];
        
        for (const [field, value] of Object.entries(filter)) {
            if (typeof value === 'object' && value !== null) {
                // å¤„ç†èŒƒå›´æŸ¥è¯¢
                if (value.$gt !== undefined || value.$gte !== undefined ||
                    value.$lt !== undefined || value.$lte !== undefined) {
                    const rangeCondition = {};
                    
                    if (value.$gt !== undefined) rangeCondition.$gt = value.$gt;
                    if (value.$gte !== undefined) rangeCondition.$gte = value.$gte;
                    if (value.$lt !== undefined) rangeCondition.$lt = value.$lt;
                    if (value.$lte !== undefined) rangeCondition.$lte = value.$lte;
                    
                    conditions.push({
                        field: field,
                        ...rangeCondition
                    });
                }
                // å¤„ç†æ•°ç»„æŸ¥è¯¢
                else if (value.$in !== undefined) {
                    conditions.push({
                        field: field,
                        $in: value.$in
                    });
                }
            } else {
                // å¤„ç†ç²¾ç¡®åŒ¹é…
                conditions.push({
                    field: field,
                    $eq: value
                });
            }
        }

        return conditions.length > 0 ? { conditions } : {};
    }

    // è…¾è®¯äº‘å‘é‡æ•°æ®åº“ä¸“ç”¨è¿‡æ»¤å™¨æ„å»º
    _buildTencentFilter(filter) {
        if (!filter || Object.keys(filter).length === 0) {
            return undefined;
        }

        // è…¾è®¯äº‘å‘é‡æ•°æ®åº“ä½¿ç”¨ç®€å•çš„é”®å€¼å¯¹è¿‡æ»¤æ ¼å¼
        const tencentFilter = {};
        
        for (const [field, value] of Object.entries(filter)) {
            if (typeof value === 'object' && value !== null) {
                // è…¾è®¯äº‘æš‚æ—¶åªæ”¯æŒåŸºæœ¬è¿‡æ»¤ï¼Œå¤æ‚æŸ¥è¯¢å¯èƒ½éœ€è¦è½¬æ¢
                if (value.$eq !== undefined) {
                    tencentFilter[field] = value.$eq;
                } else if (value.$in !== undefined && Array.isArray(value.$in) && value.$in.length > 0) {
                    tencentFilter[field] = value.$in[0]; // å–ç¬¬ä¸€ä¸ªå€¼ä½œä¸ºç¤ºä¾‹
                }
            } else {
                tencentFilter[field] = value;
            }
        }

        return Object.keys(tencentFilter).length > 0 ? tencentFilter : undefined;
    }

    _buildMetadata(vector) {
        const metadata = {};
        
        // æ·»åŠ åŸºæœ¬å­—æ®µ
        if (vector.filePath) metadata.filePath = vector.filePath;
        if (vector.fileName) metadata.fileName = vector.fileName;
        if (vector.offset !== undefined) metadata.offset = vector.offset;
        if (vector.timestamp) metadata.timestamp = vector.timestamp;
        
        // æ·»åŠ è‡ªå®šä¹‰å­—æ®µ
        if (vector.metadata) {
            Object.assign(metadata, vector.metadata);
        }
        
        return metadata;
    }
}

module.exports = QueryBuilder;

/***/ }),
/* 229 */
/***/ ((module) => {

/**
 * Collectionåç§°ç”Ÿæˆå·¥å…·
 * 
 * åŸºäºè…¾è®¯äº‘å‘é‡æ•°æ®åº“çš„collectionå‘½åé™åˆ¶
 * å®ç°ä¸Pythonç‰ˆæœ¬ç›¸åŒçš„collectionåç§°ç”Ÿæˆé€»è¾‘
 */

/**
 * åˆ›å»ºç¬¦åˆè…¾è®¯äº‘é™åˆ¶çš„é›†åˆåç§°
 * ä»ç”¨æˆ·IDã€è®¾å¤‡IDå’Œå·¥ä½œç©ºé—´è·¯å¾„ç”Ÿæˆcollectionåç§°
 * 
 * @param {string} user_id - ç”¨æˆ·æ ‡è¯†ç¬¦
 * @param {string} device_id - è®¾å¤‡æ ‡è¯†ç¬¦  
 * @param {string} workspace_path - å·¥ä½œç©ºé—´è·¯å¾„
 * @returns {string} Collectionåç§°å­—ç¬¦ä¸²
 */
function createCollectionName(user_id, device_id, workspace_path) {
    // å‚æ•°éªŒè¯
    if (!user_id || !device_id || !workspace_path) {
        throw new Error('Missing required parameters: user_id, device_id, workspace_path');
    }
    
    // æ¸…ç†å·¥ä½œç©ºé—´è·¯å¾„ - å°†æ‰€æœ‰éå­—æ¯æ•°å­—å­—ç¬¦æ›¿æ¢ä¸ºä¸‹åˆ’çº¿
    const clean_workspace = workspace_path
        .replace(/[^a-zA-Z0-9]/g, '_')  // æ›¿æ¢æ‰€æœ‰éå­—æ¯æ•°å­—å­—ç¬¦ä¸ºä¸‹åˆ’çº¿
        .replace(/_+/g, '_')            // å¤šä¸ªè¿ç»­ä¸‹åˆ’çº¿åˆå¹¶ä¸ºä¸€ä¸ª
        .replace(/^_+|_+$/g, '');       // å»é™¤é¦–å°¾çš„ä¸‹åˆ’çº¿
    
    return `${user_id}_${device_id}_${clean_workspace}`;
}

/**
 * éªŒè¯collectionåç§°æ˜¯å¦ç¬¦åˆè…¾è®¯äº‘è¦æ±‚
 * 
 * @param {string} collectionName - å¾…éªŒè¯çš„collectionåç§°
 * @returns {boolean} æ˜¯å¦æœ‰æ•ˆ
 */
function validateCollectionName(collectionName) {
    if (!collectionName || typeof collectionName !== 'string') {
        return false;
    }
    
    // è…¾è®¯äº‘collectionåç§°è§„åˆ™:
    // - åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸‹åˆ’çº¿
    // - é•¿åº¦é™åˆ¶é€šå¸¸ä¸º1-64å­—ç¬¦
    // - ä¸èƒ½ä»¥ä¸‹åˆ’çº¿å¼€å¤´æˆ–ç»“å°¾
    const isValidFormat = /^[a-zA-Z0-9][a-zA-Z0-9_]*[a-zA-Z0-9]$/.test(collectionName) || 
                         /^[a-zA-Z0-9]$/.test(collectionName);
    const isValidLength = collectionName.length >= 1 && collectionName.length <= 64;
    
    return isValidFormat && isValidLength;
}

/**
 * ä»collectionåç§°ä¸­è§£æå‡ºç»„ä»¶ä¿¡æ¯
 * 
 * @param {string} collectionName - collectionåç§°
 * @returns {Object} è§£æç»“æœ {user_id, device_id, workspace_path}
 */
function parseCollectionName(collectionName) {
    if (!collectionName || typeof collectionName !== 'string') {
        return null;
    }
    
    const parts = collectionName.split('_');
    if (parts.length < 3) {
        return null;
    }
    
    return {
        user_id: parts[0],
        device_id: parts[1],
        workspace_path: parts.slice(2).join('_')  // é‡æ–°ç»„åˆworkspaceéƒ¨åˆ†
    };
}

module.exports = {
    createCollectionName,
    validateCollectionName,
    parseCollectionName
}; 

/***/ }),
/* 230 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Logger = __webpack_require__(225);

class RetryHelper {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('RetryHelper', config.logLevel);
        
        // é‡è¯•é…ç½®
        this.maxRetries = config.maxRetries || 3;
        this.baseDelay = config.baseDelay || 1000; // 1ç§’
        this.maxDelay = config.maxDelay || 30000; // 30ç§’
        this.backoffFactor = config.backoffFactor || 2;
        this.jitter = config.jitter !== false; // æ·»åŠ éšæœºæ€§
        
        // é‡è¯•æ¡ä»¶é…ç½®
        this.retryableErrors = config.retryableErrors || [
            'ECONNRESET',
            'ETIMEDOUT', 
            'ECONNREFUSED',
            'ENETUNREACH',
            'EAI_AGAIN'
        ];
        
        this.retryableHttpCodes = config.retryableHttpCodes || [
            408, // Request Timeout
            429, // Too Many Requests
            500, // Internal Server Error
            502, // Bad Gateway
            503, // Service Unavailable
            504  // Gateway Timeout
        ];
        
        // ç»Ÿè®¡ä¿¡æ¯
        this.stats = {
            totalAttempts: 0,
            successfulRetries: 0,
            failedRetries: 0,
            totalDelayTime: 0
        };
    }

    async executeWithRetry(operation, context = '', options = {}) {
        const mergedOptions = { ...this.config, ...options };
        const maxRetries = mergedOptions.maxRetries || this.maxRetries;
        
        let lastError;
        let attempt = 0;
        
        console.log('å¼€å§‹é‡è¯•æ‰§è¡Œï¼ŒmaxRetries:', maxRetries);
        
        while (attempt < maxRetries) {
            console.log('å½“å‰å°è¯•æ¬¡æ•°:', attempt);
            try {
                attempt++;
                this.stats.totalAttempts++;
                
                console.log('æ‰§è¡Œæ“ä½œï¼Œå½“å‰attempt:', attempt);
                
                if (attempt > 1) {
                    this.logger.debug(`Retry attempt ${attempt}/${maxRetries} for: ${context}`);
                }
                
                const result = await this._executeOperation(operation);
                
                if (attempt > 1) {
                    this.stats.successfulRetries++;
                    this.logger.info(`Operation succeeded after ${attempt} retries: ${context}`);
                }
                
                return result;
                
            } catch (error) {
                lastError = error;
                console.log('æ“ä½œå¤±è´¥ï¼Œå½“å‰attempt:', attempt, 'é”™è¯¯:', error.message);
                
                if (attempt >= maxRetries) {
                    console.log('è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œé€€å‡ºå¾ªç¯');
                    break;
                }
                
                const delay = this._calculateDelay(attempt, mergedOptions);
                
                this.logger.warn(`Operation failed (attempt ${attempt}), retrying in ${delay}ms: ${context}`, {
                    error: error.message,
                    attempt: attempt,
                    maxRetries: maxRetries
                });
                
                await this._delay(delay);
            }
        }
        
        this.stats.failedRetries++;
        this.logger.error(`Operation failed after ${maxRetries} retries: ${context}`, {
            finalError: lastError.message,
            totalAttempts: attempt
        });
        
        throw new Error(`Operation failed after ${maxRetries} retries: ${lastError.message}`);
    }

    async executeWithCircuitBreaker(operation, context = '', circuitConfig = {}) {
        const circuitBreaker = this._getCircuitBreaker(context, circuitConfig);
        
        if (circuitBreaker.isOpen()) {
            throw new Error(`Circuit breaker is open for: ${context}`);
        }
        
        try {
            const result = await this.executeWithRetry(operation, context);
            circuitBreaker.recordSuccess();
            return result;
            
        } catch (error) {
            circuitBreaker.recordFailure();
            throw error;
        }
    }

    // æ‰¹é‡é‡è¯•æ‰§è¡Œ
    async executeBatchWithRetry(operations, context = '', options = {}) {
        const batchOptions = { ...this.config, ...options };
        const concurrency = batchOptions.concurrency || 5;
        const failFast = batchOptions.failFast !== false;
        
        const results = [];
        const errors = [];
        
        // åˆ†æ‰¹å¤„ç†
        for (let i = 0; i < operations.length; i += concurrency) {
            const batch = operations.slice(i, i + concurrency);
            
            const batchPromises = batch.map(async (operation, index) => {
                try {
                    const result = await this.executeWithRetry(
                        operation, 
                        `${context}[${i + index}]`, 
                        batchOptions
                    );
                    return { index: i + index, result, success: true };
                    
                } catch (error) {
                    const errorInfo = { index: i + index, error, success: false };
                    
                    if (failFast) {
                        throw errorInfo;
                    }
                    
                    return errorInfo;
                }
            });
            
            const batchResults = await Promise.allSettled(batchPromises);
            
            for (const promiseResult of batchResults) {
                if (promiseResult.status === 'fulfilled') {
                    const operationResult = promiseResult.value;
                    
                    if (operationResult.success) {
                        results[operationResult.index] = operationResult.result;
                    } else {
                        errors.push(operationResult);
                    }
                    
                } else {
                    // failFastæ¨¡å¼ä¸‹çš„é”™è¯¯
                    throw promiseResult.reason;
                }
            }
        }
        
        return {
            results,
            errors,
            successCount: results.filter(r => r !== undefined).length,
            errorCount: errors.length
        };
    }

    // å†…éƒ¨æ–¹æ³•
    async _executeOperation(operation) {
        if (typeof operation === 'function') {
            return await operation();
        } else if (operation && typeof operation.then === 'function') {
            return await operation;
        } else {
            throw new Error('Operation must be a function or Promise');
        }
    }

    _shouldRetry(error) {
        // æ£€æŸ¥é”™è¯¯ä»£ç 
        if (error.code && this.retryableErrors.includes(error.code)) {
            return true;
        }
        
        // æ£€æŸ¥HTTPçŠ¶æ€ç 
        if (error.response && this.retryableHttpCodes.includes(error.response.status)) {
            return true;
        }
        
        // æ£€æŸ¥é”™è¯¯æ¶ˆæ¯ä¸­çš„å…³é”®è¯
        const retryableKeywords = ['timeout', 'reset', 'refused', 'unavailable'];
        const errorMessage = error.message.toLowerCase();
        
        return retryableKeywords.some(keyword => errorMessage.includes(keyword));
    }

    _calculateDelay(attempt, options = {}) {
        const baseDelay = options.baseDelay || this.baseDelay;
        const maxDelay = options.maxDelay || this.maxDelay;
        const backoffFactor = options.backoffFactor || this.backoffFactor;
        const jitter = options.jitter !== false;
        
        // æŒ‡æ•°é€€é¿
        let delay = baseDelay * Math.pow(backoffFactor, attempt);
        
        // é™åˆ¶æœ€å¤§å»¶è¿Ÿ
        delay = Math.min(delay, maxDelay);
        
        // æ·»åŠ éšæœºæŠ–åŠ¨
        if (jitter) {
            const jitterAmount = delay * 0.1; // 10%çš„æŠ–åŠ¨
            delay += (Math.random() - 0.5) * 2 * jitterAmount;
        }
        
        this.stats.totalDelayTime += delay;
        
        return Math.max(0, Math.floor(delay));
    }

    async _delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    _getCircuitBreaker(context, config) {
        // ç®€åŒ–çš„æ–­è·¯å™¨å®ç°
        if (!this.circuitBreakers) {
            this.circuitBreakers = new Map();
        }
        
        if (!this.circuitBreakers.has(context)) {
            this.circuitBreakers.set(context, new CircuitBreaker(config));
        }
        
        return this.circuitBreakers.get(context);
    }

    // ç»Ÿè®¡æ–¹æ³•
    getStats() {
        return {
            ...this.stats,
            averageDelayTime: this.stats.totalAttempts > 0 ? 
                this.stats.totalDelayTime / this.stats.totalAttempts : 0
        };
    }

    resetStats() {
        this.stats = {
            totalAttempts: 0,
            successfulRetries: 0,
            failedRetries: 0,
            totalDelayTime: 0
        };
    }
}

// ç®€åŒ–çš„æ–­è·¯å™¨å®ç°
class CircuitBreaker {
    constructor(config = {}) {
        this.failureThreshold = config.failureThreshold || 5;
        this.timeout = config.timeout || 60000; // 1åˆ†é’Ÿ
        this.monitoringPeriod = config.monitoringPeriod || 10000; // 10ç§’
        
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.lastSuccessTime = null;
    }

    isOpen() {
        if (this.state === 'OPEN') {
            // æ£€æŸ¥æ˜¯å¦åº”è¯¥è½¬ä¸ºåŠå¼€çŠ¶æ€
            if (Date.now() - this.lastFailureTime > this.timeout) {
                this.state = 'HALF_OPEN';
                return false;
            }
            return true;
        }
        
        return false;
    }

    recordSuccess() {
        this.failureCount = 0;
        this.lastSuccessTime = Date.now();
        this.state = 'CLOSED';
    }

    recordFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        
        if (this.failureCount >= this.failureThreshold) {
            this.state = 'OPEN';
        }
    }
}

module.exports = RetryHelper;

/***/ }),
/* 231 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const https = __webpack_require__(153);
const http = __webpack_require__(152);
const crypto = __webpack_require__(8);
const URL = (__webpack_require__(154).URL);
const backendApiConfig = __webpack_require__(124);
const config = __webpack_require__(123);

/**
 * æ–°ç‰ˆæœ¬åµŒå…¥å®¢æˆ·ç«¯
 * é€‚é…æ–°çš„ /api/v1/codebase/embed æ¥å£
 */
class EmbeddingClient {
    constructor(options = {}) {
        // ä»ç°æœ‰é…ç½®ç³»ç»Ÿè·å–é…ç½®
        const userConfig = config.getAll();
        
        // è§£æAPIç«¯ç‚¹ï¼ˆæ”¯æŒ<SERVER_IP>å ä½ç¬¦æ ¼å¼ï¼‰
        let apiEndpoint = options.apiEndpoint || userConfig.apiEndpoint;
        if (apiEndpoint && apiEndpoint.includes('<SERVER_IP>')) {
            const serverIP = process.env.BACKEND_API_SERVER_IP || '42.193.14.136:8087';
            const protocol = process.env.BACKEND_API_PROTOCOL || 'http';
            apiEndpoint = apiEndpoint.replace('<SERVER_IP>', serverIP);
            
            // å¦‚æœåè®®ä¸åŒ¹é…ï¼Œæ›´æ–°åè®®
            if (apiEndpoint.startsWith('https://') && protocol === 'http') {
                apiEndpoint = apiEndpoint.replace('https://', 'http://');
            } else if (apiEndpoint.startsWith('http://') && protocol === 'https') {
                apiEndpoint = apiEndpoint.replace('http://', 'https://');
            }
        }
        
        // è§£æURLè·å–åŸºç¡€ä¿¡æ¯
        const url = new URL(apiEndpoint || 'http://42.193.14.136:8087/api/v1/codebase/embed');
        this.baseURL = `${url.protocol}//${url.host}`;
        
        this.config = {
            baseURL: this.baseURL,
            token: options.token || process.env.BACKEND_API_TOKEN || userConfig.token || 'test_auth_token',
            timeout: options.timeout || userConfig.timeout || 30000,
            batchSize: options.batchSize || userConfig.batchSize || 100,
            maxRetries: options.maxRetries || userConfig.maxRetries || 3,
            retryDelay: options.retryDelay || userConfig.retryDelay || 1000,
            logLevel: options.logLevel || 'info',
        };
        
        // æ–°çš„APIç«¯ç‚¹
        this.endpoints = {
            embed: '/api/v1/codebase/embed',
            upsert: '/api/v1/codebase/upsert'
        };
        
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            totalProcessingTime: 0,
        };
        
        this._log('info', `EmbeddingClient initialized with baseURL: ${this.baseURL}`);
    }

    /**
     * ç”ŸæˆéšæœºID
     */
    _generateId() {
        return `req-${crypto.randomBytes(8).toString('hex')}`;
    }

    /**
     * ç”ŸæˆUUIDæ ¼å¼çš„è¯·æ±‚ID
     */
    _generateRequestId() {
        return `req-${crypto.randomBytes(8).toString('hex')}`;
    }

    /**
     * åµŒå…¥ä»£ç å— - æ–°æ¥å£æ ¼å¼
     * @param {Array} codeBlocks - ä»£ç å—æ•°ç»„
     * @param {Object} options - å¤„ç†é€‰é¡¹
     */
    async embedCodeBlocks(codeBlocks, options = {}) {
        const startTime = Date.now();
        
        try {
            // éªŒè¯å¹¶è·å–å¤„ç†åçš„ä»£ç å—
            const validatedBlocks = this._validateCodeBlocks(codeBlocks);
            
            // å‡†å¤‡æ–°æ¥å£æ ¼å¼çš„è¯·æ±‚æ•°æ®
            const requestData = {
                requestId: this._generateRequestId(),
                uniqueId: options.uniqueId || `${Date.now()}-unknown-unknown`,
                parserVersion: options.parserVersion || "v0.1.2",
                timestamp: new Date().toISOString(),
                processingMode: options.processingMode || "sync",
                codeChunks: validatedBlocks.map(block => ({
                    chunkId: block.chunkId,
                    filePath: block.filePath,
                    language: block.language || this._detectLanguage(block.filePath),
                    startLine: block.startLine || 1,
                    endLine: block.endLine || 1,
                    content: block.content,
                    parser: block.parser || "ast_parser"
                }))
            };

            
            this._log('info', `Processing ${validatedBlocks.length} code blocks with requestId: ${requestData.requestId}`);
            
            // å‘é€è¯·æ±‚åˆ°æ–°çš„æ¥å£
            const response = await this._makeRequest('POST', this.endpoints.embed, requestData);
            
            const processingTime = Date.now() - startTime;
            this._updateStats(true, processingTime);
            
            // å¤„ç†å“åº”å¹¶è½¬æ¢ä¸ºåŸæ ¼å¼å…¼å®¹
            const result = this._processNewEmbedResponse(response, validatedBlocks);
            
            this._log('info', `Successfully processed ${validatedBlocks.length} code blocks in ${processingTime}ms`);
            return result;
            
        } catch (error) {
            const processingTime = Date.now() - startTime;
            this._updateStats(false, processingTime);
            
            this._log('error', `Failed to process code blocks: ${error.message}`);
            throw error;
        }
    }

    /**
     * è·å–å•ä¸ªæŸ¥è¯¢çš„åµŒå…¥å‘é‡ï¼ˆç”¨äºæœç´¢åŠŸèƒ½ï¼‰
     * @param {string} query - æŸ¥è¯¢å­—ç¬¦ä¸²
     * @param {Object} options - å¤„ç†é€‰é¡¹
     */
    async getEmbedding(query, options = {}) {
        const startTime = Date.now();
        
        try {
            if (!query || typeof query !== 'string') {
                throw new Error('Query must be a non-empty string');
            }

            if (Buffer.byteLength(query, 'utf8') > 10240) { // 10KB
                throw new Error('Query exceeds 10KB limit');
            }

            this._log('info', `Getting embedding for query: "${query.substring(0, 50)}${query.length > 50 ? '...' : ''}"`);

            // å°†æŸ¥è¯¢åŒ…è£…ä¸ºä»£ç å—æ ¼å¼ä»¥å¤ç”¨ç°æœ‰API
            const queryBlock = {
                chunkId: options.queryId || `query_${this._generateId()}`,
                filePath: 'search_query',
                language: 'text',
                startLine: 1,
                endLine: 1,
                content: query,
                parser: 'search'
            };

            // ä½¿ç”¨embedCodeBlocksæ–¹æ³•å¤„ç†å•ä¸ªæŸ¥è¯¢
            const result = await this.embedCodeBlocks([queryBlock], {
                ...options,
                processingMode: 'sync'
            });

            const processingTime = Date.now() - startTime;

            // æå–ç¬¬ä¸€ä¸ªç»“æœçš„å‘é‡ï¼Œæ”¯æŒå‹ç¼©å‘é‡æ ¼å¼
            if (result.results && result.results.length > 0) {
                const firstResult = result.results[0];
                if (firstResult.status === 'success') {
                    this._log('info', `Successfully generated embedding for query in ${processingTime}ms`);
                    
                    // æ”¯æŒå‹ç¼©å‘é‡æ ¼å¼
                    const response = {
                        vector: firstResult.vector,
                        compressedVector: firstResult.compressedVector,
                        isCompressed: firstResult.isCompressed || false,
                        vectorDimension: firstResult.vectorDimension,
                        processingTimeMs: firstResult.processingTimeMs,
                        modelVersion: firstResult.modelVersion
                    };
                    
                    // è®°å½•å‹ç¼©å‘é‡ä¿¡æ¯
                    if (firstResult.isCompressed) {
                        this._log('info', `Query embedding is compressed: compressedVector length = ${firstResult.compressedVector ? firstResult.compressedVector.length : 'null'}`);
                    }
                    
                    return response;
                } else {
                    throw new Error(`Failed to generate embedding: ${firstResult.error}`);
                }
            } else {
                throw new Error('No embedding result returned');
            }
            
        } catch (error) {
            this._log('error', `Failed to get embedding for query: ${error.message}`);
            throw error;
        }
    }

    /**
     * å¤„ç†æ–°æ¥å£çš„å“åº”æ ¼å¼ï¼ˆæ”¯æŒå‹ç¼©å‘é‡ï¼‰
     */
    _processNewEmbedResponse(response, originalBlocks) {
        try {
            // å¢å¼ºæ—¥å¿—è®°å½•ï¼Œæ˜¾ç¤ºå®Œæ•´çš„å“åº”ä¿¡æ¯ï¼ˆå¼ºåˆ¶è¾“å‡ºï¼‰

            
            // å…¼å®¹åç«¯è¿”å›çš„å­—æ®µåé”™è¯¯ï¼šæ”¯æŒ "status:" å’Œ "status"
            const status = response.status || response['status:'];
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºæˆåŠŸå“åº”
            // å¦‚æœæœ‰æ˜ç¡®çš„é”™è¯¯å­—æ®µï¼ˆdetail, error, messageï¼‰ï¼Œåˆ™è®¤ä¸ºæ˜¯é”™è¯¯å“åº”
            const hasErrorField = response.detail || response.error || response.message;
            const isSuccessStatus = status === 'success';
            const hasSuccessFields = response.results || response.processed !== undefined;
            
            if (isSuccessStatus || (!hasErrorField && hasSuccessFields)) {
                // å¤„ç†å‹ç¼©å‘é‡æ ¼å¼
                const processedResults = this._processCompressedVectors(response.results);
                
                return {
                    status: 'success',
                    requestId: response.requestId,
                    processed: response.processed,
                    skipped: response.skipped,
                    results: processedResults,
                    totalProcessingTimeMs: response.totalProcessingTimeMs,
                    timestamp: response.timestamp,
                    processingMode: 'sync'
                };
            } else {
                // ä¼˜å…ˆæ£€æŸ¥å„ç§å¯èƒ½çš„é”™è¯¯å­—æ®µ
                const errorMsg = response.error || response.detail || response.message || 'Unknown error occurred';
                console.error(`ğŸ”¥ [EmbeddingClient] Response indicates failure. Status: "${status}", Error: "${errorMsg}"`);
                console.error(`ğŸ”¥ [EmbeddingClient] Available error fields:`, {
                    error: response.error,
                    detail: response.detail,
                    message: response.message
                });
                throw new Error(errorMsg);
            }
        } catch (error) {
            console.error(`ğŸ”¥ [EmbeddingClient] Failed to process embed response: ${error.message}`);
            console.error(`ğŸ”¥ [EmbeddingClient] Full response object:`, JSON.stringify(response, null, 2));
            throw error;
        }
    }

    /**
     * å¤„ç†å‹ç¼©å‘é‡æ ¼å¼çš„ç»“æœ
     */
    _processCompressedVectors(results) {
        if (!Array.isArray(results)) {
            return results;
        }

        return results.map(result => {
            const processedResult = { ...result };

            // å¤„ç†å‹ç¼©å‘é‡
            if (result.isCompressed === true) {
                // ç¡®ä¿å‹ç¼©æ ¼å¼çš„æ•°æ®ç»“æ„æ­£ç¡®
                processedResult.vector = null;
                processedResult.compressedVector = result.compressedVector;
                processedResult.isCompressed = true;
            } else {
                // å¦‚æœä¸æ˜¯å‹ç¼©æ ¼å¼ï¼Œä½¿ç”¨åŸå§‹å‘é‡
                processedResult.vector = result.vector;
                processedResult.compressedVector = null;
                processedResult.isCompressed = false;
            }

            return processedResult;
        });
    }

    /**
     * éªŒè¯ä»£ç å—æ•°æ®
     */
    _validateCodeBlocks(codeBlocks) {
        if (!Array.isArray(codeBlocks)) {
            throw new Error('codeBlocks must be an array');
        }
        
        if (codeBlocks.length === 0) {
            throw new Error('codeBlocks cannot be empty');
        }
        
        if (codeBlocks.length > 100) {
            throw new Error('codeBlocks cannot exceed 100 items');
        }
        
        const validatedBlocks = [];
        
        for (let index = 0; index < codeBlocks.length; index++) {
            const block = codeBlocks[index];
            
            // éªŒè¯å¿…å¡«å­—æ®µ
            if (!block.chunkId) {
                throw new Error(`Code block ${index}: chunkId is required`);
            }
            
            if (!block.filePath) {
                throw new Error(`Code block ${index}: filePath is required`);
            }
            
            if (block.content === undefined || block.content === null) {
                throw new Error(`Code block ${index}: content is required`);
            }
            
            // è¯¦ç»†è®°å½•ç©ºå†…å®¹æƒ…å†µï¼Œä½†ä¸è¿‡æ»¤
            if (block.content === '' || block.content === null || block.content === undefined) {
                console.error(`ğŸš¨ [EmbeddingClient] ç©ºå†…å®¹ä»£ç å—è¯¦æƒ…:`);
                console.error(`   ç´¢å¼•: ${index}`);
                console.error(`   chunkId: ${block.chunkId}`);
                console.error(`   filePath: ${block.filePath}`);
                console.error(`   è¡Œå·èŒƒå›´: ${block.startLine}-${block.endLine}`);
                console.error(`   å†…å®¹ç±»å‹: ${typeof block.content}`);
                console.error(`   å†…å®¹å€¼: ${JSON.stringify(block.content)}`);
                this._log('warn', `Code block ${index} (${block.chunkId}) has empty content`);
            }
            
            // æ£€æŸ¥å†…å®¹é•¿åº¦ï¼ˆ10KBé™åˆ¶ï¼‰
            const contentSize = Buffer.byteLength(block.content, 'utf8');
            if (contentSize > 10240) {
                // è‡ªåŠ¨åˆ†å‰²è¶…å¤§ä»£ç å—è€Œä¸æ˜¯æŠ›å‡ºé”™è¯¯
                this._log('warn', `Code block ${index} exceeds 10KB (${contentSize} bytes), splitting automatically`);
                const splitBlocks = this._splitLargeCodeBlock(block);
                validatedBlocks.push(...splitBlocks);
            } else {
                validatedBlocks.push({
                    chunkId: block.chunkId,
                    filePath: block.filePath,
                    language: block.language || this._detectLanguage(block.filePath),
                    startLine: block.startLine || 1,
                    endLine: block.endLine || 1,
                    content: block.content,
                    parser: block.parser || 'ast_parser'
                });
            }
        }
        
        return validatedBlocks;
    }

    /**
     * åˆ†å‰²è¿‡å¤§çš„ä»£ç å—
     */
    _splitLargeCodeBlock(block, maxSize = 10240) {
        const lines = block.content.split('\n');
        const chunks = [];
        let currentLines = [];
        let currentStartLine = block.startLine || 1;
        let partIndex = 0;
        
        for (let i = 0; i < lines.length; i++) {
            currentLines.push(lines[i]);
            const currentContent = currentLines.join('\n');
            const currentSize = Buffer.byteLength(currentContent, 'utf8');
            
            // å¦‚æœè¾¾åˆ°å¤§å°é™åˆ¶æˆ–æ˜¯æœ€åä¸€è¡Œ
            if (currentSize >= maxSize - 100 || i === lines.length - 1) { // ç•™100å­—èŠ‚ä½™é‡
                if (currentSize > maxSize && currentLines.length > 1) {
                    // ç§»é™¤æœ€åä¸€è¡Œï¼Œä¿å­˜å½“å‰å—
                    currentLines.pop();
                    const finalContent = currentLines.join('\n');
                    
                    chunks.push({
                        chunkId: `${block.chunkId}_part_${partIndex++}`,
                        filePath: block.filePath,
                        language: block.language || this._detectLanguage(block.filePath),
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        content: finalContent,
                        parser: block.parser || 'ast_parser'
                    });
                    
                    // ä»å½“å‰è¡Œé‡æ–°å¼€å§‹ - ä¿®å¤Bug: åº”è¯¥åŸºäºå¤„ç†çš„è¡Œæ•°æ›´æ–°èµ·å§‹è¡Œå·
                    const processedLines = currentLines.length;
                    currentLines = [lines[i]];
                    currentStartLine = currentStartLine + processedLines;
                } else {
                    // ä¿å­˜å½“å‰å—
                    chunks.push({
                        chunkId: `${block.chunkId}_part_${partIndex++}`,
                        filePath: block.filePath,
                        language: block.language || this._detectLanguage(block.filePath),
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        content: currentContent,
                        parser: block.parser || 'ast_parser'
                    });
                    
                    // é‡ç½® - ä¿®å¤Bug: åœ¨é‡ç½®currentLinesä¹‹å‰å…ˆä¿å­˜é•¿åº¦
                    const processedLines = currentLines.length;
                    currentLines = [];
                    currentStartLine = currentStartLine + processedLines;
                }
            }
        }
        
        this._log('info', `Split large code block ${block.chunkId} into ${chunks.length} parts`);
        return chunks;
    }

    /**
     * æ£€æµ‹æ–‡ä»¶è¯­è¨€
     */
    _detectLanguage(filePath) {
        if (!filePath) return 'unknown';
        
        const ext = filePath.split('.').pop()?.toLowerCase();
        
        const languageMap = {
            'js': 'javascript',
            'ts': 'typescript',
            'py': 'python',
            'java': 'java',
            'cpp': 'cpp',
            'c': 'c',
            'cs': 'csharp',
            'go': 'go',
            'rs': 'rust',
            'php': 'php',
            'rb': 'ruby',
            'json': 'json',
            'yaml': 'yaml',
            'yml': 'yaml',
            'xml': 'xml',
            'html': 'html',
            'css': 'css',
            'md': 'markdown'
        };
        
        return languageMap[ext] || 'unknown';
    }

    /**
     * å‘é€HTTPè¯·æ±‚
     */
    async _makeRequest(method, endpoint, data = null) {
        const requestStartTime = process.hrtime.bigint(); // é«˜ç²¾åº¦è¯·æ±‚å¼€å§‹æ—¶é—´
        const url = new URL(endpoint, this.baseURL);
        const isHttps = url.protocol === 'https:';
        
        // ç‰¹åˆ«æ ‡è®°upsertè¯·æ±‚
        const isUpsertRequest = endpoint.includes('/upsert');
        
        if (isUpsertRequest) {
            console.log(`\nğŸŒ ===== HTTP ç½‘ç»œè¯·æ±‚è¯¦æƒ… =====`);
            console.log(`ğŸ“¡ URL: ${method} ${this.baseURL}${endpoint}`);
            console.log(`ğŸ”— åè®®: ${isHttps ? 'HTTPS' : 'HTTP'}`);
            console.log(`ğŸ  ä¸»æœº: ${url.hostname}:${url.port || (isHttps ? 443 : 80)}`);
            console.log(`ğŸ”‘ è®¤è¯: Bearer ${this.config.token.substring(0, 10)}...`);
            console.log(`â±ï¸ è¶…æ—¶: ${this.config.timeout}ms`);
        }
        
        const options = {
            hostname: url.hostname,
            port: url.port || (isHttps ? 443 : 80),
            path: url.pathname + url.search,
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.config.token}`,
                'User-Agent': 'CodeChunker-EmbeddingClient/1.0.0'
            },
            timeout: this.config.timeout
        };

        if (data) {
            const postData = JSON.stringify(data);
            options.headers['Content-Length'] = Buffer.byteLength(postData);
            
            if (isUpsertRequest) {
                console.log(`ğŸ“¦ è¯·æ±‚ä½“å¤§å°: ${Buffer.byteLength(postData)} bytes`);
                console.log(`ğŸ“ Content-Length: ${options.headers['Content-Length']}`);
            }
        }

        return new Promise((resolve, reject) => {
            let connectionStartTime;
            let firstByteTime;
            let responseEndTime;
            
            const req = (isHttps ? https : http).request(options, (res) => {
                firstByteTime = process.hrtime.bigint(); // æ¥æ”¶åˆ°ç¬¬ä¸€ä¸ªå­—èŠ‚çš„æ—¶é—´
                let responseData = '';
                
                res.on('data', (chunk) => {
                    responseData += chunk;
                });
                
                res.on('end', () => {
                    responseEndTime = process.hrtime.bigint(); // å“åº”å®Œå…¨æ¥æ”¶å®Œæˆæ—¶é—´
                    
                    try {
                        // æ£€æŸ¥å“åº”æ•°æ®æ˜¯å¦ä¸ºç©ºæˆ–ä¸å®Œæ•´
                        if (!responseData || responseData.trim().length === 0) {
                            reject(new Error('Empty response from server'));
                            return;
                        }
                        
                        // æ£€æŸ¥å“åº”æ˜¯å¦çœ‹èµ·æ¥åƒJSON
                        if (!responseData.trim().startsWith('{') && !responseData.trim().startsWith('[')) {
                            this._log('error', `Non-JSON response received: ${responseData.substring(0, 200)}...`);
                            reject(new Error(`Invalid response format: expected JSON, got: ${responseData.substring(0, 100)}...`));
                            return;
                        }
                        
                        const parsed = JSON.parse(responseData);
                        
                        // è®¡ç®—ç½‘ç»œé€šä¿¡æ—¶é—´
                        const totalRequestTime = Number(responseEndTime - requestStartTime) / 1000000; // è½¬æ¢ä¸ºæ¯«ç§’
                        const serverProcessingTime = 14; // å·²çŸ¥çš„æœåŠ¡å™¨å†…éƒ¨å¤„ç†æ—¶é—´
                        const networkCommunicationTime = totalRequestTime - serverProcessingTime;
                        
                        // è¯¦ç»†çš„æ—¶é—´åˆ†æ
                        const connectionTime = connectionStartTime ? Number(connectionStartTime - requestStartTime) / 1000000 : 0;
                        const timeToFirstByte = Number(firstByteTime - requestStartTime) / 1000000;
                        const dataTransferTime = Number(responseEndTime - firstByteTime) / 1000000;
                        
                        // è®°å½•ç½‘ç»œæ€§èƒ½åˆ†æï¼ˆå¼ºåˆ¶è¾“å‡ºé‡è¦æ€§èƒ½ä¿¡æ¯ï¼‰
                        console.log(`\nğŸ“Š [ç½‘ç»œæ€§èƒ½åˆ†æ] ${endpoint} æ¥å£è°ƒç”¨æ—¶é—´ç»Ÿè®¡:`);
                        console.log(`â”œâ”€ æ€»è¯·æ±‚æ—¶é—´: ${totalRequestTime.toFixed(2)}ms`);
                        console.log(`â”œâ”€ æœåŠ¡å™¨å¤„ç†æ—¶é—´: ${serverProcessingTime}ms (å·²çŸ¥)`);
                        console.log(`â”œâ”€ ç½‘ç»œé€šä¿¡æ—¶é—´: ${networkCommunicationTime.toFixed(2)}ms`);
                        console.log(`â”œâ”€ è¿æ¥å»ºç«‹æ—¶é—´: ${connectionTime.toFixed(2)}ms`);
                        console.log(`â”œâ”€ é¦–å­—èŠ‚å“åº”æ—¶é—´: ${timeToFirstByte.toFixed(2)}ms`);
                        console.log(`â”œâ”€ æ•°æ®ä¼ è¾“æ—¶é—´: ${dataTransferTime.toFixed(2)}ms`);
                        console.log(`â”œâ”€ å“åº”æ•°æ®å¤§å°: ${Buffer.byteLength(responseData, 'utf8')} bytes`);
                        console.log(`â””â”€ ç½‘ç»œé€šä¿¡å æ¯”: ${((networkCommunicationTime / totalRequestTime) * 100).toFixed(1)}%\n`);
                        
                        // è®°å½•åˆ°æ€§èƒ½åˆ†ææ•°ç»„ä¸­
                        if (!this.networkPerformanceData) {
                            this.networkPerformanceData = [];
                        }
                        
                        this.networkPerformanceData.push({
                            timestamp: new Date().toISOString(),
                            totalRequestTime: totalRequestTime,
                            serverProcessingTime: serverProcessingTime,
                            networkCommunicationTime: networkCommunicationTime,
                            connectionTime: connectionTime,
                            timeToFirstByte: timeToFirstByte,
                            dataTransferTime: dataTransferTime,
                            responseSize: Buffer.byteLength(responseData, 'utf8'),
                            networkRatio: (networkCommunicationTime / totalRequestTime) * 100
                        });
                        
                        // å¦‚æœæœ‰å¤–éƒ¨æ€§èƒ½åˆ†æå™¨ï¼Œè®°å½•è¯¦ç»†ç½‘ç»œæ•°æ®
                        if (this.performanceAnalyzer) {
                            this.performanceAnalyzer.recordDetailedNetworkRequest(
                                'embedding',
                                totalRequestTime,
                                networkCommunicationTime,
                                serverProcessingTime,
                                true
                            );
                        }
                        
                        if (isUpsertRequest) {
                            console.log(`\nğŸ“¥ ===== HTTP å“åº”è¯¦æƒ… =====`);
                            console.log(`ğŸ“Š çŠ¶æ€ç : ${res.statusCode} ${res.statusMessage || ''}`);
                            console.log(`ğŸ“‹ å“åº”å¤´:`, JSON.stringify(res.headers, null, 2));
                            console.log(`ğŸ“„ å“åº”ä½“:`, JSON.stringify(parsed, null, 2));
                            console.log(`ğŸ“¥ ============================\n`);
                        }
                        
                        if (res.statusCode >= 200 && res.statusCode < 300) {
                            resolve(parsed);
                        } else {
                            if (isUpsertRequest) {
                                console.error(`\nâŒ ===== HTTP é”™è¯¯å“åº” =====`);
                                console.error(`ğŸ“Š çŠ¶æ€ç : ${res.statusCode} ${res.statusMessage || ''}`);
                                console.error(`ğŸ“‹ å“åº”å¤´:`, JSON.stringify(res.headers, null, 2));
                                console.error(`ğŸ“„ é”™è¯¯å“åº”ä½“:`, JSON.stringify(parsed, null, 2));
                                console.error(`âŒ ===========================\n`);
                            }
                            
                            const error = new Error(parsed.error || `HTTP ${res.statusCode}`);
                            error.statusCode = res.statusCode;
                            error.response = parsed;
                            reject(error);
                        }
                    } catch (error) {
                        this._log('error', `JSON parse error. Response length: ${responseData.length}, Content: ${responseData.substring(0, 200)}...`);
                        reject(new Error(`Failed to parse response: ${error.message}. Response was: ${responseData.substring(0, 200)}...`));
                    }
                });
            });

            req.on('connect', () => {
                connectionStartTime = process.hrtime.bigint(); // è¿æ¥å»ºç«‹æ—¶é—´
            });

            req.on('error', (error) => {
                if (isUpsertRequest) {
                    console.error(`\nğŸ’¥ ===== HTTP ç½‘ç»œé”™è¯¯ =====`);
                    console.error(`ğŸ“¡ URL: ${method} ${this.baseURL}${endpoint}`);
                    console.error(`âŒ é”™è¯¯ç±»å‹: ${error.constructor.name}`);
                    console.error(`ğŸ“ é”™è¯¯æ¶ˆæ¯: ${error.message}`);
                    console.error(`ğŸ”§ é”™è¯¯ä»£ç : ${error.code || 'N/A'}`);
                    console.error(`ğŸ“š é”™è¯¯å †æ ˆ:`, error.stack);
                    console.error(`ğŸ’¥ ========================\n`);
                }
                reject(new Error(`Request failed: ${error.message}`));
            });

            req.on('timeout', () => {
                if (isUpsertRequest) {
                    console.error(`\nâ° ===== HTTP è¯·æ±‚è¶…æ—¶ =====`);
                    console.error(`ğŸ“¡ URL: ${method} ${this.baseURL}${endpoint}`);
                    console.error(`â±ï¸ è¶…æ—¶è®¾ç½®: ${this.config.timeout}ms`);
                    console.error(`â° ========================\n`);
                }
                req.destroy();
                reject(new Error('Request timeout'));
            });

            if (data) {
                req.write(JSON.stringify(data));
            }
            
            req.end();
        });
    }

    /**
     * æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
     */
    _updateStats(success, processingTime) {
        this.stats.totalRequests++;
        if (success) {
            this.stats.successfulRequests++;
        } else {
            this.stats.failedRequests++;
        }
        this.stats.totalProcessingTime += processingTime;
    }

    /**
     * æ—¥å¿—è®°å½•
     */
    _log(level, message) {
        if (level === 'error' || this.config.logLevel === 'debug' || 
            (this.config.logLevel === 'info' && level === 'info')) {
    
        }
    }

    /**
     * è·å–ç»Ÿè®¡ä¿¡æ¯
     */
    getStats() {
        return {
            ...this.stats,
            averageProcessingTime: this.stats.totalRequests > 0 
                ? this.stats.totalProcessingTime / this.stats.totalRequests 
                : 0
        };
    }

    /**
     * ç”Ÿæˆç½‘ç»œæ€§èƒ½åˆ†ææŠ¥å‘Š
     */
    generateNetworkPerformanceReport() {
        if (!this.networkPerformanceData || this.networkPerformanceData.length === 0) {
            console.log('\nğŸ“Š [ç½‘ç»œæ€§èƒ½æŠ¥å‘Š] æš‚æ— æ€§èƒ½æ•°æ®');
            return null;
        }

        const data = this.networkPerformanceData;
        const count = data.length;

        // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
        const totalRequestTimes = data.map(d => d.totalRequestTime);
        const networkTimes = data.map(d => d.networkCommunicationTime);
        const connectionTimes = data.map(d => d.connectionTime);
        const firstByteTimes = data.map(d => d.timeToFirstByte);
        const transferTimes = data.map(d => d.dataTransferTime);
        const responseSizes = data.map(d => d.responseSize);
        const networkRatios = data.map(d => d.networkRatio);

        const calculateStats = (arr) => ({
            min: Math.min(...arr),
            max: Math.max(...arr),
            avg: arr.reduce((a, b) => a + b, 0) / arr.length,
            median: arr.sort((a, b) => a - b)[Math.floor(arr.length / 2)]
        });

        const totalStats = calculateStats(totalRequestTimes);
        const networkStats = calculateStats(networkTimes);
        const connectionStats = calculateStats(connectionTimes);
        const firstByteStats = calculateStats(firstByteTimes);
        const transferStats = calculateStats(transferTimes);
        const sizeStats = calculateStats(responseSizes);
        const ratioStats = calculateStats(networkRatios);

        const report = {
            summary: {
                totalRequests: count,
                timeRange: {
                    start: data[0].timestamp,
                    end: data[data.length - 1].timestamp
                },
                serverProcessingTime: 14 // å›ºå®šå€¼
            },
            performance: {
                totalRequestTime: totalStats,
                networkCommunicationTime: networkStats,
                connectionTime: connectionStats,
                timeToFirstByte: firstByteStats,
                dataTransferTime: transferStats,
                responseSize: sizeStats,
                networkRatio: ratioStats
            },
            rawData: data
        };

        // è¾“å‡ºè¯¦ç»†æŠ¥å‘Š
        console.log('\n' + '='.repeat(80));
        console.log('ğŸ“Š ç½‘ç»œæ€§èƒ½åˆ†ææŠ¥å‘Š');
        console.log('='.repeat(80));
        console.log(`\nğŸ“ˆ æ€»ä½“ç»Ÿè®¡ (åŸºäº ${count} æ¬¡è¯·æ±‚)`);
        console.log(`â”œâ”€ æ—¶é—´èŒƒå›´: ${new Date(report.summary.timeRange.start).toLocaleString()} ~ ${new Date(report.summary.timeRange.end).toLocaleString()}`);
        console.log(`â””â”€ æœåŠ¡å™¨å¤„ç†æ—¶é—´: ${report.summary.serverProcessingTime}ms (å›ºå®šå€¼)\n`);

        console.log('â±ï¸  æ—¶é—´æ€§èƒ½åˆ†æ:');
        console.log(`â”œâ”€ æ€»è¯·æ±‚æ—¶é—´    : å¹³å‡ ${totalStats.avg.toFixed(2)}ms | æœ€å° ${totalStats.min.toFixed(2)}ms | æœ€å¤§ ${totalStats.max.toFixed(2)}ms | ä¸­ä½æ•° ${totalStats.median.toFixed(2)}ms`);
        console.log(`â”œâ”€ ç½‘ç»œé€šä¿¡æ—¶é—´  : å¹³å‡ ${networkStats.avg.toFixed(2)}ms | æœ€å° ${networkStats.min.toFixed(2)}ms | æœ€å¤§ ${networkStats.max.toFixed(2)}ms | ä¸­ä½æ•° ${networkStats.median.toFixed(2)}ms`);
        console.log(`â”œâ”€ è¿æ¥å»ºç«‹æ—¶é—´  : å¹³å‡ ${connectionStats.avg.toFixed(2)}ms | æœ€å° ${connectionStats.min.toFixed(2)}ms | æœ€å¤§ ${connectionStats.max.toFixed(2)}ms | ä¸­ä½æ•° ${connectionStats.median.toFixed(2)}ms`);
        console.log(`â”œâ”€ é¦–å­—èŠ‚å“åº”æ—¶é—´: å¹³å‡ ${firstByteStats.avg.toFixed(2)}ms | æœ€å° ${firstByteStats.min.toFixed(2)}ms | æœ€å¤§ ${firstByteStats.max.toFixed(2)}ms | ä¸­ä½æ•° ${firstByteStats.median.toFixed(2)}ms`);
        console.log(`â””â”€ æ•°æ®ä¼ è¾“æ—¶é—´  : å¹³å‡ ${transferStats.avg.toFixed(2)}ms | æœ€å° ${transferStats.min.toFixed(2)}ms | æœ€å¤§ ${transferStats.max.toFixed(2)}ms | ä¸­ä½æ•° ${transferStats.median.toFixed(2)}ms\n`);

        console.log('ğŸ“¦ æ•°æ®ä¼ è¾“åˆ†æ:');
        console.log(`â”œâ”€ å“åº”æ•°æ®å¤§å°  : å¹³å‡ ${(sizeStats.avg / 1024).toFixed(2)}KB | æœ€å° ${(sizeStats.min / 1024).toFixed(2)}KB | æœ€å¤§ ${(sizeStats.max / 1024).toFixed(2)}KB`);
        console.log(`â””â”€ ç½‘ç»œæ—¶é—´å æ¯”  : å¹³å‡ ${ratioStats.avg.toFixed(1)}% | æœ€å° ${ratioStats.min.toFixed(1)}% | æœ€å¤§ ${ratioStats.max.toFixed(1)}%\n`);

        console.log('ğŸ¯ æ€§èƒ½ä¼˜åŒ–å»ºè®®:');
        if (networkStats.avg > 100) {
            console.log('â”œâ”€ âš ï¸  ç½‘ç»œé€šä¿¡æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®æ£€æŸ¥ç½‘ç»œè¿æ¥è´¨é‡');
        }
        if (connectionStats.avg > 50) {
            console.log('â”œâ”€ âš ï¸  è¿æ¥å»ºç«‹æ—¶é—´è¾ƒé•¿ï¼Œå»ºè®®è€ƒè™‘è¿æ¥å¤ç”¨æˆ–æ›´è¿‘çš„æœåŠ¡å™¨');
        }
        if (ratioStats.avg > 70) {
            console.log('â”œâ”€ âš ï¸  ç½‘ç»œæ—¶é—´å æ¯”è¿‡é«˜ï¼Œä¸»è¦ç“¶é¢ˆåœ¨ç½‘ç»œé€šä¿¡è€ŒéæœåŠ¡å™¨å¤„ç†');
        }
        if (sizeStats.avg > 100 * 1024) { // 100KB
            console.log('â”œâ”€ âš ï¸  å“åº”æ•°æ®è¾ƒå¤§ï¼Œå»ºè®®è€ƒè™‘æ•°æ®å‹ç¼©æˆ–åˆ†æ‰¹å¤„ç†');
        }
        if (networkStats.avg < 30 && ratioStats.avg < 50) {
            console.log('â”œâ”€ âœ… ç½‘ç»œæ€§èƒ½è‰¯å¥½ï¼Œä¸»è¦å¤„ç†æ—¶é—´åœ¨æœåŠ¡å™¨ç«¯');
        }
        console.log('â””â”€ ğŸ’¡ æŒç»­ç›‘æ§è¿™äº›æŒ‡æ ‡æœ‰åŠ©äºè¯†åˆ«æ€§èƒ½ç“¶é¢ˆå’Œä¼˜åŒ–æ–¹å‘\n');

        console.log('='.repeat(80));

        return report;
    }

    /**
     * æ¸…é™¤ç½‘ç»œæ€§èƒ½æ•°æ®
     */
    clearNetworkPerformanceData() {
        this.networkPerformanceData = [];
        console.log('ğŸ—‘ï¸  [ç½‘ç»œæ€§èƒ½] å·²æ¸…é™¤å†å²æ€§èƒ½æ•°æ®');
    }

    /**
     * è·å–ç½‘ç»œæ€§èƒ½æ•°æ®
     */
    getNetworkPerformanceData() {
        return this.networkPerformanceData || [];
    }
}

module.exports = EmbeddingClient;


/***/ }),
/* 232 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);
const path = __webpack_require__(4);
const KeyManager = __webpack_require__(233);
const CryptoUtils = __webpack_require__(234);
const Logger = __webpack_require__(225);

class PathEncryption {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('PathEncryption', config.logLevel || 'info');
        
        // åŠ å¯†é…ç½®
        this.algorithm = config.algorithm || 'aes-256-ctr';
        this.nonceLength = config.nonceLength || 6; // 6å­—èŠ‚nonce
        this.encoding = config.encoding || 'base64';
        
        // å¯†é’¥ç®¡ç†å™¨
        this.keyManager = null;
        this.cryptoUtils = null;
        
        // ç¼“å­˜é…ç½®
        this.enableCache = config.enableCache !== false;
        this.encryptionCache = new Map(); // path -> encrypted
        this.decryptionCache = new Map(); // encrypted -> path
        this.maxCacheSize = config.maxCacheSize || 1000;
        
        // åˆ†éš”ç¬¦é…ç½®
        this.pathSeparator = config.pathSeparator || '/';
        this.extensionSeparator = config.extensionSeparator || '.';
    }

    async initialize() {
        try {
            this.logger.info('Initializing PathEncryption...');
            
            // æ£€æŸ¥æ˜¯å¦å¯ç”¨å®‰å…¨åŠŸèƒ½
            if (this.config.enabled === false) {
                this.logger.info('Security is disabled, PathEncryption will use passthrough mode');
                return;
            }
            
            // 1. åˆå§‹åŒ–å¯†é’¥ç®¡ç†å™¨
            this.keyManager = new KeyManager(this.config.keyManager);
            await this.keyManager.initialize();
            
            // 2. åˆå§‹åŒ–åŠ å¯†å·¥å…·
            this.cryptoUtils = new CryptoUtils({
                algorithm: this.algorithm,
                nonceLength: this.nonceLength
            });
            
            // 3. éªŒè¯åŠ å¯†è®¾ç½®ï¼ˆä»…åœ¨ç”Ÿäº§ç¯å¢ƒï¼‰
            if (process.env.NODE_ENV === 'production') {
                await this._validateEncryptionSetup();
            } else {
                this.logger.info('Skipping encryption validation in non-production environment');
            }
            
            this.logger.info('PathEncryption initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize PathEncryption:', error);
            throw error;
        }
    }

    encryptPath(originalPath) {
        if (!originalPath || typeof originalPath !== 'string') {
            throw new Error('Invalid path for encryption');
        }
        
        // å¦‚æœå®‰å…¨åŠŸèƒ½ç¦ç”¨ï¼Œç›´æ¥è¿”å›åŸå§‹è·¯å¾„
        if (this.config.enabled === false) {
            return originalPath;
        }
        
        try {
            // æ£€æŸ¥ç¼“å­˜
            if (this.enableCache && this.encryptionCache.has(originalPath)) {
                return this.encryptionCache.get(originalPath);
            }
            
            // æ ‡å‡†åŒ–è·¯å¾„
            const normalizedPath = this._normalizePath(originalPath);
            console.log('æ ‡å‡†åŒ–è·¯å¾„:', normalizedPath);
            
            // åˆ†è§£è·¯å¾„
            const pathInfo = this._segmentPath(normalizedPath);
            console.log('è·¯å¾„åˆ†æ®µç»“æœ:', JSON.stringify(pathInfo, null, 2));
            
            if (!pathInfo || !pathInfo.segments || !Array.isArray(pathInfo.segments)) {
                throw new Error('Invalid path segmentation result');
            }
            
            // åŠ å¯†æ¯ä¸ªæ®µ
            const encryptedSegments = {
                isAbsolute: pathInfo.isAbsolute,
                segments: pathInfo.segments.map(segment => this._encryptSegment(segment))
            };
            
            // é‡ç»„è·¯å¾„
            const encryptedPath = this._reassemblePath(encryptedSegments, pathInfo.isAbsolute);
            
            // æ›´æ–°ç¼“å­˜
            if (this.enableCache) {
                this._updateEncryptionCache(originalPath, encryptedPath);
            }
            
            this.logger.debug(`Encrypted path: ${originalPath.length} chars -> ${encryptedPath.length} chars`);
            
            return encryptedPath;
            
        } catch (error) {
            this.logger.error(`Error encrypting path "${originalPath}":`, error);
            throw error;
        }
    }

    decryptPath(encryptedPath) {
        if (!encryptedPath || typeof encryptedPath !== 'string') {
            throw new Error('Invalid encrypted path for decryption');
        }
        
        // å¦‚æœå®‰å…¨åŠŸèƒ½ç¦ç”¨ï¼Œç›´æ¥è¿”å›åŸå§‹è·¯å¾„
        if (this.config.enabled === false) {
            return encryptedPath;
        }
        
        try {
            // æ£€æŸ¥ç¼“å­˜
            if (this.enableCache && this.decryptionCache.has(encryptedPath)) {
                return this.decryptionCache.get(encryptedPath);
            }
            
            // åˆ†è§£åŠ å¯†è·¯å¾„
            const encryptedSegments = this._segmentEncryptedPath(encryptedPath);
            console.log('åŠ å¯†è·¯å¾„åˆ†æ®µç»“æœ:', JSON.stringify(encryptedSegments, null, 2));
            
            if (!encryptedSegments || !encryptedSegments.segments || !Array.isArray(encryptedSegments.segments)) {
                throw new Error('Invalid encrypted path segmentation result');
            }
            
            // è§£å¯†æ¯ä¸ªæ®µ
            const decryptedSegments = {
                isAbsolute: encryptedSegments.isAbsolute,
                segments: encryptedSegments.segments.map(segment => this._decryptSegment(segment))
            };
            
            // é‡ç»„åŸå§‹è·¯å¾„
            const originalPath = this._reassembleOriginalPath(decryptedSegments, encryptedPath);
            
            // æ›´æ–°ç¼“å­˜
            if (this.enableCache) {
                this._updateDecryptionCache(encryptedPath, originalPath);
            }
            
            this.logger.debug(`Decrypted path: ${encryptedPath.length} chars -> ${originalPath.length} chars`);
            
            return originalPath;
            
        } catch (error) {
            this.logger.error(`Error decrypting path "${encryptedPath}":`, error);
            throw error;
        }
    }

    // æ‰¹é‡åŠ å¯†
    encryptPaths(paths) {
        if (!Array.isArray(paths)) {
            throw new Error('Paths must be an array');
        }
        
        return paths.map(path => ({
            original: path,
            encrypted: this.encryptPath(path)
        }));
    }

    // æ‰¹é‡è§£å¯†
    decryptPaths(encryptedPaths) {
        if (!Array.isArray(encryptedPaths)) {
            throw new Error('Encrypted paths must be an array');
        }
        
        return encryptedPaths.map(encryptedPath => ({
            encrypted: encryptedPath,
            decrypted: this.decryptPath(encryptedPath)
        }));
    }

    // å†…éƒ¨æ–¹æ³•
    _normalizePath(pathStr) {
        // æ ‡å‡†åŒ–è·¯å¾„åˆ†éš”ç¬¦
        return pathStr.replace(/\\/g, this.pathSeparator);
    }

    _segmentPath(pathStr) {
        // åˆ†è§£è·¯å¾„ä¸ºæ®µ
        const segments = [];
        
        // å¤„ç†ç»å¯¹è·¯å¾„æ ‡è¯†
        let workingPath = pathStr;
        let isAbsolute = false;
        
        if (workingPath.startsWith(this.pathSeparator)) {
            isAbsolute = true;
            workingPath = workingPath.substring(1);
        }
        
        // åˆ†å‰²è·¯å¾„æ®µ
        const pathParts = workingPath.split(this.pathSeparator).filter(part => part.length > 0);
        
        for (const part of pathParts) {
            // å¤„ç†æ–‡ä»¶åå’Œæ‰©å±•å
            if (part.includes(this.extensionSeparator)) {
                const lastDotIndex = part.lastIndexOf(this.extensionSeparator);
                const filename = part.substring(0, lastDotIndex);
                const extension = part.substring(lastDotIndex + 1);
                
                if (filename.length > 0) {
                    segments.push({ type: 'filename', value: filename });
                }
                if (extension.length > 0) {
                    segments.push({ type: 'extension', value: extension });
                }
            } else {
                segments.push({ type: 'directory', value: part });
            }
        }
        
        return {
            isAbsolute,
            segments
        };
    }

    _encryptSegment(segment) {
        const key = this.keyManager.getEncryptionKey();
        const nonce = this._generateNonce(segment.value);
        
        // åŠ å¯†æ•°æ®
        const encrypted = this.cryptoUtils.encrypt(segment.value, key, nonce);
        
        // è¿”å›åŠ å¯†åçš„æ®µ
        return {
            type: segment.type,
            value: encrypted
        };
    }

    _decryptSegment(encryptedSegment) {
        const key = this.keyManager.getEncryptionKey();
        
        try {
            // ç›´æ¥ä¼ é€’åŠ å¯†å­—ç¬¦ä¸²ç»™cryptoUtils.decrypt
            const decrypted = this.cryptoUtils.decrypt(encryptedSegment.value, key);
            
            return {
                type: encryptedSegment.type,
                value: decrypted
            };
        } catch (error) {
            this.logger.error(`Failed to decrypt segment: ${error.message}`);
            throw error;
        }
    }

    _generateNonce(value) {
        // ç”Ÿæˆç¡®å®šæ€§nonce
        const hash = crypto.createHash('sha256').update(value).digest();
        return hash.subarray(0, this.nonceLength);
    }

    _reassemblePath(encryptedSegments, originalPath) {
        const { isAbsolute, segments } = encryptedSegments;
        
        let path = '';
        if (isAbsolute) {
            path = this.pathSeparator;
        }
        
        let currentFileName = '';
        
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            
            switch (segment.type) {
                case 'directory':
                    if (currentFileName) {
                        path += currentFileName + this.pathSeparator;
                        currentFileName = '';
                    }
                    path += segment.value + this.pathSeparator;
                    break;
                    
                case 'filename':
                    if (currentFileName) {
                        path += currentFileName + this.pathSeparator;
                    }
                    currentFileName = segment.value;
                    break;
                    
                case 'extension':
                    if (currentFileName) {
                        currentFileName += this.extensionSeparator + segment.value;
                    } else {
                        path += this.extensionSeparator + segment.value;
                    }
                    break;
            }
        }
        
        if (currentFileName) {
            path += currentFileName;
        }
        
        // ç§»é™¤æœ«å°¾çš„åˆ†éš”ç¬¦ï¼ˆå¦‚æœä¸æ˜¯æ ¹ç›®å½•ï¼‰
        if (path.length > 1 && path.endsWith(this.pathSeparator)) {
            path = path.substring(0, path.length - 1);
        }
        
        return path;
    }

    _segmentEncryptedPath(encryptedPath) {
        // åˆ†è§£è·¯å¾„ä¸ºæ®µ
        const segments = [];
        
        // å¤„ç†ç»å¯¹è·¯å¾„æ ‡è¯†
        let workingPath = encryptedPath;
        let isAbsolute = false;
        
        if (workingPath.startsWith(this.pathSeparator)) {
            isAbsolute = true;
            workingPath = workingPath.substring(1);
        }
        
        // åˆ†å‰²è·¯å¾„æ®µ
        const pathParts = workingPath.split(this.pathSeparator).filter(part => part.length > 0);
        
        for (let i = 0; i < pathParts.length; i++) {
            const part = pathParts[i];
            const isLastPart = i === pathParts.length - 1;
            
            if (isLastPart && part.includes('.')) {
                // å¤„ç†æœ€åä¸€ä¸ªéƒ¨åˆ†ï¼Œå®ƒå¯èƒ½åŒ…å«æ–‡ä»¶åå’Œæ‰©å±•å
                const parts = part.split('.');
                if (parts.length >= 2) {
                    // ç¬¬ä¸€ä¸ªéƒ¨åˆ†æ˜¯æ–‡ä»¶å
                    segments.push({
                        type: 'filename',
                        value: parts[0] + '.' + parts[1]
                    });
                    // ç¬¬äºŒä¸ªéƒ¨åˆ†æ˜¯æ‰©å±•å
                    if (parts.length >= 3) {
                        segments.push({
                            type: 'extension',
                            value: parts[2] + '.' + parts[3]
                        });
                    }
                } else {
                    segments.push({
                        type: 'directory',
                        value: part
                    });
                }
            } else {
                segments.push({
                    type: 'directory',
                    value: part
                });
            }
        }
        
        return {
            isAbsolute,
            segments
        };
    }

    _reassembleOriginalPath(decryptedSegments, originalEncryptedPath) {
        return this._reassemblePath(decryptedSegments, originalEncryptedPath);
    }

    _updateEncryptionCache(original, encrypted) {
        if (this.encryptionCache.size >= this.maxCacheSize) {
            // ç®€å•çš„LRUç­–ç•¥ï¼šåˆ é™¤æœ€æ—©çš„æ¡ç›®
            const firstKey = this.encryptionCache.keys().next().value;
            this.encryptionCache.delete(firstKey);
        }
        
        this.encryptionCache.set(original, encrypted);
    }

    _updateDecryptionCache(encrypted, decrypted) {
        if (this.decryptionCache.size >= this.maxCacheSize) {
            const firstKey = this.decryptionCache.keys().next().value;
            this.decryptionCache.delete(firstKey);
        }
        
        this.decryptionCache.set(encrypted, decrypted);
    }

    async _validateEncryptionSetup() {
        try {
            const testPath = '/test/path/file.txt';
            console.log('éªŒè¯åŠ å¯†è®¾ç½®ï¼Œæµ‹è¯•è·¯å¾„:', testPath);
            
            // æµ‹è¯•è·¯å¾„åˆ†æ®µ
            const pathInfo = this._segmentPath(testPath);
            console.log('è·¯å¾„åˆ†æ®µç»“æœ:', JSON.stringify(pathInfo, null, 2));
            
            // æµ‹è¯•åŠ å¯†
            const encrypted = this.encryptPath(testPath);
            console.log('åŠ å¯†ç»“æœ:', encrypted);
            
            // æµ‹è¯•è§£å¯†
            const decrypted = this.decryptPath(encrypted);
            console.log('è§£å¯†ç»“æœ:', decrypted);
            
            if (decrypted !== testPath) {
                throw new Error(`Encryption/decryption validation failed: ${decrypted} !== ${testPath}`);
            }
            
            this.logger.debug('Encryption setup validation passed');
            
        } catch (error) {
            console.error('åŠ å¯†è®¾ç½®éªŒè¯å¤±è´¥:', error);
            throw new Error(`Encryption setup validation failed: ${error.message}`);
        }
    }

    // å·¥å…·æ–¹æ³•
    clearCache() {
        this.encryptionCache.clear();
        this.decryptionCache.clear();
        this.logger.debug('Encryption cache cleared');
    }

    getCacheStats() {
        return {
            encryptionCacheSize: this.encryptionCache.size,
            decryptionCacheSize: this.decryptionCache.size,
            maxCacheSize: this.maxCacheSize
        };
    }

    async shutdown() {
        try {
            if (this.keyManager) {
                await this.keyManager.shutdown();
                this.keyManager = null;
            }
            
            if (this.enableCache) {
                this.clearCache();
            }
            
            this.logger.info('PathEncryption shutdown completed');
            
        } catch (error) {
            this.logger.error('Error during PathEncryption shutdown:', error);
        }
    }
}

module.exports = PathEncryption;

/***/ }),
/* 233 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);
const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const Logger = __webpack_require__(225);

class KeyManager {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('KeyManager', config.logLevel || 'info');
        
        // å¯†é’¥é…ç½®
        this.keyLength = config.keyLength || 32; // 256ä½å¯†é’¥
        this.keyDerivationIterations = config.keyDerivationIterations || 100000;
        this.keyDerivationAlgorithm = config.keyDerivationAlgorithm || 'pbkdf2';
        
        // å­˜å‚¨é…ç½®
        this.keyStorePath = config.keyStorePath || path.join(process.cwd(), '.vector-keys');
        this.keyFileName = config.keyFileName || 'master.key';
        this.secureStorage = config.secureStorage !== false;
        
        // å†…å­˜ä¸­çš„å¯†é’¥
        this.masterKey = null;
        this.derivedKeys = new Map(); // purpose -> key
        
        // å¯†é’¥è½®æ¢
        this.enableKeyRotation = config.enableKeyRotation !== false;
        
        // æ ¹æ®ç¯å¢ƒè®¾ç½®ä¸åŒçš„è½®æ¢é—´éš”
        if (process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'development') {
            // æµ‹è¯•å’Œå¼€å‘ç¯å¢ƒï¼šç¦ç”¨è‡ªåŠ¨è½®æ¢
            this.enableKeyRotation = false;
            this.keyRotationInterval = 60 * 60 * 1000; // 1å°æ—¶ï¼ˆå¦‚æœæ‰‹åŠ¨å¯ç”¨ï¼‰
        } else {
            // ç”Ÿäº§ç¯å¢ƒï¼š30å¤©
            this.keyRotationInterval = config.keyRotationInterval || 30 * 24 * 60 * 60 * 1000;
        }
        
        this.keyRotationTimer = null;
        
        // å¦‚æœçˆ¶çº§é…ç½®æ˜ç¡®ç¦ç”¨äº†VectorManagerï¼Œä¹Ÿç¦ç”¨å¯†é’¥è½®æ¢
        if (config.enabled === false) {
            this.enableKeyRotation = false;
        }
    }

    
    async initialize() {
        try {
            this.logger.info('Initializing KeyManager...');
            
            // 1. ç¡®ä¿å¯†é’¥å­˜å‚¨ç›®å½•å­˜åœ¨
            await this._ensureKeyStoreDirectory();
            
            // 2. åŠ è½½æˆ–ç”Ÿæˆä¸»å¯†é’¥
            await this._loadOrGenerateMasterKey();
            
            // 3. æ´¾ç”Ÿå·¥ä½œå¯†é’¥
            await this._deriveWorkingKeys();
            
            // 4. å¯åŠ¨å¯†é’¥è½®æ¢ï¼ˆå¦‚æœå¯ç”¨ï¼‰
            if (this.enableKeyRotation) {
                this._startKeyRotation();
            }
            
            this.logger.info('KeyManager initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize KeyManager:', error);
            throw error;
        }
    }

    getEncryptionKey(purpose = 'default') {
        const key = this.derivedKeys.get(purpose);
        if (!key) {
            throw new Error(`No key found for purpose: ${purpose}`);
        }
        return key;
    }

    async generateNewKey(purpose = 'default') {
        try {
            const salt = crypto.randomBytes(16);
            const key = await this._deriveKey(this.masterKey, salt, purpose);
            
            this.derivedKeys.set(purpose, key);
            
            // å¯é€‰ï¼šæŒä¹…åŒ–æ´¾ç”Ÿå¯†é’¥ä¿¡æ¯ï¼ˆä¸åŒ…å«å¯†é’¥æœ¬èº«ï¼‰
            await this._saveKeyMetadata(purpose, salt);
            
            this.logger.info(`Generated new key for purpose: ${purpose}`);
            return key;
            
        } catch (error) {
            this.logger.error(`Error generating key for purpose ${purpose}:`, error);
            throw error;
        }
    }

    async rotateKeys() {
        try {
            this.logger.info('Starting key rotation...');
            
            // 1. ç”Ÿæˆæ–°çš„ä¸»å¯†é’¥
            const newMasterKey = crypto.randomBytes(this.keyLength);
            
            // 2. å¤‡ä»½å½“å‰å¯†é’¥
            await this._backupCurrentKey();
            
            // 3. æ›´æ–°ä¸»å¯†é’¥
            this.masterKey = newMasterKey;
            
            // 4. é‡æ–°æ´¾ç”Ÿå·¥ä½œå¯†é’¥
            await this._deriveWorkingKeys();
            
            // 5. ä¿å­˜æ–°å¯†é’¥
            await this._saveMasterKey();
            
            this.logger.info('Key rotation completed successfully');
            
        } catch (error) {
            this.logger.error('Error during key rotation:', error);
            throw error;
        }
    }

    // å†…éƒ¨æ–¹æ³•
    async _ensureKeyStoreDirectory() {
        try {
            await fs.ensureDir(this.keyStorePath);
            
            // è®¾ç½®ç›®å½•æƒé™ï¼ˆä»…æ‰€æœ‰è€…å¯è®¿é—®ï¼‰
            if (process.platform !== 'win32') {
                await fs.chmod(this.keyStorePath, 0o700);
            }
            
        } catch (error) {
            throw new Error(`Failed to create key store directory: ${error.message}`);
        }
    }

    async _loadOrGenerateMasterKey() {
        const keyFilePath = path.join(this.keyStorePath, this.keyFileName);

        try {
            if (await fs.pathExists(keyFilePath)) {
                // åŠ è½½ç°æœ‰å¯†é’¥
                await this._loadMasterKey();
                this.logger.debug('Loaded existing master key');
            } else {
                // ç”Ÿæˆæ–°å¯†é’¥
                await this._generateMasterKey();
                await this._saveMasterKey();
                this.logger.info('Generated new master key');
            }
            
        } catch (error) {
            console.error('åŠ è½½æˆ–ç”Ÿæˆå¯†é’¥å¤±è´¥:', error);
            throw new Error(`Failed to load or generate master key: ${error.message}`);
        }
    }

    async _generateMasterKey() {
        this.masterKey = crypto.randomBytes(this.keyLength);
    }

    async _loadMasterKey() {
        const keyFilePath = path.join(this.keyStorePath, this.keyFileName);
        
        try {
            const keyData = await fs.readFile(keyFilePath);
            
            // æ£€æŸ¥ç©ºæ–‡ä»¶
            if (keyData.length === 0) {
                await fs.remove(keyFilePath);
                await this._generateMasterKey();
                await this._saveMasterKey();
                return;
            }
            
            if (this.secureStorage) {
                this.masterKey = this._decryptStoredKey(keyData);
            } else {
                // å¦‚æœå¯†é’¥é•¿åº¦ä¸è¶³ï¼Œç”¨0å¡«å……
                if (keyData.length < this.keyLength) {
                    this.masterKey = Buffer.concat([keyData, Buffer.alloc(this.keyLength - keyData.length)]);
                } else if (keyData.length > this.keyLength) {
                    this.masterKey = keyData.slice(0, this.keyLength);
                } else {
                    this.masterKey = keyData;
                }
            }
            
            if (this.masterKey.length !== this.keyLength) {
                throw new Error(`Invalid key length: ${this.masterKey.length} (expected ${this.keyLength})`);
            }
            
        } catch (error) {
            console.error('åŠ è½½å¯†é’¥å¤±è´¥:', error);
            throw new Error(`Failed to load master key: ${error.message}`);
        }
    }

    async _saveMasterKey() {
        const keyFilePath = path.join(this.keyStorePath, this.keyFileName);
        
        try {
            let keyData = this.masterKey;
            
            if (this.secureStorage) {
                // å¦‚æœå¯ç”¨äº†å®‰å…¨å­˜å‚¨ï¼ŒåŠ å¯†å¯†é’¥åå­˜å‚¨
                keyData = this._encryptKeyForStorage(this.masterKey);
            }
            
            await fs.writeFile(keyFilePath, keyData);
            
            // è®¾ç½®æ–‡ä»¶æƒé™ï¼ˆä»…æ‰€æœ‰è€…å¯è¯»å†™ï¼‰
            if (process.platform !== 'win32') {
                await fs.chmod(keyFilePath, 0o600);
            }
            
        } catch (error) {
            throw new Error(`Failed to save master key: ${error.message}`);
        }
    }

    async _deriveWorkingKeys() {
        const purposes = ['default', 'path', 'metadata'];
        
        for (const purpose of purposes) {
            const salt = this._generateDeterministicSalt(purpose);
            const key = await this._deriveKey(this.masterKey, salt, purpose);
            this.derivedKeys.set(purpose, key);
        }
        
        this.logger.debug(`Derived ${purposes.length} working keys`);
    }

    async _deriveKey(masterKey, salt, purpose) {
        return new Promise((resolve, reject) => {
            crypto.pbkdf2(masterKey, salt, this.keyDerivationIterations, this.keyLength, 'sha256', (err, derivedKey) => {
                if (err) {
                    reject(new Error(`Key derivation failed for ${purpose}: ${err.message}`));
                } else {
                    resolve(derivedKey);
                }
            });
        });
    }

    _generateDeterministicSalt(purpose) {
        // ç”Ÿæˆç¡®å®šæ€§ç›å€¼ï¼ŒåŸºäºç”¨é€”å’Œä¸€äº›å›ºå®šå€¼
        const hash = crypto.createHash('sha256');
        hash.update(purpose);
        hash.update(this.config.applicationId || 'vectormanager');
        return hash.digest().subarray(0, 16); // ä½¿ç”¨å‰16å­—èŠ‚ä½œä¸ºç›å€¼
    }

    async _backupCurrentKey() {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupFileName = `master_${timestamp}.key.bak`;
        const backupPath = path.join(this.keyStorePath, backupFileName);
        
        try {
            const currentKeyPath = path.join(this.keyStorePath, this.keyFileName);
            
            if (await fs.pathExists(currentKeyPath)) {
                await fs.copy(currentKeyPath, backupPath);
                this.logger.debug(`Backed up current key to ${backupFileName}`);
            }
            
        } catch (error) {
            this.logger.warn(`Failed to backup current key: ${error.message}`);
        }
    }

    async _saveKeyMetadata(purpose, salt) {
        const metadataPath = path.join(this.keyStorePath, `${purpose}.metadata`);
        
        const metadata = {
            purpose: purpose,
            salt: salt.toString('base64'),
            createdAt: new Date().toISOString(),
            algorithm: this.keyDerivationAlgorithm,
            iterations: this.keyDerivationIterations
        };
        
        try {
            await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
            
        } catch (error) {
            this.logger.warn(`Failed to save key metadata for ${purpose}: ${error.message}`);
        }
    }

    _encryptKeyForStorage(key) {
        // ç®€åŒ–å®ç°ï¼šä½¿ç”¨ç³»ç»Ÿç‰¹å®šçš„ä¿¡æ¯ä½œä¸ºå¯†ç 
        const password = this._getSystemPassword();
        const salt = crypto.randomBytes(16);
        const iv = crypto.randomBytes(16);
        
        const derivedKey = crypto.pbkdf2Sync(password, salt, 10000, 32, 'sha256');
        const cipher = crypto.createCipheriv('aes-256-gcm', derivedKey, iv);
        
        let encrypted = cipher.update(key);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        
        const authTag = cipher.getAuthTag();
        
        // ç»„åˆ salt + iv + authTag + encrypted
        return Buffer.concat([salt, iv, authTag, encrypted]);
    }

    _decryptStoredKey(encryptedData) {
        const password = this._getSystemPassword();
        // è§£æç»„åˆæ•°æ®
        const salt = encryptedData.subarray(0, 16);
        const iv = encryptedData.subarray(16, 32);
        const authTag = encryptedData.subarray(32, 48);
        const encrypted = encryptedData.subarray(48);
    

    
        const derivedKey = crypto.pbkdf2Sync(password, salt, 10000, 32, 'sha256');
        const decipher = crypto.createDecipheriv('aes-256-gcm', derivedKey, iv);
        decipher.setAuthTag(authTag);
    
        let decrypted = decipher.update(encrypted);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
    
        return decrypted;
    }

    _getSystemPassword() {
        // åŸºäºç³»ç»Ÿä¿¡æ¯ç”Ÿæˆå¯†ç ï¼ˆç®€åŒ–å®ç°ï¼‰
        const systemInfo = [
            process.platform,
            process.arch,
            (__webpack_require__(146).hostname)(),
            this.config.applicationId || 'vectormanager'
        ].join('|');
        
        return crypto.createHash('sha256').update(systemInfo).digest();
    }

    _startKeyRotation() {
        // é˜²æ­¢é‡å¤å¯åŠ¨å®šæ—¶å™¨
        if (this.keyRotationTimer) {
            this.logger.warn('Key rotation timer already running, skipping start');
            return;
        }
        
        // ç¡®ä¿è½®æ¢é—´éš”åˆç†ï¼ˆè‡³å°‘1åˆ†é’Ÿï¼‰
        if (this.keyRotationInterval < 60000) {
            this.logger.warn(`Key rotation interval too short: ${this.keyRotationInterval}ms, setting to 1 hour`);
            this.keyRotationInterval = 60 * 60 * 1000; // 1å°æ—¶
        }
        
        this.keyRotationTimer = setInterval(async () => {
            try {
                await this.rotateKeys();
            } catch (error) {
                this.logger.error('Automatic key rotation failed:', error);
            }
        }, this.keyRotationInterval);
        
        const dayInterval = this.keyRotationInterval / 1000 / 60 / 60 / 24;
        if (dayInterval >= 1) {
            this.logger.info(`Key rotation scheduled every ${dayInterval.toFixed(1)} days`);
        } else {
            const hourInterval = this.keyRotationInterval / 1000 / 60 / 60;
            this.logger.info(`Key rotation scheduled every ${hourInterval.toFixed(1)} hours`);
        }
    }

    async shutdown() {
        if (this.keyRotationTimer) {
            clearInterval(this.keyRotationTimer);
            this.keyRotationTimer = null;
        }
        
        // æ¸…é™¤å†…å­˜ä¸­çš„å¯†é’¥
        if (this.masterKey) {
            this.masterKey.fill(0);
            this.masterKey = null;
        }
        
        for (const [purpose, key] of this.derivedKeys) {
            key.fill(0);
        }
        this.derivedKeys.clear();
        
        this.logger.info('KeyManager shutdown completed');
    }
}

module.exports = KeyManager;

/***/ }),
/* 234 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

class CryptoUtils {
    constructor(config) {
        this.algorithm = config.algorithm || 'aes-256-ctr';
        this.nonceLength = config.nonceLength || 6;
        this.encoding = config.encoding || 'base64';
    }

    encrypt(plaintext, key, nonce) {
        try {
            console.log('åŠ å¯†å‚æ•°:', {
                plaintext,
                keyLength: key.length,
                nonceLength: nonce ? nonce.length : 0
            });
            
            // åˆ›å»ºcipherå®ä¾‹
            let cipher;
            
            // å¦‚æœæä¾›äº†nonceï¼Œè®¾ç½®åˆå§‹å‘é‡
            if (nonce) {
                const iv = Buffer.alloc(16);
                nonce.copy(iv, 0, 0, Math.min(nonce.length, 16));
                console.log('ä½¿ç”¨IV:', iv.toString('hex'));
                cipher = crypto.createCipheriv(this.algorithm, key, iv);
            } else {
                // ä¸ºå…¼å®¹æ€§ï¼Œå¦‚æœæ²¡æœ‰nonceåˆ™ä½¿ç”¨é›¶åˆå§‹å‘é‡
                const iv = Buffer.alloc(16, 0);
                cipher = crypto.createCipheriv(this.algorithm, key, iv);
            }
            
            // åŠ å¯†æ•°æ®
            let encrypted = cipher.update(plaintext, 'utf8', this.encoding);
            encrypted += cipher.final(this.encoding);
            
            // å¦‚æœä½¿ç”¨äº†nonceï¼Œå°†å…¶æ·»åŠ åˆ°ç»“æœå‰é¢
            if (nonce) {
                const nonceStr = nonce.toString(this.encoding);
                const result = nonceStr + '.' + encrypted;
                console.log('åŠ å¯†ç»“æœ:', result);
                return result;
            }
            
            console.log('åŠ å¯†ç»“æœ:', encrypted);
            return encrypted;
            
        } catch (error) {
            console.error('åŠ å¯†å¤±è´¥:', error);
            throw new Error(`Encryption failed: ${error.message}`);
        }
    }
    
    decrypt(ciphertext, key) {
        try {
            console.log('è§£å¯†å‚æ•°:', {
                ciphertext,
                keyLength: key.length
            });
            
            let nonce = null;
            let encrypted = ciphertext;
            
            // æ£€æŸ¥æ˜¯å¦åŒ…å«nonce
            if (ciphertext.includes('.')) {
                const parts = ciphertext.split('.');
                if (parts.length === 2) {
                    nonce = Buffer.from(parts[0], this.encoding);
                    encrypted = parts[1];
                    console.log('æå–çš„nonce:', nonce.toString('hex'));
                }
            }
            
            // åˆ›å»ºdecipherå®ä¾‹
            let decipher;
            if (nonce) {
                const iv = Buffer.alloc(16);
                nonce.copy(iv, 0, 0, Math.min(nonce.length, 16));
                console.log('ä½¿ç”¨IV:', iv.toString('hex'));
                decipher = crypto.createDecipheriv(this.algorithm, key, iv);
            } else {
                // ä¸ºå…¼å®¹æ€§ï¼Œå¦‚æœæ²¡æœ‰nonceåˆ™ä½¿ç”¨é›¶åˆå§‹å‘é‡
                const iv = Buffer.alloc(16, 0);
                decipher = crypto.createDecipheriv(this.algorithm, key, iv);
            }
            
            // è§£å¯†æ•°æ®
            let decrypted = decipher.update(encrypted, this.encoding, 'utf8');
            decrypted += decipher.final('utf8');
            
            console.log('è§£å¯†ç»“æœ:', decrypted);
            return decrypted;
            
        } catch (error) {
            console.error('è§£å¯†å¤±è´¥:', error);
            throw new Error(`Decryption failed: ${error.message}`);
        }
    }

    hash(data, algorithm = 'sha256') {
        try {
            return crypto.createHash(algorithm).update(data).digest('hex');
        } catch (error) {
            throw new Error(`Hashing failed: ${error.message}`);
        }
    }

    generateRandomBytes(length) {
        return crypto.randomBytes(length);
    }

    generateSecureToken(length = 32) {
        return crypto.randomBytes(length).toString('hex');
    }

    verifyIntegrity(data, expectedHash, algorithm = 'sha256') {
        const actualHash = this.hash(data, algorithm);
        return actualHash === expectedHash;
    }
}

module.exports = CryptoUtils;

/***/ }),
/* 235 */
/***/ ((module) => {

class Validator {
    constructor(config = {}) {
        this.config = config;
        this.customValidators = new Map();
        
        // æ³¨å†Œå†…ç½®éªŒè¯å™¨
        this._registerBuiltinValidators();
    }

    // éªŒè¯å¯¹è±¡
    validate(data, schema) {
        const errors = [];
        
        if (!schema || typeof schema !== 'object') {
            throw new Error('Schema must be an object');
        }
        
        this._validateObject(data, schema, '', errors);
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    // éªŒè¯å•ä¸ªå­—æ®µ
    validateField(value, rules, fieldName = 'field') {
        const errors = [];
        
        if (!Array.isArray(rules)) {
            rules = [rules];
        }
        
        for (const rule of rules) {
            const result = this._applyRule(value, rule, fieldName);
            if (!result.isValid) {
                errors.push(result.error);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    // æ³¨å†Œè‡ªå®šä¹‰éªŒè¯å™¨
    registerValidator(name, validatorFn) {
        if (typeof validatorFn !== 'function') {
            throw new Error('Validator must be a function');
        }
        
        this.customValidators.set(name, validatorFn);
    }

    // å†…éƒ¨æ–¹æ³•
    _validateObject(data, schema, path, errors) {
        for (const [key, rules] of Object.entries(schema)) {
            const fieldPath = path ? `${path}.${key}` : key;
            const value = data ? data[key] : undefined;
            
            if (Array.isArray(rules)) {
                // å¤šä¸ªéªŒè¯è§„åˆ™
                for (const rule of rules) {
                    const result = this._applyRule(value, rule, fieldPath);
                    if (!result.isValid) {
                        errors.push(result.error);
                    }
                }
            } else if (typeof rules === 'object' && rules.type) {
                // å•ä¸ªéªŒè¯è§„åˆ™
                const result = this._applyRule(value, rules, fieldPath);
                if (!result.isValid) {
                    errors.push(result.error);
                }
            } else if (typeof rules === 'object') {
                // åµŒå¥—å¯¹è±¡éªŒè¯
                if (value && typeof value === 'object') {
                    this._validateObject(value, rules, fieldPath, errors);
                }
            }
        }
    }

    _applyRule(value, rule, fieldPath) {
        if (typeof rule === 'string') {
            // ç®€å•ç±»å‹éªŒè¯
            return this._validateType(value, rule, fieldPath);
        }
        
        if (typeof rule === 'function') {
            // è‡ªå®šä¹‰éªŒè¯å‡½æ•°
            return this._validateCustom(value, rule, fieldPath);
        }
        
        if (typeof rule === 'object') {
            return this._validateComplexRule(value, rule, fieldPath);
        }
        
        return { isValid: true };
    }

    _validateType(value, type, fieldPath) {
        const validator = this.customValidators.get(type) || 
                         this._getBuiltinValidator(type);
        
        if (!validator) {
            return {
                isValid: false,
                error: `Unknown validator type: ${type} for field ${fieldPath}`
            };
        }
        
        return validator(value, fieldPath);
    }

    _validateCustom(value, validatorFn, fieldPath) {
        try {
            const result = validatorFn(value, fieldPath);
            
            if (typeof result === 'boolean') {
                return {
                    isValid: result,
                    error: result ? null : `Validation failed for field ${fieldPath}`
                };
            }
            
            return result;
            
        } catch (error) {
            return {
                isValid: false,
                error: `Validation error for field ${fieldPath}: ${error.message}`
            };
        }
    }

    _validateComplexRule(value, rule, fieldPath) {
        const errors = [];
        
        // å¿…å¡«éªŒè¯
        if (rule.required && (value === undefined || value === null)) {
            return {
                isValid: false,
                error: `Field ${fieldPath} is required`
            };
        }
        
        // å¦‚æœå­—æ®µä¸æ˜¯å¿…å¡«ä¸”å€¼ä¸ºç©ºï¼Œè·³è¿‡å…¶ä»–éªŒè¯
        if (!rule.required && (value === undefined || value === null)) {
            return { isValid: true };
        }
        
        // ç±»å‹éªŒè¯
        if (rule.type) {
            const typeResult = this._validateType(value, rule.type, fieldPath);
            if (!typeResult.isValid) {
                return typeResult;
            }
        }
        
        // é•¿åº¦éªŒè¯
        if (rule.minLength !== undefined || rule.maxLength !== undefined) {
            const lengthResult = this._validateLength(value, rule, fieldPath);
            if (!lengthResult.isValid) {
                errors.push(lengthResult.error);
            }
        }
        
        // èŒƒå›´éªŒè¯
        if (rule.min !== undefined || rule.max !== undefined) {
            const rangeResult = this._validateRange(value, rule, fieldPath);
            if (!rangeResult.isValid) {
                errors.push(rangeResult.error);
            }
        }
        
        // æ­£åˆ™è¡¨è¾¾å¼éªŒè¯
        if (rule.pattern) {
            const patternResult = this._validatePattern(value, rule.pattern, fieldPath);
            if (!patternResult.isValid) {
                errors.push(patternResult.error);
            }
        }
        
        // æšä¸¾å€¼éªŒè¯
        if (rule.enum) {
            const enumResult = this._validateEnum(value, rule.enum, fieldPath);
            if (!enumResult.isValid) {
                errors.push(enumResult.error);
            }
        }
        
        // è‡ªå®šä¹‰éªŒè¯å™¨
        if (rule.validator) {
            const customResult = this._validateCustom(value, rule.validator, fieldPath);
            if (!customResult.isValid) {
                errors.push(customResult.error);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    _validateLength(value, rule, fieldPath) {
        const length = value ? value.length : 0;
        
        if (rule.minLength !== undefined && length < rule.minLength) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be at least ${rule.minLength} characters long`
            };
        }
        
        if (rule.maxLength !== undefined && length > rule.maxLength) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be no more than ${rule.maxLength} characters long`
            };
        }
        
        return { isValid: true };
    }

    _validateRange(value, rule, fieldPath) {
        const numValue = Number(value);
        
        if (isNaN(numValue)) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be a number for range validation`
            };
        }
        
        if (rule.min !== undefined && numValue < rule.min) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be at least ${rule.min}`
            };
        }
        
        if (rule.max !== undefined && numValue > rule.max) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be no more than ${rule.max}`
            };
        }
        
        return { isValid: true };
    }

    _validatePattern(value, pattern, fieldPath) {
        const regex = pattern instanceof RegExp ? pattern : new RegExp(pattern);
        
        if (!regex.test(String(value))) {
            return {
                isValid: false,
                error: `Field ${fieldPath} does not match required pattern`
            };
        }
        
        return { isValid: true };
    }

    _validateEnum(value, enumValues, fieldPath) {
        if (!enumValues.includes(value)) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be one of: ${enumValues.join(', ')}`
            };
        }
        
        return { isValid: true };
    }

    _registerBuiltinValidators() {
        // åŸºæœ¬ç±»å‹éªŒè¯å™¨
        this.customValidators.set('string', (value, field) => ({
            isValid: typeof value === 'string',
            error: typeof value === 'string' ? null : `Field ${field} must be a string`
        }));
        
        this.customValidators.set('number', (value, field) => ({
            isValid: typeof value === 'number' && !isNaN(value),
            error: typeof value === 'number' && !isNaN(value) ? null : `Field ${field} must be a number`
        }));
        
        this.customValidators.set('boolean', (value, field) => ({
            isValid: typeof value === 'boolean',
            error: typeof value === 'boolean' ? null : `Field ${field} must be a boolean`
        }));
        
        this.customValidators.set('array', (value, field) => ({
            isValid: Array.isArray(value),
            error: Array.isArray(value) ? null : `Field ${field} must be an array`
        }));
        
        this.customValidators.set('object', (value, field) => ({
            isValid: value && typeof value === 'object' && !Array.isArray(value),
            error: value && typeof value === 'object' && !Array.isArray(value) ? null : `Field ${field} must be an object`
        }));
        
        // ç‰¹æ®ŠéªŒè¯å™¨
        this.customValidators.set('email', (value, field) => {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return {
                isValid: emailRegex.test(value),
                error: emailRegex.test(value) ? null : `Field ${field} must be a valid email address`
            };
        });
        
        this.customValidators.set('url', (value, field) => {
            try {
                new URL(value);
                return { isValid: true };
            } catch {
                return {
                    isValid: false,
                    error: `Field ${field} must be a valid URL`
                };
            }
        });
        
        this.customValidators.set('uuid', (value, field) => {
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
            return {
                isValid: uuidRegex.test(value),
                error: uuidRegex.test(value) ? null : `Field ${field} must be a valid UUID`
            };
        });
        
        this.customValidators.set('datestring', (value, field) => {
            const date = new Date(value);
            return {
                isValid: !isNaN(date.getTime()),
                error: !isNaN(date.getTime()) ? null : `Field ${field} must be a valid date string`
            };
        });
    }

    _getBuiltinValidator(type) {
        return this.customValidators.get(type);
    }
}

module.exports = Validator;

/***/ }),
/* 236 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * è…¾è®¯äº‘å‘é‡æ•°æ®åº“é€‚é…å™¨
 * å°†TencentVectorDBçš„æ¥å£é€‚é…ä¸ºVectorManageræœŸæœ›çš„æ ‡å‡†æ¥å£
 */

const TencentVectorDB = __webpack_require__(226);
const crypto = __webpack_require__(8);

class TencentVectorDBAdapter {
    constructor(config = {}) {
        this.config = config;
        
        // é€‚é…é…ç½®æ ¼å¼
        const tencentConfig = {
            username: config.username,
            apiKey: config.password, // å°†passwordæ˜ å°„ä¸ºapiKey
            host: this._extractHost(config.endpoint),
            port: this._extractPort(config.endpoint),
            useHttps: config.endpoint?.startsWith('https'),
            timeout: config.connectionTimeout || 30000,
            logLevel: config.logLevel || 'info'
        };
        
        this.tencentDB = new TencentVectorDB(tencentConfig);
        this.defaultDatabase = 'code_chunker_db';
        this.isInitialized = false;
    }

    _extractHost(endpoint) {
        if (!endpoint) return 'localhost';
        const url = new URL(endpoint);
        return url.hostname;
    }

    _extractPort(endpoint) {
        if (!endpoint) return 8100;
        const url = new URL(endpoint);
        return parseInt(url.port) || (endpoint.startsWith('https') ? 443 : 80);
    }

    async initialize() {
        if (this.isInitialized) {
            return;
        }

        try {
            // åˆå§‹åŒ–åº•å±‚æ•°æ®åº“è¿æ¥
            await this.tencentDB.initialize();
            
            // ç¡®ä¿é»˜è®¤æ•°æ®åº“å­˜åœ¨
            await this._ensureDatabase(this.defaultDatabase);
            
            this.isInitialized = true;
            console.log('TencentVectorDB Adapter initialized successfully');
            
        } catch (error) {
            console.error('Failed to initialize TencentVectorDB Adapter:', error);
            throw error;
        }
    }

    async _ensureDatabase(databaseName) {
        try {
            // å°è¯•åˆ—å‡ºæ•°æ®åº“ï¼Œæ£€æŸ¥æ˜¯å¦å­˜åœ¨
            const response = await this.tencentDB.listDatabases();
            const databases = response.data?.databases || [];
            
            const exists = databases.some(db => db.database === databaseName);
            
            if (!exists) {
                console.log(`Creating database: ${databaseName}`);
                await this.tencentDB.createDatabase(databaseName);
            }
            
        } catch (error) {
            console.warn(`Error ensuring database ${databaseName}:`, error.message);
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºæ•°æ®åº“å¯èƒ½å·²å­˜åœ¨
        }
    }

    async ensureCollection(collectionName) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            // æ£€æŸ¥é›†åˆæ˜¯å¦å­˜åœ¨
            const response = await this.tencentDB.listCollections(this.defaultDatabase);
            const collections = response.data?.collections || [];
            
            const existingCollection = collections.find(col => col.collection === collectionName);
            
            if (!existingCollection) {
                console.log(`Creating collection: ${collectionName}`);
                
                // åˆ›å»ºé›†åˆï¼Œä½¿ç”¨ä»£ç å‘é‡åŒ–çš„æ ‡å‡†é…ç½®
                const createParams = {
                    replicaNum: 0, // è…¾è®¯äº‘è¦æ±‚
                    shardNum: this.config.collections?.shards || 1,
                    description: `Code chunker collection: ${collectionName}`,
                    indexes: [
                        {
                            fieldName: "id",
                            fieldType: "string",
                            indexType: "primaryKey"
                        },
                        {
                            fieldName: "vector",
                            fieldType: "vector",
                            indexType: this.config.collections?.indexType || "IVF_FLAT",
                            dimension: this.config.collections?.defaultDimension || 768,
                            metricType: this.config.collections?.metric?.toUpperCase() || "COSINE",
                            params: {
                                nlist: 1024
                            }
                        }
                    ]
                };
                
                await this.tencentDB.createCollection(this.defaultDatabase, collectionName, createParams);
                
                // ç­‰å¾…ç´¢å¼•æ„å»ºå®Œæˆ
                await this._waitForIndexReady(collectionName);
            } else {
                // å³ä½¿é›†åˆå·²å­˜åœ¨ï¼Œä¹Ÿè¦æ£€æŸ¥ç´¢å¼•æ˜¯å¦å‡†å¤‡å¥½
                await this._waitForIndexReady(collectionName);
            }
            
        } catch (error) {
            console.warn(`Error ensuring collection ${collectionName}:`, error.message);
            // ä¸æŠ›å‡ºé”™è¯¯ï¼Œå› ä¸ºé›†åˆå¯èƒ½å·²å­˜åœ¨
        }
    }

    async _waitForIndexReady(collectionName, maxWaitTime = 30000) {
        const startTime = Date.now();
        const checkInterval = 2000; // 2ç§’æ£€æŸ¥ä¸€æ¬¡
        let initialStateCount = 0; // è®¡ç®—å¤„äºinitialçŠ¶æ€çš„æ¬¡æ•°
        
        console.log(`â³ ç­‰å¾…é›†åˆ ${collectionName} çš„ç´¢å¼•æ„å»ºå®Œæˆ...`);
        
        while (Date.now() - startTime < maxWaitTime) {
            try {
                // å°è¯•æè¿°é›†åˆä»¥æ£€æŸ¥çŠ¶æ€
                const response = await this.tencentDB.describeCollection(this.defaultDatabase, collectionName);
                
                if (response.success && response.data && response.data.collection) {
                    // æ£€æŸ¥ç´¢å¼•çŠ¶æ€ - ä¿®æ­£è·¯å¾„
                    const indexStatus = response.data.collection.indexStatus?.status || 'unknown';
                    console.log(`ğŸ“Š ç´¢å¼•çŠ¶æ€: ${indexStatus}`);
                    
                    // è…¾è®¯äº‘ç´¢å¼•çŠ¶æ€ï¼šinitial -> building -> ready
                    if (indexStatus === 'ready' || indexStatus === 'normal') {
                        console.log(`âœ… é›†åˆ ${collectionName} ç´¢å¼•å·²å‡†å¤‡å°±ç»ª`);
                        return true;
                    } else if (indexStatus === 'initial') {
                        initialStateCount++;
                        console.log(`ğŸ”„ ç´¢å¼•çŠ¶æ€ä¸ºåˆå§‹çŠ¶æ€ (${initialStateCount}/${Math.floor(maxWaitTime/checkInterval)})`);
                        
                        // å¦‚æœé•¿æ—¶é—´å¤„äºinitialçŠ¶æ€ï¼Œå¯èƒ½éœ€è¦æ•°æ®æ‰èƒ½è§¦å‘ç´¢å¼•æ„å»º
                        if (initialStateCount >= 5) { // ç­‰å¾…10ç§’å
                            console.log(`ğŸ’¡ ç´¢å¼•é•¿æ—¶é—´å¤„äºåˆå§‹çŠ¶æ€ï¼Œå¯èƒ½éœ€è¦æ’å…¥æ•°æ®åæ‰ä¼šå¼€å§‹æ„å»º`);
                            console.log(`âœ… ç»§ç»­æ‰§è¡Œï¼Œå°†åœ¨æ•°æ®æ’å…¥æ—¶è§¦å‘ç´¢å¼•æ„å»º`);
                            return true; // å…è®¸ç»§ç»­æ‰§è¡Œ
                        }
                    } else if (indexStatus === 'building') {
                        console.log(`ğŸ—ï¸ ç´¢å¼•æ­£åœ¨æ„å»ºä¸­...`);
                        initialStateCount = 0; // é‡ç½®è®¡æ•°å™¨
                    }
                }
                
                // ç­‰å¾…åå†æ¬¡æ£€æŸ¥
                await new Promise(resolve => setTimeout(resolve, checkInterval));
                
            } catch (error) {
                console.warn(`æ£€æŸ¥ç´¢å¼•çŠ¶æ€æ—¶å‡ºé”™: ${error.message}`);
                // ç»§ç»­ç­‰å¾…
                await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
        }
        
        console.warn(`âš ï¸ ç­‰å¾…ç´¢å¼•æ„å»ºè¶…æ—¶ (${maxWaitTime}ms)ï¼Œç»§ç»­æ‰§è¡Œ`);
        return false;
    }

    async batchUpsert(collectionName, vectors) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            // ç¡®ä¿é›†åˆå­˜åœ¨ä¸”ç´¢å¼•å‡†å¤‡å®Œæˆ
            await this.ensureCollection(collectionName);
            
            // è½¬æ¢å‘é‡æ ¼å¼ä¸ºè…¾è®¯äº‘æœŸæœ›çš„æ ¼å¼ï¼ŒåŒ…å«å®Œæ•´çš„å…ƒæ•°æ®
            const documents = vectors.map(vector => ({
                id: vector.id,
                vector: vector.vector,
                
                // åŸºç¡€æ–‡ä»¶ä¿¡æ¯
                filePath: vector.filePath || '',
                fileName: vector.fileName || '',
                offset: typeof vector.offset === 'number' ? vector.offset : 0,
                timestamp: typeof vector.timestamp === 'number' ? vector.timestamp : Date.now(),
                
                // ç”¨æˆ·ä¿¡æ¯ - å…³é”®çš„æ˜ å°„ä¿®å¤
                userId: vector.userId || 'unknown',
                deviceId: vector.deviceId || 'unknown', 
                workspacePath: vector.workspacePath || 'unknown',
                
                // ä»£ç å—å…ƒæ•°æ® - ä»nested metadataä¸­æå–
                language: vector.language || vector.metadata?.language || 'unknown',
                startLine: vector.startLine || vector.metadata?.startLine || 0,
                endLine: vector.endLine || vector.metadata?.endLine || 0,
                content: vector.content || vector.metadata?.content || '',
                parser: vector.parser || vector.metadata?.parser || 'unknown',
                type: vector.type || vector.metadata?.type || 'code',
                
                // å‘é‡å¤„ç†ä¿¡æ¯
                vectorModel: vector.vectorModel || vector.metadata?.vectorModel || 'CoCoSoDa-v1.0',
                processingTimeMs: vector.processingTimeMs || vector.metadata?.processingTimeMs || 0,
                createdAt: vector.createdAt || vector.metadata?.createdAt || new Date().toISOString()
            }));
            
            // æ™ºèƒ½é‡è¯•æœºåˆ¶
            const maxRetries = 3;
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    // æ‰¹é‡ä¸Šä¼ åˆ°è…¾è®¯äº‘
                    const response = await this.tencentDB.upsertDocuments(
                        this.defaultDatabase,
                        collectionName,
                        documents
                    );
                    
                    if (response.success) {
                        if (attempt > 1) {
                            console.log(`âœ… ç¬¬${attempt}æ¬¡é‡è¯•æˆåŠŸï¼Œä¸Šä¼ äº†${vectors.length}ä¸ªå‘é‡`);
                        }
                        return {
                            success: true,
                            count: vectors.length,
                            collectionName: collectionName
                        };
                    } else {
                        lastError = new Error(response.error || 'Batch upsert failed');
                    }
                    
                } catch (error) {
                    lastError = error;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯ç´¢å¼•æœªå‡†å¤‡å¥½çš„é”™è¯¯
                    if (error.message.includes('current index is not ready')) {
                        console.log(`â³ ç¬¬${attempt}æ¬¡å°è¯•ï¼šç´¢å¼•æœªå‡†å¤‡å¥½ï¼Œç­‰å¾…${attempt * 2}ç§’åé‡è¯•...`);
                        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                        continue;
                    } else {
                        // å…¶ä»–ç±»å‹çš„é”™è¯¯ï¼Œç›´æ¥å¤±è´¥
                        break;
                    }
                }
            }
            
            // æ‰€æœ‰é‡è¯•éƒ½å¤±è´¥äº†
            console.warn(`âš ï¸ å‘é‡ä¸Šä¼ å¤±è´¥ï¼Œå·²é‡è¯•${maxRetries}æ¬¡: ${lastError.message}`);
            return {
                success: false,
                error: lastError.message,
                count: 0
            };
            
        } catch (error) {
            console.error(`Batch upsert failed for collection ${collectionName}:`, error);
            return {
                success: false,
                error: error.message,
                count: 0
            };
        }
    }

    async search(queryVector, topK = 10, collectionName, options = {}) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            // æ„å»ºæœç´¢å‚æ•° - åŒ…å«æ‰€æœ‰é‡è¦å­—æ®µ
            const searchParams = {
                limit: topK,
                outputFields: [
                    'id', 'filePath', 'fileName', 'offset', 'timestamp',
                    'userId', 'deviceId', 'workspacePath',
                    'language', 'startLine', 'endLine', 'content', 'parser', 'type',
                    'vectorModel', 'processingTimeMs', 'createdAt'
                ],
                searchParams: {
                    ef: 64  // HNSWæœç´¢å‚æ•°
                }
            };
            
            // æ·»åŠ è¿‡æ»¤æ¡ä»¶
            if (options.filter) {
                searchParams.filter = options.filter;
            }
            
            // æ‰§è¡Œå‘é‡æœç´¢
            const response = await this.tencentDB.searchVectors(
                this.defaultDatabase,
                collectionName,
                queryVector, // ç›´æ¥ä¼ é€’å‘é‡ï¼Œä¸ä½¿ç”¨æ•°ç»„
                searchParams
            );
            
            if (response.success && response.data?.results) {
                // è½¬æ¢ç»“æœæ ¼å¼ï¼Œä¿æŒä¸VectorManageræœŸæœ›çš„æ ¼å¼ä¸€è‡´
                return response.data.results.map(result => ({
                    chunkId: result.id,
                    id: result.id,
                    score: result.score,
                    similarity: result.score, // å‘åå…¼å®¹
                    filePath: result.filePath || '',
                    fileName: result.fileName || '',
                    startLine: result.startLine || 0,
                    endLine: result.endLine || 0,
                    content: result.content || '',
                    
                    metadata: {
                        userId: result.userId || 'unknown',
                        deviceId: result.deviceId || 'unknown',  
                        workspacePath: result.workspacePath || 'unknown',
                        language: result.language || 'unknown',
                        parser: result.parser || 'unknown',
                        type: result.type || 'code',
                        vectorModel: result.vectorModel || 'CoCoSoDa-v1.0',
                        processingTimeMs: result.processingTimeMs || 0,
                        createdAt: result.createdAt || '',
                        timestamp: result.timestamp || Date.now(),
                        offset: result.offset || 0,
                        originalScore: result.score // åŸå§‹åˆ†æ•°
                    }
                }));
            } else {
                console.warn('Search returned no results or failed:', response);
                return [];
            }
            
        } catch (error) {
            console.error(`Search failed for collection ${collectionName}:`, error);
            return [];
        }
    }

    async deleteCollection(collectionName) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            const response = await this.tencentDB.dropCollection(this.defaultDatabase, collectionName);
            return response.success;
        } catch (error) {
            console.error(`Delete collection failed:`, error);
            return false;
        }
    }

    async getCollectionStats(collectionName) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            const response = await this.tencentDB.describeCollection(this.defaultDatabase, collectionName);
            
            if (response.success && response.data) {
                return {
                    name: collectionName,
                    vectorCount: response.data.documentCount || 0,
                    dimension: this.config.collections?.defaultDimension || 768,
                    metric: this.config.collections?.metric || 'cosine'
                };
            } else {
                return null;
            }
        } catch (error) {
            console.error(`Get collection stats failed:`, error);
            return null;
        }
    }

    async shutdown() {
        try {
            if (this.tencentDB && typeof this.tencentDB.close === 'function') {
                await this.tencentDB.close();
            }
            this.isInitialized = false;
            console.log('TencentVectorDB Adapter shutdown completed');
        } catch (error) {
            console.error('Error during shutdown:', error);
        }
    }
}

module.exports = TencentVectorDBAdapter; 

/***/ }),
/* 237 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

class MerkleTree {
    constructor() {
        this.leaves = [];
        this.tree = [];
    }

    /**
     * è®¡ç®—å•ä¸ªæ–‡ä»¶çš„å“ˆå¸Œå€¼
     * @param {string} content - æ–‡ä»¶å†…å®¹
     * @returns {string} - æ–‡ä»¶çš„å“ˆå¸Œå€¼
     */
    hashFile(content) {
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    /**
     * è®¡ç®—ä¸¤ä¸ªå“ˆå¸Œå€¼çš„ç»„åˆå“ˆå¸Œ
     * @param {string} hash1 - ç¬¬ä¸€ä¸ªå“ˆå¸Œå€¼
     * @param {string} hash2 - ç¬¬äºŒä¸ªå“ˆå¸Œå€¼
     * @returns {string} - ç»„åˆåçš„å“ˆå¸Œå€¼
     */
    combineHashes(hash1, hash2) {
        return crypto.createHash('sha256')
            .update(hash1 + hash2)
            .digest('hex');
    }

    /**
     * æ„å»º Merkle æ ‘
     * @param {Array<string>} fileHashes - æ–‡ä»¶å“ˆå¸Œå€¼æ•°ç»„ï¼ˆå·²é¢„è®¡ç®—ï¼‰
     * @returns {Object} - åŒ…å«æ ¹å“ˆå¸Œå’Œå®Œæ•´æ ‘çš„å¯¹è±¡
     */
    buildTree(fileHashes) {
        // æ¸…ç©ºç°æœ‰æ•°æ®
        this.leaves = [];
        this.tree = [];

        // ç›´æ¥ä½¿ç”¨å·²è®¡ç®—çš„å“ˆå¸Œå€¼ä½œä¸ºå¶èŠ‚ç‚¹
        this.leaves = [...fileHashes];
        this.tree.push([...this.leaves]);

        // æ„å»ºæ ‘
        let currentLevel = this.leaves;
        while (currentLevel.length > 1) {
            const nextLevel = [];
            for (let i = 0; i < currentLevel.length; i += 2) {
                if (i + 1 === currentLevel.length) {
                    // å¦‚æœæ˜¯å¥‡æ•°ä¸ªèŠ‚ç‚¹ï¼Œå¤åˆ¶æœ€åä¸€ä¸ªèŠ‚ç‚¹
                    nextLevel.push(this.combineHashes(currentLevel[i], currentLevel[i]));
                } else {
                    nextLevel.push(this.combineHashes(currentLevel[i], currentLevel[i + 1]));
                }
            }
            this.tree.push(nextLevel);
            currentLevel = nextLevel;
        }

        return {
            rootHash: this.tree[this.tree.length - 1][0],
            tree: this.tree
        };
    }

    /**
     * æ„å»º Merkle æ ‘ï¼ˆå…¼å®¹æ—§ç‰ˆæœ¬ï¼Œæ¥æ”¶æ–‡ä»¶å†…å®¹ï¼‰
     * @param {Array<string>} fileContents - æ–‡ä»¶å†…å®¹æ•°ç»„
     * @returns {Object} - åŒ…å«æ ¹å“ˆå¸Œå’Œå®Œæ•´æ ‘çš„å¯¹è±¡
     * @deprecated è¯·ä½¿ç”¨ buildTree(fileHashes) ä»¥é¿å…é‡å¤å“ˆå¸Œè®¡ç®—
     */
    buildTreeFromContents(fileContents) {
        // è®¡ç®—æ–‡ä»¶å†…å®¹çš„å“ˆå¸Œå€¼
        const fileHashes = fileContents.map(content => this.hashFile(content));
        return this.buildTree(fileHashes);
    }

    /**
     * è·å–æ–‡ä»¶çš„è¯æ˜è·¯å¾„
     * @param {number} index - æ–‡ä»¶åœ¨åŸå§‹æ•°ç»„ä¸­çš„ç´¢å¼•
     * @returns {Array<{hash: string, isLeft: boolean}>} - è¯æ˜è·¯å¾„
     */
    getProof(index) {
        const proof = [];
        let currentIndex = index;

        for (let level = 0; level < this.tree.length - 1; level++) {
            const isLeft = currentIndex % 2 === 0;
            const siblingIndex = isLeft ? currentIndex + 1 : currentIndex - 1;
            
            if (siblingIndex < this.tree[level].length) {
                proof.push({
                    hash: this.tree[level][siblingIndex],
                    isLeft: !isLeft
                });
            }

            currentIndex = Math.floor(currentIndex / 2);
        }

        return proof;
    }

    /**
     * éªŒè¯æ–‡ä»¶æ˜¯å¦åœ¨æ ‘ä¸­
     * @param {string} content - æ–‡ä»¶å†…å®¹
     * @param {Array<{hash: string, isLeft: boolean}>} proof - è¯æ˜è·¯å¾„
     * @param {string} rootHash - æ ¹å“ˆå¸Œå€¼
     * @returns {boolean} - éªŒè¯ç»“æœ
     */
    verifyProof(content, proof, rootHash) {
        let hash = this.hashFile(content);

        for (const { hash: siblingHash, isLeft } of proof) {
            hash = isLeft ? 
                this.combineHashes(siblingHash, hash) : 
                this.combineHashes(hash, siblingHash);
        }

        return hash === rootHash;
    }
}

module.exports = MerkleTree; 

/***/ }),
/* 238 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const os = __webpack_require__(146);

/**
 * ä»£ç åˆ†å—æ€§èƒ½åˆ†æå™¨
 * ç›‘æ§æ•´ä¸ªå¤„ç†æµç¨‹ä¸­å„ä¸ªç¯èŠ‚çš„è€—æ—¶ï¼Œç”Ÿæˆè¯¦ç»†çš„æ€§èƒ½æŠ¥å‘Š
 */
class PerformanceAnalyzer {
    constructor() {
        this.metrics = {
            // æ€»ä½“æ—¶é—´
            totalTime: { start: 0, end: 0, duration: 0 },
            
            // æ–‡ä»¶æ‰«æé˜¶æ®µ
            fileScanning: { start: 0, end: 0, duration: 0, fileCount: 0, skippedCount: 0 },
            
            // æ–‡ä»¶è§£æé˜¶æ®µ
            fileParsing: { 
                start: 0, end: 0, duration: 0, 
                totalFiles: 0, 
                successFiles: 0, 
                failedFiles: 0,
                workerCreationFailures: 0,
                syncProcessingCount: 0,
                workerProcessingCount: 0
            },
            
            // åˆ†å—ç”Ÿæˆé˜¶æ®µ
            chunkGeneration: { 
                start: 0, end: 0, duration: 0, 
                totalChunks: 0,
                averageChunkSize: 0,
                largestChunk: 0
            },
            
            // Embeddingç”Ÿæˆé˜¶æ®µ
            embeddingGeneration: { 
                start: 0, end: 0, duration: 0, 
                totalRequests: 0,
                successRequests: 0,
                failedRequests: 0,
                averageRequestTime: 0,
                batchSizes: [],
                networkCommunicationTime: 0,
                serverProcessingTime: 0
            },
            
            // ç½‘ç»œè¯·æ±‚é˜¶æ®µ - æ‰©å±•æ›´è¯¦ç»†çš„ç½‘ç»œç›‘æ§
            networkRequests: {
                embedding: { 
                    count: 0, 
                    totalTime: 0, 
                    failures: 0, 
                    averageTime: 0,
                    minTime: Infinity,
                    maxTime: 0,
                    networkTime: 0,
                    serverTime: 0
                },
                vectorDB: { 
                    count: 0, 
                    totalTime: 0, 
                    failures: 0, 
                    averageTime: 0,
                    minTime: Infinity,
                    maxTime: 0,
                    insertOperations: 0,
                    queryOperations: 0
                }
            },
            
            // å‘é‡æ•°æ®åº“æ“ä½œ - ç»†åŒ–å„ç§æ“ä½œ
            vectorDatabase: { 
                start: 0, end: 0, duration: 0,
                collectionOps: { 
                    create: { count: 0, totalTime: 0 }, 
                    delete: { count: 0, totalTime: 0 }, 
                    insert: { count: 0, totalTime: 0 }, 
                    query: { count: 0, totalTime: 0 } 
                },
                insertedVectors: 0,
                batchInsertCount: 0,
                averageBatchSize: 0
            },
            
            // æ¨¡å—è¯¦ç»†è€—æ—¶è¿½è¸ª
            moduleTimings: {
                fileScanner: { initTime: 0, scanTime: 0, filterTime: 0 },
                parserSelector: { initTime: 0, parseTime: 0, chunkTime: 0 },
                dispatcher: { initTime: 0, dispatchTime: 0, workerTime: 0 },
                sender: { initTime: 0, prepareTime: 0, sendTime: 0, batchTime: 0 },
                vectorManager: { initTime: 0, cacheTime: 0, dbTime: 0, embeddingTime: 0 },
                merkleTree: { buildTime: 0, proofTime: 0 }
            },
            
            // ç³»ç»Ÿèµ„æºä½¿ç”¨
            systemResources: {
                initialMemory: 0,
                peakMemory: 0,
                finalMemory: 0,
                cpuUsage: [],
                processId: process.pid,
                memoryTimeline: []
            }
        };
        
        this.timers = new Map();
        this.isAnalyzing = false;
        this.reportPath = null;
        this.workspaceInfo = {};
        this.reportFolder = null; // å›ºå®šæŠ¥å‘Šæ–‡ä»¶å¤¹
    }

    /**
     * å¼€å§‹æ€§èƒ½åˆ†æ
     */
    startAnalysis(workspacePath, userId, deviceId) {
        this.isAnalyzing = true;
        this.workspaceInfo = {
            path: workspacePath,
            name: path.basename(workspacePath),
            userId,
            deviceId,
            timestamp: new Date().toISOString()
        };
        
        // åˆ›å»ºå›ºå®šçš„æŠ¥å‘Šæ–‡ä»¶å¤¹
        this.reportFolder = path.join(workspacePath, 'performance-reports');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' + 
                         new Date().toTimeString().split(' ')[0].replace(/:/g, '-');
        
        this.reportPath = path.join(this.reportFolder, `æ€§èƒ½æµ‹é€ŸæŠ¥å‘Š_${timestamp}.json`);
        
        this.metrics.totalTime.start = Date.now();
        this.metrics.systemResources.initialMemory = this._getMemoryUsage();
        this.metrics.systemResources.memoryTimeline.push({
            timestamp: Date.now(),
            memory: this._getMemoryUsage(),
            phase: 'start'
        });
        
        console.log(`ğŸ“Š [æ€§èƒ½åˆ†æ] å¼€å§‹ç›‘æ§é¡¹ç›®æ€§èƒ½ - æŠ¥å‘Šå°†ä¿å­˜åˆ°: ${this.reportFolder}`);
    }

    /**
     * ç»“æŸæ€§èƒ½åˆ†æå¹¶ç”ŸæˆæŠ¥å‘Š
     */
    async endAnalysis() {
        if (!this.isAnalyzing) return;
        
        this.metrics.totalTime.end = Date.now();
        this.metrics.totalTime.duration = this.metrics.totalTime.end - this.metrics.totalTime.start;
        this.metrics.systemResources.finalMemory = this._getMemoryUsage();
        
        const report = await this._generateReport();
        await this._saveReport(report);
        

        
        this.isAnalyzing = false;
        return report;
    }

    /**
     * è®°å½•æ–‡ä»¶æ‰«æå¼€å§‹
     */
    startFileScanning() {
        this.metrics.fileScanning.start = Date.now();

    }

    /**
     * è®°å½•æ–‡ä»¶æ‰«æç»“æŸ
     */
    endFileScanning(fileCount, skippedCount) {
        this.metrics.fileScanning.end = Date.now();
        this.metrics.fileScanning.duration = this.metrics.fileScanning.end - this.metrics.fileScanning.start;
        this.metrics.fileScanning.fileCount = fileCount;
        this.metrics.fileScanning.skippedCount = skippedCount;
        

    }

    /**
     * è®°å½•æ–‡ä»¶è§£æå¼€å§‹
     */
    startFileParsing(totalFiles) {
        this.metrics.fileParsing.start = Date.now();
        this.metrics.fileParsing.totalFiles = totalFiles;

    }

    /**
     * è®°å½•æ–‡ä»¶è§£æç»“æŸ
     */
    endFileParsing(successFiles, failedFiles, workerFailures, syncCount, workerCount) {
        this.metrics.fileParsing.end = Date.now();
        this.metrics.fileParsing.duration = this.metrics.fileParsing.end - this.metrics.fileParsing.start;
        this.metrics.fileParsing.successFiles = successFiles;
        this.metrics.fileParsing.failedFiles = failedFiles;
        this.metrics.fileParsing.workerCreationFailures = workerFailures;
        this.metrics.fileParsing.syncProcessingCount = syncCount;
        this.metrics.fileParsing.workerProcessingCount = workerCount;
        

    }

    /**
     * è®°å½•åˆ†å—ç”Ÿæˆä¿¡æ¯
     */
    recordChunkGeneration(totalChunks, chunkSizes) {
        this.metrics.chunkGeneration.totalChunks = totalChunks;
        if (chunkSizes && chunkSizes.length > 0) {
            this.metrics.chunkGeneration.averageChunkSize = Math.round(chunkSizes.reduce((a, b) => a + b, 0) / chunkSizes.length);
            this.metrics.chunkGeneration.largestChunk = Math.max(...chunkSizes);
        }
        

    }

    /**
     * è®°å½•Embeddingç”Ÿæˆå¼€å§‹
     */
    startEmbeddingGeneration() {
        this.metrics.embeddingGeneration.start = Date.now();

    }

    /**
     * è®°å½•Embeddingç”Ÿæˆç»“æŸ
     */
    endEmbeddingGeneration(totalRequests, successRequests, failedRequests) {
        this.metrics.embeddingGeneration.end = Date.now();
        this.metrics.embeddingGeneration.duration = this.metrics.embeddingGeneration.end - this.metrics.embeddingGeneration.start;
        this.metrics.embeddingGeneration.totalRequests = totalRequests;
        this.metrics.embeddingGeneration.successRequests = successRequests;
        this.metrics.embeddingGeneration.failedRequests = failedRequests;
        
        if (totalRequests > 0) {
            this.metrics.embeddingGeneration.averageRequestTime = Math.round(this.metrics.embeddingGeneration.duration / totalRequests);
        }
        

    }

    /**
     * è®°å½•ç½‘ç»œè¯·æ±‚
     */
    recordNetworkRequest(type, duration, success = true) {
        if (!this.metrics.networkRequests[type]) {
            this.metrics.networkRequests[type] = { count: 0, totalTime: 0, failures: 0, averageTime: 0 };
        }
        
        this.metrics.networkRequests[type].count++;
        this.metrics.networkRequests[type].totalTime += duration;
        if (!success) {
            this.metrics.networkRequests[type].failures++;
        }
        this.metrics.networkRequests[type].averageTime = Math.round(this.metrics.networkRequests[type].totalTime / this.metrics.networkRequests[type].count);
    }

    /**
     * è®°å½•å‘é‡æ•°æ®åº“æ“ä½œå¼€å§‹
     */
    startVectorDBOperations() {
        this.metrics.vectorDatabase.start = Date.now();

    }

    /**
     * è®°å½•å‘é‡æ•°æ®åº“æ“ä½œç»“æŸ
     */
    endVectorDBOperations(insertedVectors, batchCount) {
        this.metrics.vectorDatabase.end = Date.now();
        this.metrics.vectorDatabase.duration = this.metrics.vectorDatabase.end - this.metrics.vectorDatabase.start;
        this.metrics.vectorDatabase.insertedVectors = insertedVectors;
        this.metrics.vectorDatabase.batchInsertCount = batchCount;
        

    }

    /**
     * è®°å½•æ•°æ®åº“æ“ä½œ
     */
    recordDBOperation(operation, duration = 0) {
        if (this.metrics.vectorDatabase.collectionOps[operation]) {
            this.metrics.vectorDatabase.collectionOps[operation].count++;
            this.metrics.vectorDatabase.collectionOps[operation].totalTime += duration;
        }
    }

    /**
     * è®°å½•æ¨¡å—è®¡æ—¶å¼€å§‹
     */
    startModuleTimer(moduleName, operation) {
        const key = `${moduleName}_${operation}`;
        this.timers.set(key, Date.now());
    }

    /**
     * è®°å½•æ¨¡å—è®¡æ—¶ç»“æŸ
     */
    endModuleTimer(moduleName, operation) {
        const key = `${moduleName}_${operation}`;
        const startTime = this.timers.get(key);
        if (startTime) {
            const duration = Date.now() - startTime;
            this.timers.delete(key);
            
            // è®°å½•åˆ°æ¨¡å—è®¡æ—¶ä¸­
            if (this.metrics.moduleTimings[moduleName] && this.metrics.moduleTimings[moduleName][operation] !== undefined) {
                this.metrics.moduleTimings[moduleName][operation] += duration;
            }
            
            return duration;
        }
        return 0;
    }

    /**
     * è®°å½•ç½‘ç»œè¯·æ±‚è¯¦ç»†ä¿¡æ¯ï¼ˆåŒ…å«ç½‘ç»œé€šä¿¡æ—¶é—´åˆ†æï¼‰
     */
    recordDetailedNetworkRequest(type, totalTime, networkTime, serverTime, success = true) {
        if (!this.metrics.networkRequests[type]) return;
        
        const metric = this.metrics.networkRequests[type];
        metric.count++;
        metric.totalTime += totalTime;
        
        if (totalTime < metric.minTime) metric.minTime = totalTime;
        if (totalTime > metric.maxTime) metric.maxTime = totalTime;
        
        if (networkTime !== undefined) metric.networkTime += networkTime;
        if (serverTime !== undefined) metric.serverTime += serverTime;
        
        if (!success) metric.failures++;
        
        metric.averageTime = Math.round(metric.totalTime / metric.count);
        
        // æ›´æ–°embeddingç”Ÿæˆçš„ç½‘ç»œåˆ†ææ•°æ®
        if (type === 'embedding') {
            this.metrics.embeddingGeneration.networkCommunicationTime += networkTime || 0;
            this.metrics.embeddingGeneration.serverProcessingTime += serverTime || 0;
        }
    }

    /**
     * è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
     */
    recordMemoryUsage(phase) {
        const currentMemory = this._getMemoryUsage();
        this.metrics.systemResources.memoryTimeline.push({
            timestamp: Date.now(),
            memory: currentMemory,
            phase: phase
        });
        
        if (currentMemory > this.metrics.systemResources.peakMemory) {
            this.metrics.systemResources.peakMemory = currentMemory;
        }
    }

    /**
     * æ›´æ–°å†…å­˜å³°å€¼
     */
    updatePeakMemory() {
        const currentMemory = this._getMemoryUsage();
        if (currentMemory > this.metrics.systemResources.peakMemory) {
            this.metrics.systemResources.peakMemory = currentMemory;
        }
    }

    /**
     * è·å–å†…å­˜ä½¿ç”¨æƒ…å†µ
     */
    _getMemoryUsage() {
        const usage = process.memoryUsage();
        return Math.round(usage.heapUsed / 1024 / 1024); // MB
    }

    /**
     * ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
     */
    async _generateReport() {
        const report = {
            metadata: {
                generatedAt: new Date().toISOString(),
                workspace: this.workspaceInfo,
                system: {
                    platform: os.platform(),
                    arch: os.arch(),
                    nodeVersion: process.version,
                    totalMemory: Math.round(os.totalmem() / 1024 / 1024), // MB
                    cpuCount: os.cpus().length
                }
            },
            
            summary: {
                totalDuration: this.metrics.totalTime.duration,
                totalFiles: this.metrics.fileScanning.fileCount,
                skippedFiles: this.metrics.fileScanning.skippedCount,
                processedFiles: this.metrics.fileParsing.successFiles,
                totalChunks: this.metrics.chunkGeneration.totalChunks,
                totalEmbeddingRequests: this.metrics.embeddingGeneration.totalRequests,
                insertedVectors: this.metrics.vectorDatabase.insertedVectors
            },
            
            performance: {
                breakdown: this._calculatePerformanceBreakdown(),
                bottlenecks: this._identifyBottlenecks(),
                recommendations: this._generateRecommendations()
            },
            
            detailed: this.metrics
        };

        return report;
    }

    /**
     * è®¡ç®—æ€§èƒ½åˆ†è§£
     */
    _calculatePerformanceBreakdown() {
        const total = this.metrics.totalTime.duration;
        if (total === 0) return {};

        return {
            fileScanning: {
                duration: this.metrics.fileScanning.duration,
                percentage: Math.round((this.metrics.fileScanning.duration / total) * 100)
            },
            fileParsing: {
                duration: this.metrics.fileParsing.duration,
                percentage: Math.round((this.metrics.fileParsing.duration / total) * 100)
            },
            embeddingGeneration: {
                duration: this.metrics.embeddingGeneration.duration,
                percentage: Math.round((this.metrics.embeddingGeneration.duration / total) * 100)
            },
            vectorDatabase: {
                duration: this.metrics.vectorDatabase.duration,
                percentage: Math.round((this.metrics.vectorDatabase.duration / total) * 100)
            }
        };
    }

    /**
     * è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
     */
    _identifyBottlenecks() {
        const breakdown = this._calculatePerformanceBreakdown();
        const bottlenecks = [];

        // è¯†åˆ«è€—æ—¶æœ€å¤šçš„ç¯èŠ‚
        const phases = Object.entries(breakdown).sort((a, b) => b[1].percentage - a[1].percentage);
        
        if (phases.length > 0) {
            const topPhase = phases[0];
            if (topPhase[1].percentage > 40) {
                bottlenecks.push({
                    phase: topPhase[0],
                    impact: 'high',
                    percentage: topPhase[1].percentage,
                    description: this._getBottleneckDescription(topPhase[0])
                });
            }
        }

        // æ£€æŸ¥Workerå¤±è´¥ç‡
        if (this.metrics.fileParsing.workerCreationFailures > 5) {
            bottlenecks.push({
                phase: 'workerCreation',
                impact: 'medium',
                count: this.metrics.fileParsing.workerCreationFailures,
                description: 'Workeråˆ›å»ºå¤±è´¥è¿‡å¤šï¼Œå½±å“å¹¶å‘å¤„ç†æ•ˆç‡'
            });
        }

        // æ£€æŸ¥ç½‘ç»œè¯·æ±‚å¤±è´¥ç‡
        const embeddingFailureRate = this.metrics.embeddingGeneration.failedRequests / Math.max(this.metrics.embeddingGeneration.totalRequests, 1);
        if (embeddingFailureRate > 0.1) {
            bottlenecks.push({
                phase: 'networkRequests',
                impact: 'high',
                failureRate: Math.round(embeddingFailureRate * 100),
                description: 'EmbeddingæœåŠ¡è¯·æ±‚å¤±è´¥ç‡è¿‡é«˜'
            });
        }

        return bottlenecks;
    }

    /**
     * è·å–ç“¶é¢ˆæè¿°
     */
    _getBottleneckDescription(phase) {
        const descriptions = {
            fileScanning: 'æ–‡ä»¶æ‰«æè€—æ—¶è¿‡é•¿ï¼Œå¯èƒ½æ˜¯ç”±äºæ–‡ä»¶æ•°é‡è¿‡å¤šæˆ–ç£ç›˜IOæ€§èƒ½é—®é¢˜',
            fileParsing: 'æ–‡ä»¶è§£æè€—æ—¶è¿‡é•¿ï¼Œå¯èƒ½æ˜¯Workeråˆ›å»ºå¤±è´¥å¯¼è‡´åŒæ­¥å¤„ç†è¿‡å¤š',
            embeddingGeneration: 'Embeddingç”Ÿæˆè€—æ—¶è¿‡é•¿ï¼Œå¯èƒ½æ˜¯ç½‘ç»œå»¶è¿Ÿæˆ–æœåŠ¡å™¨å“åº”æ…¢',
            vectorDatabase: 'å‘é‡æ•°æ®åº“æ“ä½œè€—æ—¶è¿‡é•¿ï¼Œå¯èƒ½æ˜¯ç½‘ç»œè¿æ¥æˆ–æ•°æ®åº“æ€§èƒ½é—®é¢˜'
        };
        return descriptions[phase] || 'æœªçŸ¥æ€§èƒ½é—®é¢˜';
    }

    /**
     * ç”Ÿæˆä¼˜åŒ–å»ºè®®
     */
    _generateRecommendations() {
        const recommendations = [];
        const breakdown = this._calculatePerformanceBreakdown();

        // åŸºäºç“¶é¢ˆç»™å‡ºå»ºè®®
        if (breakdown.fileScanning.percentage > 30) {
            recommendations.push({
                category: 'fileScanning',
                priority: 'medium',
                suggestion: 'è€ƒè™‘å¢åŠ æ›´å¤šæ–‡ä»¶ç±»å‹åˆ°å¿½ç•¥åˆ—è¡¨ï¼Œæˆ–å¯ç”¨æ›´æ¿€è¿›çš„æ™ºèƒ½ç­›é€‰',
                impact: 'å¯å‡å°‘æ–‡ä»¶æ‰«ææ—¶é—´20-40%'
            });
        }

        if (breakdown.embeddingGeneration.percentage > 50) {
            recommendations.push({
                category: 'embedding',
                priority: 'high',
                suggestion: 'è€ƒè™‘å¢åŠ æ‰¹å¤„ç†å¤§å°ã€ä½¿ç”¨æœ¬åœ°embeddingæœåŠ¡æˆ–åˆ‡æ¢åˆ°æ›´å¿«çš„embeddingæ¨¡å‹',
                impact: 'å¯å‡å°‘embeddingç”Ÿæˆæ—¶é—´30-60%'
            });
        }

        if (this.metrics.fileParsing.workerCreationFailures > this.metrics.fileParsing.totalFiles * 0.3) {
            recommendations.push({
                category: 'workerOptimization',
                priority: 'high',
                suggestion: 'å‡å°‘æœ€å¤§Workeræ•°é‡ï¼Œä¼˜åŒ–Workeråˆ›å»ºç­–ç•¥ï¼Œæˆ–å®Œå…¨ä½¿ç”¨åŒæ­¥å¤„ç†',
                impact: 'å¯æé«˜å¤„ç†ç¨³å®šæ€§å’Œé€Ÿåº¦'
            });
        }

        if (breakdown.vectorDatabase.percentage > 25) {
            recommendations.push({
                category: 'vectorDB',
                priority: 'medium',
                suggestion: 'è€ƒè™‘å¢åŠ æ‰¹é‡æ’å…¥å¤§å°ã€ä¼˜åŒ–ç½‘ç»œè¿æ¥æˆ–ä½¿ç”¨æœ¬åœ°å‘é‡æ•°æ®åº“',
                impact: 'å¯å‡å°‘æ•°æ®åº“æ“ä½œæ—¶é—´20-50%'
            });
        }

        return recommendations;
    }

    /**
     * ä¿å­˜æŠ¥å‘Šåˆ°æ–‡ä»¶
     */
    async _saveReport(report) {
        try {
            await fs.ensureDir(path.dirname(this.reportPath));
            await fs.writeJson(this.reportPath, report, { spaces: 2 });
            
            // åŒæ—¶ç”Ÿæˆä¸€ä¸ªç®€åŒ–çš„markdownæŠ¥å‘Š
            const markdownPath = this.reportPath.replace('.json', '.md');
            await this._generateMarkdownReport(report, markdownPath);
            
        } catch (error) {
            console.error('âŒ [PerformanceAnalyzer] ä¿å­˜æŠ¥å‘Šå¤±è´¥:', error);
        }
    }

    /**
     * ç”ŸæˆMarkdownæ ¼å¼çš„æŠ¥å‘Š
     */
    async _generateMarkdownReport(report, markdownPath) {
        const formatTime = (ms) => {
            if (ms >= 1000) return `${(ms / 1000).toFixed(2)}s`;
            return `${ms.toFixed(0)}ms`;
        };

        const formatMemory = (mb) => {
            if (mb >= 1024) return `${(mb / 1024).toFixed(2)}GB`;
            return `${mb.toFixed(0)}MB`;
        };

        // è®¡ç®—å„æ¨¡å—çš„æ€»è€—æ—¶å’Œå æ¯”
        const moduleTimings = report.detailed.moduleTimings || {};

        const md = `# ğŸš€ æ™ºèƒ½ä»£ç åˆ†å—å·¥å…· - æ€§èƒ½æµ‹é€ŸæŠ¥å‘Š

## ğŸ“Š é¡¹ç›®åŸºæœ¬ä¿¡æ¯
- **é¡¹ç›®åç§°**: ${report.metadata.workspace.name}
- **é¡¹ç›®è·¯å¾„**: \`${report.metadata.workspace.path}\`
- **ç”¨æˆ·ID**: ${report.metadata.workspace.userId}
- **è®¾å¤‡ID**: ${report.metadata.workspace.deviceId}
- **åˆ†ææ—¶é—´**: ${new Date(report.metadata.generatedAt).toLocaleString('zh-CN')}
- **æ€»å¤„ç†æ—¶é—´**: **${formatTime(report.summary.totalDuration)}**

## ğŸ“ˆ å¤„ç†ç»“æœç»Ÿè®¡
| æŒ‡æ ‡ | æ•°é‡ | å¤‡æ³¨ |
|------|------|------|
| ğŸ“ æ‰«ææ–‡ä»¶æ€»æ•° | ${report.summary.totalFiles} | ç¬¦åˆæ¡ä»¶çš„ä»£ç æ–‡ä»¶ |
| â­ï¸ è·³è¿‡æ–‡ä»¶æ•° | ${report.summary.skippedFiles} | è¢«è¿‡æ»¤å™¨æ’é™¤çš„æ–‡ä»¶ |
| âœ… æˆåŠŸå¤„ç†æ–‡ä»¶ | ${report.summary.processedFiles} | æˆåŠŸè§£æå¹¶åˆ†å—çš„æ–‡ä»¶ |
| ğŸ§© ç”Ÿæˆä»£ç å— | ${report.summary.totalChunks} | æ€»å…±ç”Ÿæˆçš„ä»£ç åˆ†å—æ•° |
| ğŸŒ Embeddingè¯·æ±‚ | ${report.summary.totalEmbeddingRequests} | å‘é€ç»™å‘é‡åŒ–æœåŠ¡çš„è¯·æ±‚æ•° |
| ğŸ“Š æ’å…¥å‘é‡æ•° | ${report.summary.insertedVectors} | æˆåŠŸæ’å…¥æ•°æ®åº“çš„å‘é‡æ•° |

## â±ï¸ å„é˜¶æ®µæ€§èƒ½åˆ†è§£
| é˜¶æ®µ | è€—æ—¶ | å æ€»æ—¶é—´æ¯”ä¾‹ | çŠ¶æ€ |
|------|------|-------------|------|
| ğŸ” æ–‡ä»¶æ‰«æ | ${formatTime(report.performance.breakdown.fileScanning?.duration || 0)} | ${report.performance.breakdown.fileScanning?.percentage || 0}% | ${(report.performance.breakdown.fileScanning?.percentage || 0) < 10 ? 'âœ… è‰¯å¥½' : (report.performance.breakdown.fileScanning?.percentage || 0) < 30 ? 'âš ï¸ ä¸€èˆ¬' : 'ğŸ”´ è¾ƒæ…¢'} |
| ğŸ”§ æ–‡ä»¶è§£æ | ${formatTime(report.performance.breakdown.fileParsing?.duration || 0)} | ${report.performance.breakdown.fileParsing?.percentage || 0}% | ${(report.performance.breakdown.fileParsing?.percentage || 0) < 20 ? 'âœ… è‰¯å¥½' : (report.performance.breakdown.fileParsing?.percentage || 0) < 40 ? 'âš ï¸ ä¸€èˆ¬' : 'ğŸ”´ è¾ƒæ…¢'} |
| ğŸ§  Embeddingç”Ÿæˆ | ${formatTime(report.performance.breakdown.embeddingGeneration?.duration || 0)} | ${report.performance.breakdown.embeddingGeneration?.percentage || 0}% | ${(report.performance.breakdown.embeddingGeneration?.percentage || 0) < 40 ? 'âœ… è‰¯å¥½' : (report.performance.breakdown.embeddingGeneration?.percentage || 0) < 60 ? 'âš ï¸ ä¸€èˆ¬' : 'ğŸ”´ è¾ƒæ…¢'} |
| ğŸ—„ï¸ å‘é‡æ•°æ®åº“ | ${formatTime(report.performance.breakdown.vectorDatabase?.duration || 0)} | ${report.performance.breakdown.vectorDatabase?.percentage || 0}% | ${(report.performance.breakdown.vectorDatabase?.percentage || 0) < 20 ? 'âœ… è‰¯å¥½' : (report.performance.breakdown.vectorDatabase?.percentage || 0) < 40 ? 'âš ï¸ ä¸€èˆ¬' : 'ğŸ”´ è¾ƒæ…¢'} |

## ğŸ”§ æ¨¡å—è¯¦ç»†è€—æ—¶åˆ†æ

### ğŸ“‚ FileScanner (æ–‡ä»¶æ‰«æå™¨)
- **åˆå§‹åŒ–æ—¶é—´**: ${formatTime(moduleTimings.fileScanner?.initTime || 0)}
- **æ‰«ææ—¶é—´**: ${formatTime(moduleTimings.fileScanner?.scanTime || 0)}
- **è¿‡æ»¤æ—¶é—´**: ${formatTime(moduleTimings.fileScanner?.filterTime || 0)}

### ğŸ” ParserSelector (è§£æå™¨é€‰æ‹©å™¨)
- **åˆå§‹åŒ–æ—¶é—´**: ${formatTime(moduleTimings.parserSelector?.initTime || 0)}
- **è§£ææ—¶é—´**: ${formatTime(moduleTimings.parserSelector?.parseTime || 0)}
- **åˆ†å—æ—¶é—´**: ${formatTime(moduleTimings.parserSelector?.chunkTime || 0)}

### ğŸš€ Dispatcher (ä»»åŠ¡è°ƒåº¦å™¨)
- **åˆå§‹åŒ–æ—¶é—´**: ${formatTime(moduleTimings.dispatcher?.initTime || 0)}
- **è°ƒåº¦æ—¶é—´**: ${formatTime(moduleTimings.dispatcher?.dispatchTime || 0)}
- **Workerå¤„ç†æ—¶é—´**: ${formatTime(moduleTimings.dispatcher?.workerTime || 0)}

### ğŸ“¤ Sender (æ•°æ®å‘é€å™¨)
- **åˆå§‹åŒ–æ—¶é—´**: ${formatTime(moduleTimings.sender?.initTime || 0)}
- **å‡†å¤‡æ—¶é—´**: ${formatTime(moduleTimings.sender?.prepareTime || 0)}
- **å‘é€æ—¶é—´**: ${formatTime(moduleTimings.sender?.sendTime || 0)}
- **æ‰¹å¤„ç†æ—¶é—´**: ${formatTime(moduleTimings.sender?.batchTime || 0)}

### ğŸ“Š VectorManager (å‘é‡ç®¡ç†å™¨)
- **åˆå§‹åŒ–æ—¶é—´**: ${formatTime(moduleTimings.vectorManager?.initTime || 0)}
- **ç¼“å­˜æ“ä½œæ—¶é—´**: ${formatTime(moduleTimings.vectorManager?.cacheTime || 0)}
- **æ•°æ®åº“æ“ä½œæ—¶é—´**: ${formatTime(moduleTimings.vectorManager?.dbTime || 0)}
- **å‘é‡åŒ–æ—¶é—´**: ${formatTime(moduleTimings.vectorManager?.embeddingTime || 0)}

### ğŸŒ³ MerkleTree (é»˜å…‹å°”æ ‘)
- **æ„å»ºæ—¶é—´**: ${formatTime(moduleTimings.merkleTree?.buildTime || 0)}
- **è¯æ˜ç”Ÿæˆæ—¶é—´**: ${formatTime(moduleTimings.merkleTree?.proofTime || 0)}

## ğŸŒ ç½‘ç»œæ€§èƒ½åˆ†æ

### EmbeddingæœåŠ¡ç½‘ç»œè¡¨ç°
- **æ€»è¯·æ±‚æ•°**: ${report.detailed.networkRequests.embedding?.count || 0}
- **æ€»ç½‘ç»œæ—¶é—´**: ${formatTime(report.detailed.networkRequests.embedding?.totalTime || 0)}
- **å¹³å‡è¯·æ±‚æ—¶é—´**: ${formatTime(report.detailed.networkRequests.embedding?.averageTime || 0)}
- **æœ€å¿«è¯·æ±‚**: ${formatTime(report.detailed.networkRequests.embedding?.minTime === Infinity ? 0 : report.detailed.networkRequests.embedding?.minTime || 0)}
- **æœ€æ…¢è¯·æ±‚**: ${formatTime(report.detailed.networkRequests.embedding?.maxTime || 0)}
- **å¤±è´¥æ¬¡æ•°**: ${report.detailed.networkRequests.embedding?.failures || 0}
- **æˆåŠŸç‡**: ${report.detailed.networkRequests.embedding?.count > 0 ? (((report.detailed.networkRequests.embedding.count - (report.detailed.networkRequests.embedding.failures || 0)) / report.detailed.networkRequests.embedding.count) * 100).toFixed(1) : 0}%

### å‘é‡æ•°æ®åº“ç½‘ç»œè¡¨ç°
- **æ€»è¯·æ±‚æ•°**: ${report.detailed.networkRequests.vectorDB?.count || 0}
- **æ€»ç½‘ç»œæ—¶é—´**: ${formatTime(report.detailed.networkRequests.vectorDB?.totalTime || 0)}
- **å¹³å‡è¯·æ±‚æ—¶é—´**: ${formatTime(report.detailed.networkRequests.vectorDB?.averageTime || 0)}
- **æ’å…¥æ“ä½œæ•°**: ${report.detailed.networkRequests.vectorDB?.insertOperations || 0}
- **æŸ¥è¯¢æ“ä½œæ•°**: ${report.detailed.networkRequests.vectorDB?.queryOperations || 0}
- **å¤±è´¥æ¬¡æ•°**: ${report.detailed.networkRequests.vectorDB?.failures || 0}

## ğŸ—„ï¸ æ•°æ®åº“æ“ä½œè¯¦æƒ…
| æ“ä½œç±»å‹ | æ‰§è¡Œæ¬¡æ•° | æ€»è€—æ—¶ | å¹³å‡è€—æ—¶ |
|---------|---------|--------|----------|
| åˆ›å»ºé›†åˆ | ${report.detailed.vectorDatabase.collectionOps?.create?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.create?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.create?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.create.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.create.count) : '0ms'} |
| åˆ é™¤é›†åˆ | ${report.detailed.vectorDatabase.collectionOps?.delete?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.delete?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.delete?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.delete.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.delete.count) : '0ms'} |
| æ’å…¥å‘é‡ | ${report.detailed.vectorDatabase.collectionOps?.insert?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.insert?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.insert?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.insert.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.insert.count) : '0ms'} |
| æŸ¥è¯¢å‘é‡ | ${report.detailed.vectorDatabase.collectionOps?.query?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.query?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.query?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.query.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.query.count) : '0ms'} |

## ğŸš¨ æ€§èƒ½ç“¶é¢ˆè¯†åˆ«
${report.performance.bottlenecks.length > 0 ? 
  report.performance.bottlenecks.map(b => `### ${b.impact === 'high' ? 'ğŸ”´' : b.impact === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢'} ${b.phase} (${b.impact === 'high' ? 'é«˜å½±å“' : b.impact === 'medium' ? 'ä¸­ç­‰å½±å“' : 'ä½å½±å“'})
- **é—®é¢˜**: ${b.description}
- **å½±å“ç¨‹åº¦**: ${b.percentage ? `å æ€»æ—¶é—´ ${b.percentage}%` : b.failureRate ? `å¤±è´¥ç‡ ${b.failureRate}%` : b.count ? `å¤±è´¥ ${b.count} æ¬¡` : 'å½±å“è¾ƒå°'}`).join('\n\n') : 
  'âœ… æœªæ£€æµ‹åˆ°æ˜æ˜¾çš„æ€§èƒ½ç“¶é¢ˆï¼Œæ•´ä½“è¿è¡Œè‰¯å¥½ï¼'
}

## ğŸ’¡ æ€§èƒ½ä¼˜åŒ–å»ºè®®
${report.performance.recommendations.length > 0 ? 
  report.performance.recommendations.map(r => `### ${r.priority === 'high' ? 'ğŸ”´' : r.priority === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢'} ${r.category} (${r.priority === 'high' ? 'é«˜ä¼˜å…ˆçº§' : r.priority === 'medium' ? 'ä¸­ä¼˜å…ˆçº§' : 'ä½ä¼˜å…ˆçº§'})
- **å»ºè®®**: ${r.suggestion}
- **é¢„æœŸæ•ˆæœ**: ${r.impact}`).join('\n\n') : 
  'âœ… å½“å‰æ€§èƒ½è¡¨ç°è‰¯å¥½ï¼Œæš‚æ— ç‰¹æ®Šä¼˜åŒ–å»ºè®®ã€‚'
}

## ğŸ–¥ï¸ ç³»ç»Ÿç¯å¢ƒä¿¡æ¯
- **æ“ä½œç³»ç»Ÿ**: ${report.metadata.system.platform} (${report.metadata.system.arch})
- **Node.jsç‰ˆæœ¬**: ${report.metadata.system.nodeVersion}
- **CPUæ ¸å¿ƒæ•°**: ${report.metadata.system.cpuCount}
- **ç³»ç»Ÿæ€»å†…å­˜**: ${formatMemory(report.metadata.system.totalMemory)}
- **è¿›ç¨‹ID**: ${report.detailed.systemResources.processId}

## ğŸ“Š å†…å­˜ä½¿ç”¨æƒ…å†µ
- **åˆå§‹å†…å­˜**: ${formatMemory(report.detailed.systemResources.initialMemory)}
- **å³°å€¼å†…å­˜**: ${formatMemory(report.detailed.systemResources.peakMemory)}
- **ç»“æŸå†…å­˜**: ${formatMemory(report.detailed.systemResources.finalMemory)}
- **å†…å­˜å¢é•¿**: ${formatMemory(report.detailed.systemResources.finalMemory - report.detailed.systemResources.initialMemory)}

## ğŸ“ˆ æ€§èƒ½è¯„åˆ†

### ğŸ¯ æ€»ä½“æ€§èƒ½è¯„åˆ†
${this._calculatePerformanceScore(report)}/100 åˆ†

### ğŸ“‹ è¯„åˆ†è¯´æ˜
- **90-100åˆ†**: ğŸ† ä¼˜ç§€ - æ€§èƒ½è¡¨ç°å“è¶Š
- **80-89åˆ†**: ğŸ¥‡ è‰¯å¥½ - æ€§èƒ½è¡¨ç°è‰¯å¥½
- **70-79åˆ†**: ğŸ¥ˆ ä¸€èˆ¬ - æ€§èƒ½å¯æ¥å—ï¼Œæœ‰ä¼˜åŒ–ç©ºé—´
- **60-69åˆ†**: ğŸ¥‰ è¾ƒå·® - å­˜åœ¨æ˜æ˜¾æ€§èƒ½é—®é¢˜
- **<60åˆ†**: âŒ å·® - éœ€è¦ç«‹å³ä¼˜åŒ–

---

**ğŸ“‹ æŠ¥å‘Šç”Ÿæˆæ—¶é—´**: ${new Date().toLocaleString('zh-CN')}  
**ğŸ”§ ç”Ÿæˆå·¥å…·**: æ™ºèƒ½ä»£ç åˆ†å—å·¥å…· v0.1.0  
**ğŸ“ æŠ¥å‘Šä½ç½®**: \`${markdownPath}\`

> ğŸ’¡ **æç¤º**: æ­¤æŠ¥å‘ŠåŒ…å«äº†é¡¹ç›®å¤„ç†çš„è¯¦ç»†æ€§èƒ½æ•°æ®ï¼Œå»ºè®®å®šæœŸç”ŸæˆæŠ¥å‘Šä»¥ç›‘æ§æ€§èƒ½è¶‹åŠ¿ã€‚å¦‚æœ‰æ€§èƒ½é—®é¢˜ï¼Œè¯·å‚è€ƒä¸Šè¿°ä¼˜åŒ–å»ºè®®è¿›è¡Œæ”¹è¿›ã€‚
`;

        await fs.writeFile(markdownPath, md, 'utf8');
        console.log(`ğŸ“„ [æ€§èƒ½åˆ†æ] è¯¦ç»†æµ‹é€ŸæŠ¥å‘Šå·²ç”Ÿæˆ: ${markdownPath}`);
    }

    /**
     * è®¡ç®—æ€§èƒ½è¯„åˆ†
     */
    _calculatePerformanceScore(report) {
        let score = 100;
        
        // æ ¹æ®å„é˜¶æ®µè€—æ—¶å æ¯”æ‰£åˆ†
        const breakdown = report.performance.breakdown;
        if (breakdown.fileScanning?.percentage > 30) score -= 10;
        if (breakdown.fileParsing?.percentage > 40) score -= 15;
        if (breakdown.embeddingGeneration?.percentage > 60) score -= 20;
        if (breakdown.vectorDatabase?.percentage > 40) score -= 15;
        
        // æ ¹æ®å¤±è´¥ç‡æ‰£åˆ†
        const embeddingFailureRate = (report.detailed.embeddingGeneration.failedRequests || 0) / 
                                   Math.max(report.detailed.embeddingGeneration.totalRequests || 1, 1);
        if (embeddingFailureRate > 0.1) score -= 20;
        if (embeddingFailureRate > 0.05) score -= 10;
        
        // æ ¹æ®Workerå¤±è´¥ç‡æ‰£åˆ†
        const workerFailureRate = (report.detailed.fileParsing.workerCreationFailures || 0) / 
                                 Math.max(report.detailed.fileParsing.totalFiles || 1, 1);
        if (workerFailureRate > 0.3) score -= 15;
        if (workerFailureRate > 0.1) score -= 5;
        
        return Math.max(score, 0);
    }
}

module.exports = PerformanceAnalyzer; 

/***/ }),
/* 239 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerSearchCommands = registerSearchCommands;
const vscode = __importStar(__webpack_require__(2));
const searchService_1 = __webpack_require__(240);
let searchService;
/**
 * æ³¨å†Œæœç´¢ç›¸å…³çš„æ‰€æœ‰å‘½ä»¤
 */
function registerSearchCommands(context) {
    // åˆå§‹åŒ–æœåŠ¡
    searchService = new searchService_1.SearchService();
    // æ³¨å†Œæ™ºèƒ½ä»£ç æœç´¢å‘½ä»¤
    const searchCodeCommand = vscode.commands.registerCommand('test-electron-treesitter.searchCode', async (searchString) => {
        try {
            await searchService.performCodeSearch(searchString);
        }
        catch (error) {
            console.error('[CodeChunker] ä»£ç æœç´¢é”™è¯¯:', error);
            vscode.window.showErrorMessage(`ä»£ç æœç´¢å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œé…ç½®å‘½ä»¤
    const configureCommand = vscode.commands.registerCommand('test-electron-treesitter.configure', async () => {
        try {
            await searchService.showConfiguration();
        }
        catch (error) {
            console.error('[CodeChunker] é…ç½®é”™è¯¯:', error);
            vscode.window.showErrorMessage(`é…ç½®å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // æ³¨å†Œåˆ é™¤Collectionå‘½ä»¤
    const deleteCollectionCommand = vscode.commands.registerCommand('test-electron-treesitter.deleteCollection', async () => {
        try {
            await searchService.deleteCloudCollection();
        }
        catch (error) {
            console.error('[CodeChunker] åˆ é™¤Collectioné”™è¯¯:', error);
            vscode.window.showErrorMessage(`åˆ é™¤Collectionå¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // ä¿ç•™åŸæœ‰çš„ Hello World å‘½ä»¤
    const helloWorldCommand = vscode.commands.registerCommand('test-electron-treesitter.helloWorld', () => {
        vscode.window.showInformationMessage('Hello World from test-electron-treeSitter!');
    });
    context.subscriptions.push(searchCodeCommand, configureCommand, deleteCollectionCommand, helloWorldCommand);
    console.log('[CodeChunker] æœç´¢ç›¸å…³å‘½ä»¤å·²æ³¨å†Œ');
}


/***/ }),
/* 240 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchService = void 0;
const vscode = __importStar(__webpack_require__(2));
const path = __importStar(__webpack_require__(4));
const searchResultView_1 = __webpack_require__(241);
const commonViews_1 = __webpack_require__(6);
// å¯¼å…¥ code-chunker æ¨¡å—
const codeChunker = __webpack_require__(9);
class SearchService {
    /**
     * æ‰§è¡Œæ™ºèƒ½ä»£ç æœç´¢
     */
    async performCodeSearch(searchString) {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
            return "è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº";
        }
        // è·å–é…ç½®
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        // æ£€æŸ¥å¿…è¦çš„é…ç½®
        if (!userId || !deviceId || !token) {
            const result = await vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯ï¼ˆç”¨æˆ·IDã€è®¾å¤‡IDæˆ–Tokenï¼‰ï¼Œæ˜¯å¦ç°åœ¨é…ç½®ï¼Ÿ', 'å»é…ç½®', 'å–æ¶ˆ');
            if (result === 'å»é…ç½®') {
                await this.showConfiguration();
            }
            return;
        }
        // è·å–æœç´¢æŸ¥è¯¢ - æ”¯æŒä¼ å…¥å‚æ•°æˆ–å¼¹å‡ºè¾“å…¥æ¡†
        let searchQuery;
        if (searchString && searchString.trim().length > 0) {
            // ä½¿ç”¨ä¼ å…¥çš„æœç´¢å­—ç¬¦ä¸²
            searchQuery = searchString.trim();
            // éªŒè¯ä¼ å…¥çš„æœç´¢å­—ç¬¦ä¸²
            if (searchQuery.length < 2) {
                vscode.window.showErrorMessage('æœç´¢å…³é”®è¯è‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦');
                return;
            }
        }
        else {
            // æ²¡æœ‰ä¼ å…¥å‚æ•°ï¼Œæ˜¾ç¤ºè¾“å…¥æ¡†
            const inputResult = await vscode.window.showInputBox({
                prompt: 'è¯·è¾“å…¥æœç´¢å…³é”®è¯',
                placeHolder: 'ä¾‹å¦‚: function, class, import, ç­‰...',
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return 'æœç´¢å…³é”®è¯ä¸èƒ½ä¸ºç©º';
                    }
                    if (value.trim().length < 2) {
                        return 'æœç´¢å…³é”®è¯è‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦';
                    }
                    return null;
                }
            });
            if (!inputResult) {
                return; // ç”¨æˆ·å–æ¶ˆäº†è¾“å…¥
            }
            searchQuery = inputResult.trim();
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        const workspaceName = path.basename(workspacePath);
        // æ˜¾ç¤ºæœç´¢è¿›åº¦
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: 'æ™ºèƒ½ä»£ç æœç´¢ä¸­...',
            cancellable: false
        }, async (progress) => {
            try {
                progress.report({ increment: 0, message: 'åˆå§‹åŒ–æœç´¢ç¯å¢ƒ...' });
                // è·å–chunkerå®ä¾‹
                const chunkerInstance = codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
                progress.report({ increment: 20, message: 'è¿æ¥å‘é‡æ•°æ®åº“...' });
                // ç¡®ä¿VectorManagerå·²åˆå§‹åŒ–
                if (!chunkerInstance.vectorManager) {
                    throw new Error('VectorManageræœªåˆå§‹åŒ–ï¼Œè¯·å…ˆè¿è¡Œä»£ç åˆ†å—å¤„ç†');
                }
                await chunkerInstance.vectorManager.initialize();
                if (!chunkerInstance.vectorManager.vectorDB || !chunkerInstance.vectorManager.vectorDB.implementation) {
                    throw new Error('å‘é‡æ•°æ®åº“è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥é…ç½®æˆ–å…ˆè¿è¡Œä»£ç åˆ†å—');
                }
                progress.report({ increment: 40, message: 'æ‰§è¡Œå‘é‡æœç´¢...' });
                // æ‰§è¡Œæœç´¢
                if (!chunkerInstance.search || typeof chunkerInstance.search !== 'function') {
                    throw new Error('æœç´¢åŠŸèƒ½æœªå¯ç”¨ï¼Œè¯·å…ˆè¿è¡Œä»£ç åˆ†å—å¤„ç†');
                }
                const searchResults = await chunkerInstance.search(searchQuery, { topK: 10 });
                progress.report({ increment: 80, message: 'å¤„ç†æœç´¢ç»“æœ...' });
                if (!searchResults || searchResults.length === 0) {
                    vscode.window.showInformationMessage(`æœªæ‰¾åˆ°ä¸"${searchQuery}"ç›¸å…³çš„ä»£ç ç‰‡æ®µ`);
                    return;
                }
                progress.report({ increment: 100, message: 'æœç´¢å®Œæˆï¼' });
                // æ˜¾ç¤ºæœç´¢ç»“æœ
                await searchResultView_1.SearchResultView.displaySearchResults(searchQuery, searchResults, workspaceName);
            }
            catch (error) {
                console.error('[CodeChunker] æœç´¢å¤±è´¥:', error);
                vscode.window.showErrorMessage(`æœç´¢å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
    }
    /**
     * æ˜¾ç¤ºé…ç½®ç•Œé¢
     */
    async showConfiguration() {
        return await commonViews_1.CommonViews.showConfiguration();
    }
    /**
     * åˆ é™¤äº‘ç«¯Collection
     */
    async deleteCloudCollection() {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
            return;
        }
        // è·å–é…ç½®
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        // æ£€æŸ¥å¿…è¦çš„é…ç½®
        if (!userId || !deviceId || !token) {
            vscode.window.showErrorMessage('ç¼ºå°‘å¿…è¦çš„é…ç½®ä¿¡æ¯ï¼ˆç”¨æˆ·IDã€è®¾å¤‡IDæˆ–Tokenï¼‰ï¼Œè¯·å…ˆé…ç½®');
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        const workspaceName = path.basename(workspacePath);
        // ç¡®è®¤åˆ é™¤
        const confirmation = await vscode.window.showWarningMessage(`ç¡®å®šè¦åˆ é™¤å·¥ä½œåŒº "${workspaceName}" åœ¨äº‘ç«¯çš„å‘é‡æ•°æ®å—ï¼Ÿ\n\næ­¤æ“ä½œä¸å¯æ’¤é”€ï¼`, { modal: true }, 'ç¡®å®šåˆ é™¤', 'å–æ¶ˆ');
        if (confirmation !== 'ç¡®å®šåˆ é™¤') {
            return;
        }
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: 'åˆ é™¤äº‘ç«¯Collection...',
            cancellable: false
        }, async (progress) => {
            try {
                progress.report({ increment: 0, message: 'è¿æ¥å‘é‡æ•°æ®åº“...' });
                // è·å–chunkerå®ä¾‹
                const chunkerInstance = codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
                if (!chunkerInstance.vectorManager) {
                    throw new Error('VectorManageræœªåˆå§‹åŒ–');
                }
                await chunkerInstance.vectorManager.initialize();
                if (!chunkerInstance.vectorManager.vectorDB || !chunkerInstance.vectorManager.vectorDB.implementation) {
                    throw new Error('å‘é‡æ•°æ®åº“è¿æ¥å¤±è´¥');
                }
                progress.report({ increment: 30, message: 'ç”ŸæˆCollectionåç§°...' });
                // ç”Ÿæˆcollectionåç§°
                const crypto = __webpack_require__(8);
                const hasher = crypto.createHash('sha256');
                hasher.update(`${userId}_${deviceId}_${workspacePath}`);
                const collectionName = hasher.digest('hex');
                const databaseName = 'vectorservice-test';
                progress.report({ increment: 50, message: 'åˆ é™¤Collection...' });
                // åˆ é™¤collection
                const result = await chunkerInstance.vectorManager.vectorDB.implementation.dropCollection(databaseName, collectionName);
                progress.report({ increment: 90, message: 'éªŒè¯åˆ é™¤ç»“æœ...' });
                // éªŒè¯åˆ é™¤æ˜¯å¦æˆåŠŸ
                try {
                    const collections = await chunkerInstance.vectorManager.vectorDB.implementation.listCollections(databaseName);
                    const collectionExists = collections && collections.collections &&
                        collections.collections.some((col) => col.collectionName === collectionName);
                    if (collectionExists) {
                        throw new Error('Collectionåˆ é™¤å¤±è´¥ï¼Œä»ç„¶å­˜åœ¨äºæ•°æ®åº“ä¸­');
                    }
                }
                catch (listError) {
                    console.warn('æ— æ³•éªŒè¯åˆ é™¤ç»“æœ:', listError);
                }
                progress.report({ increment: 100, message: 'åˆ é™¤å®Œæˆï¼' });
                vscode.window.showInformationMessage(`å·¥ä½œåŒº "${workspaceName}" çš„äº‘ç«¯å‘é‡æ•°æ®å·²æˆåŠŸåˆ é™¤ï¼\n\n` +
                    `Collection: ${collectionName.substring(0, 16)}...`);
            }
            catch (error) {
                console.error('[CodeChunker] åˆ é™¤Collectionå¤±è´¥:', error);
                vscode.window.showErrorMessage(`åˆ é™¤Collectionå¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
    }
}
exports.SearchService = SearchService;


/***/ }),
/* 241 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchResultView = void 0;
const vscode = __importStar(__webpack_require__(2));
const fs = __importStar(__webpack_require__(5));
const path = __importStar(__webpack_require__(4));
class SearchResultView {
    /**
     * æ˜¾ç¤ºæœç´¢ç»“æœ
     */
    static async displaySearchResults(query, results, workspaceName) {
        const outputChannel = vscode.window.createOutputChannel(`ä»£ç æœç´¢ç»“æœ - ${workspaceName}`);
        try {
            outputChannel.clear();
            outputChannel.appendLine(`ğŸ“Š æ™ºèƒ½ä»£ç æœç´¢ç»“æœ`);
            outputChannel.appendLine(`ğŸ” æœç´¢å…³é”®è¯: "${query}"`);
            outputChannel.appendLine(`ğŸ“ å·¥ä½œåŒº: ${workspaceName}`);
            outputChannel.appendLine(`ğŸ“ˆ æ‰¾åˆ°ç»“æœ: ${results.length} ä¸ªç›¸å…³ä»£ç ç‰‡æ®µ`);
            outputChannel.appendLine(`â° æœç´¢æ—¶é—´: ${new Date().toLocaleString()}`);
            outputChannel.appendLine(`${'='.repeat(80)}\n`);
            // æŒ‰å¾—åˆ†æ’åºç»“æœ
            results.sort((a, b) => (b.score || 0) - (a.score || 0));
            // æ˜¾ç¤ºæ¯ä¸ªæœç´¢ç»“æœ
            results.forEach((result, index) => {
                const score = result.score ? (result.score * 100).toFixed(1) : 'N/A';
                const fileName = result.fileName || result.filePath || 'unknown';
                const filePath = result.filePath || '';
                outputChannel.appendLine(`ğŸ“„ ç»“æœ ${index + 1}: ${fileName}`);
                outputChannel.appendLine(`   ğŸ“ è·¯å¾„: ${filePath}`);
                outputChannel.appendLine(`   ğŸ¯ ç›¸ä¼¼åº¦: ${score}%`);
                if (result.content) {
                    // é™åˆ¶å†…å®¹æ˜¾ç¤ºé•¿åº¦
                    const maxLength = 200;
                    let content = result.content.trim();
                    if (content.length > maxLength) {
                        content = content.substring(0, maxLength) + '...';
                    }
                    // é«˜äº®æ˜¾ç¤ºæŸ¥è¯¢å…³é”®è¯
                    const highlightedContent = this.highlightQuery(content, query);
                    outputChannel.appendLine(`   ğŸ“ å†…å®¹é¢„è§ˆ:`);
                    outputChannel.appendLine(`      ${highlightedContent.replace(/\n/g, '\n      ')}`);
                }
                outputChannel.appendLine('');
            });
            outputChannel.appendLine(`${'='.repeat(80)}`);
            outputChannel.appendLine(`ğŸ’¡ æç¤º: åŒå‡»ç»“æœåˆ—è¡¨ä¸­çš„æ–‡ä»¶å¯ä»¥ç›´æ¥æ‰“å¼€`);
            // æ˜¾ç¤ºè¾“å‡ºé¢æ¿
            outputChannel.show(true);
            // æä¾›äº¤äº’å¼é€‰æ‹©
            await this.showSearchResultPicker(results, workspaceName);
        }
        catch (error) {
            console.error('[SearchResultView] æ˜¾ç¤ºæœç´¢ç»“æœå¤±è´¥:', error);
            vscode.window.showErrorMessage(`æ˜¾ç¤ºæœç´¢ç»“æœå¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * é«˜äº®æ˜¾ç¤ºæŸ¥è¯¢å…³é”®è¯
     */
    static highlightQuery(content, query) {
        if (!query || !content)
            return content;
        try {
            // ç®€å•çš„å…³é”®è¯é«˜äº® (ç”¨ >> << åŒ…å›´)
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return content.replace(regex, '>>$1<<');
        }
        catch (error) {
            return content;
        }
    }
    /**
     * æ˜¾ç¤ºæœç´¢ç»“æœé€‰æ‹©å™¨
     */
    static async showSearchResultPicker(results, workspaceName) {
        if (!results || results.length === 0) {
            return;
        }
        const quickPickItems = results.map((result, index) => {
            const score = result.score ? (result.score * 100).toFixed(1) : 'N/A';
            const fileName = result.fileName || result.filePath || 'unknown';
            const filePath = result.filePath || '';
            return {
                label: `$(file-code) ${fileName}`,
                description: `ç›¸ä¼¼åº¦: ${score}%`,
                detail: filePath,
                result: result,
                index: index
            };
        });
        const selected = await vscode.window.showQuickPick(quickPickItems, {
            placeHolder: `é€‰æ‹©è¦æ‰“å¼€çš„æ–‡ä»¶ (å…±æ‰¾åˆ° ${results.length} ä¸ªç»“æœ)`,
            matchOnDescription: true,
            matchOnDetail: true
        });
        if (selected) {
            await this.openSearchResultFile(selected.result);
        }
    }
    /**
     * æ‰“å¼€æœç´¢ç»“æœæ–‡ä»¶
     */
    static async openSearchResultFile(result) {
        try {
            if (!result || !result.filePath) {
                vscode.window.showErrorMessage('æ— æ•ˆçš„æ–‡ä»¶è·¯å¾„');
                return;
            }
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('è¯·å…ˆæ‰“å¼€ä¸€ä¸ªå·¥ä½œåŒº');
                return;
            }
            // æ„å»ºå®Œæ•´æ–‡ä»¶è·¯å¾„
            const fullPath = path.isAbsolute(result.filePath)
                ? result.filePath
                : path.join(workspaceFolder.uri.fsPath, result.filePath);
            // æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            if (!fs.existsSync(fullPath)) {
                vscode.window.showErrorMessage(`æ–‡ä»¶ä¸å­˜åœ¨: ${result.filePath}`);
                return;
            }
            // æ‰“å¼€æ–‡ä»¶
            const document = await vscode.workspace.openTextDocument(fullPath);
            const editor = await vscode.window.showTextDocument(document);
            // å¦‚æœæœ‰è¡Œå·ä¿¡æ¯ï¼Œè·³è½¬åˆ°æŒ‡å®šä½ç½®
            if (result.startLine && result.startLine > 0) {
                const startLine = Math.max(0, result.startLine - 1); // VS Code è¡Œå·ä»0å¼€å§‹
                const endLine = result.endLine ? Math.max(startLine, result.endLine - 1) : startLine;
                const range = new vscode.Range(startLine, 0, endLine, 0);
                editor.selection = new vscode.Selection(range.start, range.end);
                editor.revealRange(range, vscode.TextEditorRevealType.InCenter);
            }
            vscode.window.showInformationMessage(`å·²æ‰“å¼€æ–‡ä»¶: ${result.fileName || result.filePath}`);
        }
        catch (error) {
            console.error('[SearchResultView] æ‰“å¼€æ–‡ä»¶å¤±è´¥:', error);
            vscode.window.showErrorMessage(`æ‰“å¼€æ–‡ä»¶å¤±è´¥: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
exports.SearchResultView = SearchResultView;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

/**
 * VS Code æ‰©å±• - æ™ºèƒ½ä»£ç åˆ†å—å·¥å…·
 *
 * å‘½ä»¤ä½¿ç”¨ç¤ºä¾‹:
 * 1. æ‰‹åŠ¨æœç´¢: vscode.commands.executeCommand('test-electron-treesitter.searchCode')
 * 2. ç¨‹åºåŒ–æœç´¢: vscode.commands.executeCommand('test-electron-treesitter.searchCode', 'function')
 * 3. å…¶ä»–å‘½ä»¤:
 *    - 'test-electron-treesitter.chunkCode' - å¼€å§‹ä»£ç åˆ†å—
 *    - 'test-electron-treesitter.checkProgress' - æŸ¥çœ‹åˆ†å—è¿›åº¦
 *    - 'test-electron-treesitter.configure' - é…ç½®ä»£ç åˆ†å—å™¨
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = activate;
exports.deactivate = deactivate;
const chunkingCommands_1 = __webpack_require__(1);
const searchCommands_1 = __webpack_require__(239);
function activate(context) {
    console.log('[CodeChunker] æ‰©å±•å·²æ¿€æ´»');
    // æ¸…é™¤ä»£ç†ç¯å¢ƒå˜é‡é¿å…è¿æ¥é—®é¢˜
    clearProxyEnvironment();
    // æ³¨å†Œæ‰€æœ‰å‘½ä»¤
    (0, chunkingCommands_1.registerChunkingCommands)(context);
    (0, searchCommands_1.registerSearchCommands)(context);
    console.log('[CodeChunker] æ‰€æœ‰å‘½ä»¤å·²æ³¨å†Œ');
}
/**
 * æ¸…é™¤ä»£ç†ç¯å¢ƒå˜é‡
 */
function clearProxyEnvironment() {
    const proxyVars = ['HTTP_PROXY', 'HTTPS_PROXY', 'http_proxy', 'https_proxy', 'ALL_PROXY', 'all_proxy'];
    proxyVars.forEach(varName => {
        if (process.env[varName]) {
            console.log(`[CodeChunker] æ¸…é™¤ä»£ç†å˜é‡: ${varName}=${process.env[varName]}`);
            delete process.env[varName];
        }
    });
    process.env.NO_PROXY = '*';
    process.env.no_proxy = '*';
    console.log('[CodeChunker] ä»£ç†ç¯å¢ƒå˜é‡å·²æ¸…é™¤ï¼Œé¿å…ç½‘ç»œè¿æ¥é—®é¢˜');
}
function deactivate() {
    console.log('[CodeChunker] æ‰©å±•å·²åœç”¨');
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map